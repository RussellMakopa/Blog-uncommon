"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.esm.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! is-hotkey-esm */ \"(ssr)/./node_modules/is-hotkey-esm/dist/index.js\");\n/* harmony import */ var _sanity_block_tools__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @sanity/block-tools */ \"(ssr)/./node_modules/@sanity/block-tools/lib/index.mjs\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_throttle_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/throttle.js */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var _sanity_util_content__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @sanity/util/content */ \"(ssr)/./node_modules/@sanity/util/lib/content.mjs\");\n/* harmony import */ var lodash_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/debounce.js */ \"(ssr)/./node_modules/lodash/debounce.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_4__(rootName);\nfunction debugWithName(name) {\n  const namespace = `${rootName}${name}`;\n  return debug__WEBPACK_IMPORTED_MODULE_4__ && debug__WEBPACK_IMPORTED_MODULE_4__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_4__(namespace) : debug__WEBPACK_IMPORTED_MODULE_4__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n  const blockPath = [point.path[0]];\n  if (!value)\n    return null;\n  const block = value[blockPath[0]];\n  if (!block)\n    return null;\n  const keyedBlockPath = [{ _key: block._key }];\n  if (block._type !== types.block.name)\n    return keyedBlockPath;\n  let keyedChildPath;\n  const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n  return child && (keyedChildPath = [\"children\", { _key: child._key }]), keyedChildPath ? [...keyedBlockPath, ...keyedChildPath] : keyedBlockPath;\n}\nfunction createArrayedPath(point, editor) {\n  if (!editor)\n    return [];\n  const [block, blockPath] = Array.from(\n    slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n      at: [],\n      match: (n) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isKeySegment)(point.path[0]) && n._key === point.path[0]._key\n    })\n  )[0] || [void 0, void 0];\n  if (!block || !slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block))\n    return [];\n  if (editor.isVoid(block))\n    return [blockPath[0], 0];\n  const childPath = [point.path[2]], childIndex = block.children.findIndex((child) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__([{ _key: child._key }], childPath));\n  if (childIndex >= 0 && block.children[childIndex]) {\n    const child = block.children[childIndex];\n    return slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n  }\n  return blockPath;\n}\nfunction toPortableTextRange(value, range, types) {\n  if (!range)\n    return null;\n  let anchor = null, focus = null;\n  const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n  anchorPath && range.anchor && (anchor = {\n    path: anchorPath,\n    offset: range.anchor.offset\n  });\n  const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n  focusPath && range.focus && (focus = {\n    path: focusPath,\n    offset: range.focus.offset\n  });\n  const backward = !!(slate__WEBPACK_IMPORTED_MODULE_13__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isBackward(range));\n  return anchor && focus ? { anchor, focus, backward } : null;\n}\nfunction toSlateRange(selection, editor) {\n  if (!selection || !editor)\n    return null;\n  const anchor = {\n    path: createArrayedPath(selection.anchor, editor),\n    offset: selection.anchor.offset\n  }, focus = {\n    path: createArrayedPath(selection.focus, editor),\n    offset: selection.focus.offset\n  };\n  return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? { anchor, focus } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n  const anchor = slate__WEBPACK_IMPORTED_MODULE_13__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_13__.Point.transform(range.focus, operation);\n  return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_13__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_13__.Point.equals(focus, range.focus) ? range : { anchor, focus };\n}\nfunction normalizePoint(point, value) {\n  if (!point || !value)\n    return null;\n  const newPath = [];\n  let newOffset = point.offset || 0;\n  const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);\n  if (block)\n    newPath.push({ _key: block._key });\n  else\n    return null;\n  if (block && point.path[1] === \"children\") {\n    if (!block.children || Array.isArray(block.children) && block.children.length === 0)\n      return null;\n    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);\n    if (child)\n      newPath.push(\"children\"), newPath.push({ _key: child._key }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n    else\n      return null;\n  }\n  return { path: newPath, offset: newOffset };\n}\nfunction normalizeSelection(selection, value) {\n  if (!selection || !value || value.length === 0)\n    return null;\n  let newAnchor = null, newFocus = null;\n  const { anchor, focus } = selection;\n  return anchor && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({ _key: blk._key }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({ _key: blk._key }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? { anchor: newAnchor, focus: newFocus, backward: selection.backward } : null;\n}\nconst EMPTY_MARKDEFS = [], EMPTY_MARKS$1 = [], VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n  const value = keyMap[object._key];\n  return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, { schemaTypes }, keyMap = {}) {\n  return value && Array.isArray(value) ? value.map((block) => {\n    const { _type, _key, ...rest } = block, voidChildren = [{ _key: VOID_CHILD_KEY, _type: \"span\", text: \"\", marks: [] }];\n    if (block && block._type === schemaTypes.block.name) {\n      const textBlock = block;\n      let hasInlines = !1;\n      const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child) => {\n        const { _type: cType, _key: cKey, ...cRest } = child;\n        return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality(\n          {\n            _type: cType,\n            _key: cKey,\n            children: voidChildren,\n            value: cRest,\n            __inline: !0\n          },\n          keyMap\n        )) : child;\n      });\n      return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({ _type, _key, ...rest, children }, keyMap));\n    }\n    return keepObjectEquality(\n      {\n        _type,\n        _key,\n        children: voidChildren,\n        value: rest\n      },\n      keyMap\n    );\n  }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n  return value.map((block) => {\n    const { _key, _type } = block;\n    if (!_key || !_type)\n      throw new Error(\"Not a valid block\");\n    if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n      let hasInlines = !1;\n      const children = block.children.map((child) => {\n        const { _type: _cType } = child;\n        if (\"value\" in child && _cType !== \"span\") {\n          hasInlines = !0;\n          const { value: v, _key: k, _type: t, __inline: _i, children: _c, ...rest } = child;\n          return keepObjectEquality({ ...rest, ...v, _key: k, _type: t }, keyMap);\n        }\n        return child;\n      });\n      return hasInlines ? keepObjectEquality({ ...block, children, _key, _type }, keyMap) : block;\n    }\n    const blockValue = \"value\" in block && block.value;\n    return keepObjectEquality(\n      { _key, _type, ...typeof blockValue == \"object\" ? blockValue : {} },\n      keyMap\n    );\n  });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n  var _a;\n  return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !((_a = children[0].children[0].marks) != null && _a.join(\"\")) && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_PROCESSING_LOCAL_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pre\", { children: JSON.stringify(props.value, null, 2) }) }), DefaultBlockObject = styled_components__WEBPACK_IMPORTED_MODULE_15__.styled.div`\n  user-select: none;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nstyled_components__WEBPACK_IMPORTED_MODULE_15__.styled.span`\n  background: #999;\n  border: ${(props) => props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nconst DefaultListItem = styled_components__WEBPACK_IMPORTED_MODULE_15__.styled.div`\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ${(props) => getLeftPositionForListLevel(props.listLevel)};\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '${(props) => getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ${(props) => getCounterIncrementForListLevel(props.listLevel)};\n    counter-reset: ${(props) => getCounterResetForListLevel(props.listLevel)};\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ${(props) => getCounterContentForListLevel(props.listLevel)};\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n`, DefaultListItemInner = styled_components__WEBPACK_IMPORTED_MODULE_15__.styled.div``;\nfunction getLeftPositionForListLevel(level) {\n  switch (Number(level)) {\n    case 1:\n      return \"1.5em\";\n    case 2:\n      return \"3em\";\n    case 3:\n      return \"4.5em\";\n    case 4:\n      return \"6em\";\n    case 5:\n      return \"7.5em\";\n    case 6:\n      return \"9em\";\n    case 7:\n      return \"10.5em\";\n    case 8:\n      return \"12em\";\n    case 9:\n      return \"13.5em\";\n    case 10:\n      return \"15em\";\n    default:\n      return \"0em\";\n  }\n}\nconst bullets = [\"\\u25CF\", \"\\u25CB\", \"\\u25A0\"];\nfunction getContentForListLevelAndStyle(level, style) {\n  const normalizedLevel = (level - 1) % 3;\n  return style === \"bullet\" ? bullets[normalizedLevel] : \"*\";\n}\nfunction getCounterIncrementForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemNumber\";\n    case 2:\n      return \"listItemAlpha\";\n    case 3:\n      return \"listItemRoman\";\n    case 4:\n      return \"listItemNumberNext\";\n    case 5:\n      return \"listItemLetterNext\";\n    case 6:\n      return \"listItemRomanNext\";\n    case 7:\n      return \"listItemNumberNextNext\";\n    case 8:\n      return \"listItemAlphaNextNext\";\n    case 9:\n      return \"listItemRomanNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterResetForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"listItemAlpha\";\n    case 2:\n      return \"listItemRoman\";\n    case 3:\n      return \"listItemNumberNext\";\n    case 4:\n      return \"listItemLetterNext\";\n    case 5:\n      return \"listItemRomanNext\";\n    case 6:\n      return \"listItemNumberNextNext\";\n    case 7:\n      return \"listItemAlphaNextNext\";\n    case 8:\n      return \"listItemRomanNextNext\";\n    case 9:\n      return \"listItemNumberNextNextNext\";\n    default:\n      return \"listItemNumberNextNextNext\";\n  }\n}\nfunction getCounterContentForListLevel(level) {\n  switch (level) {\n    case 1:\n      return \"counter(listItemNumber) '. '\";\n    case 2:\n      return \"counter(listItemAlpha, lower-alpha) '. '\";\n    case 3:\n      return \"counter(listItemRoman, lower-roman) '. '\";\n    case 4:\n      return \"counter(listItemNumberNext) '. '\";\n    case 5:\n      return \"counter(listItemLetterNext, lower-alpha) '. '\";\n    case 6:\n      return \"counter(listItemRomanNext, lower-roman) '. '\";\n    case 7:\n      return \"counter(listItemNumberNextNext) '. '\";\n    case 8:\n      return \"counter(listItemAlphaNextNext, lower-alpha) '. '\";\n    case 9:\n      return \"counter(listItemRomanNextNext, lower-roman) '. '\";\n    default:\n      return \"counter(listItemNumberNextNextNext) '. '\";\n  }\n}\nconst debug$k = debugWithName(\"components:DraggableBlock\"), DraggableBlock = ({ children, element, readOnly, blockRef }) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), isVoid = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, element), [editor, element]), isInline = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isInline(editor, element), [editor, element]), [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(\n    () => setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, element)),\n    [editor, element, blockRef]\n  );\n  const handleDragOver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n      if (!isMyDragOver || !blockElement)\n        return;\n      event.preventDefault(), event.dataTransfer.dropEffect = \"move\", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n      const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n      let position = \"bottom\";\n      if (element === editor.children[0] ? position = \"top\" : loc < height / 2 ? (position = \"top\", IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)) : (position = \"bottom\", IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, position)), isMyDragOver === element) {\n        event.dataTransfer.dropEffect = \"none\";\n        return;\n      }\n      setIsDragOver(!0);\n    },\n    [blockElement, editor, element]\n  ), handleDragLeave = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    setIsDragOver(!1);\n  }, []), handleDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);\n      if (targetBlock) {\n        IS_DRAGGING.set(editor, !1), event.preventDefault(), event.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$k(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n        const dragPosition2 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n        IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n        let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, targetBlock);\n        const myPath = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_13__.Path.isBefore(myPath, targetPath);\n        if (dragPosition2 === \"bottom\" && !isBefore) {\n          if (targetPath[0] >= editor.children.length - 1) {\n            debug$k(\"target is already at the bottom, not moving\");\n            return;\n          }\n          const originalPath = targetPath;\n          targetPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(targetPath), debug$k(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath\n            )}`\n          );\n        }\n        if (dragPosition2 === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n          const originalPath = targetPath;\n          targetPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.previous(targetPath), debug$k(\n            `Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(\n              targetPath\n            )}`\n          );\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(targetPath, myPath)) {\n          event.preventDefault(), debug$k(\"targetPath and myPath is the same, not moving\");\n          return;\n        }\n        debug$k(\n          `Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(\n            targetPath\n          )} (${dragPosition2})`\n        ), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.moveNodes(editor, { at: myPath, to: targetPath }), editor.onChange();\n        return;\n      }\n      debug$k(\"No target element, not doing anything\");\n    },\n    [editor, element]\n  ), handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$k(\"On drop (prevented)\", element), event.preventDefault(), event.stopPropagation(), setIsDragOver(!1));\n    },\n    [editor, element]\n  ), handleDrag = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      if (!isVoid) {\n        IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n        return;\n      }\n      IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event.stopPropagation();\n      const target = event.target;\n      target instanceof HTMLElement && (target.style.opacity = \"1\");\n    },\n    [editor, element, isVoid]\n  ), handleDragStart = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      if (!isVoid || isInline) {\n        debug$k(\"Not dragging block\"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);\n        return;\n      }\n      if (debug$k(\"Drag start\"), IS_DRAGGING.set(editor, !0), event.dataTransfer && (event.dataTransfer.setData(\"application/portable-text\", \"something\"), event.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n        let dragGhost = blockElement.cloneNode(!0);\n        const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n        if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n          dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n          const rect = blockElement.getBoundingClientRect(), x = event.clientX - rect.left, y = event.clientY - rect.top;\n          dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event.dataTransfer.setDragImage(dragGhost, x, y);\n        }\n      }\n      handleDrag(event);\n    },\n    [blockElement, editor, handleDrag, isInline, isVoid]\n  ), isDraggingOverFirstBlock = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), isDraggingOverLastBlock = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition === \"bottom\", dropIndicator = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      \"div\",\n      {\n        className: \"pt-drop-indicator\",\n        style: {\n          position: \"absolute\",\n          width: \"100%\",\n          height: 1,\n          borderBottom: \"1px solid currentColor\",\n          zIndex: 5\n        }\n      }\n    ),\n    []\n  );\n  return readOnly ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n    \"div\",\n    {\n      draggable: isVoid,\n      onDragStart: handleDragStart,\n      onDrag: handleDrag,\n      onDragOver: handleDragOver,\n      onDragLeave: handleDragLeave,\n      onDragEnd: handleDragEnd,\n      onDrop: handleDrop,\n      children: [\n        isDraggingOverTop && dropIndicator,\n        children,\n        isDraggingOverBottom && dropIndicator\n      ]\n    }\n  );\n};\ndebugWithName(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = { display: \"inline-block\" }, Element = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck\n}) => {\n  const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => fromSlateValue([element], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0],\n    [editor, element, schemaTypes.block.name]\n  );\n  let renderedBlock = children, className;\n  const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [{ _key: element._key }], [element]);\n  if (typeof element._type != \"string\")\n    throw new Error(\"Expected element to have a _type property\");\n  if (typeof element._key != \"string\")\n    throw new Error(\"Expected element to have a _key property\");\n  if (editor.isInline(element)) {\n    const path = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findPath(editor, element), [block2] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, path, { depth: 1 }), schemaType2 = schemaTypes.inlineObjects.find((_type) => _type.name === element._type);\n    if (!schemaType2)\n      throw new Error(\"Could not find type for inline block element\");\n    if (slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block2)) {\n      const elmPath = [{ _key: block2._key }, \"children\", { _key: element._key }];\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"span\", { ...attributes, children: [\n        children,\n        /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\n          \"span\",\n          {\n            draggable: !readOnly,\n            className: \"pt-inline-object\",\n            \"data-testid\": \"pt-inline-object\",\n            ref: inlineBlockObjectRef,\n            style: inlineBlockStyle,\n            contentEditable: !1,\n            children: [\n              renderChild && renderChild({\n                annotations: EMPTY_ANNOTATIONS,\n                // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }),\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType: schemaType2,\n                selected,\n                type: schemaType2,\n                value\n              }),\n              !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value })\n            ]\n          },\n          element._key\n        )\n      ] });\n    }\n    throw new Error(\"Block not found!\");\n  }\n  if (element._type === schemaTypes.block.name) {\n    className = \"pt-block pt-text-block\";\n    const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n    className = `pt-block pt-text-block pt-text-block-style-${style}`;\n    const blockStyleType = schemaTypes.styles.find((item) => item.value === style);\n    renderStyle && blockStyleType && (renderedBlock = renderStyle({\n      block: element,\n      children,\n      focused,\n      selected,\n      value: style,\n      path: blockPath,\n      schemaType: blockStyleType,\n      editorElementRef: blockRef\n    }));\n    let level;\n    if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find((item) => item.value === element.listItem);\n      renderListItem && listType ? renderedBlock = renderListItem({\n        block: value,\n        children: renderedBlock,\n        focused,\n        selected,\n        value: element.listItem,\n        path: blockPath,\n        schemaType: listType,\n        level: value.level || 1,\n        editorElementRef: blockRef\n      }) : renderedBlock = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n        DefaultListItem,\n        {\n          listStyle: value.listItem || schemaTypes.lists[0].value,\n          listLevel: value.level || 1,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultListItemInner, { children: renderedBlock })\n        }\n      );\n    }\n    const renderProps = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : void 0,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value\n      },\n      \"type\",\n      {\n        enumerable: !1,\n        get() {\n          return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n        }\n      }\n    ), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ...attributes, className, spellCheck, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DraggableBlock, { element, readOnly, blockRef, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, children: propsOrDefaultRendered }) }) }, element._key);\n  }\n  const schemaType = schemaTypes.blockObjects.find((_type) => _type.name === element._type);\n  if (!schemaType)\n    throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n  className = \"pt-block pt-object-block\";\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(editor)\n  )[0];\n  let renderedBlockFromProps;\n  if (renderBlock) {\n    const _props = Object.defineProperty(\n      {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }),\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block\n      },\n      \"type\",\n      {\n        enumerable: !1,\n        get() {\n          return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n        }\n      }\n    );\n    renderedBlockFromProps = renderBlock(_props);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", { ...attributes, className, children: [\n    children,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(DraggableBlock, { element, readOnly, blockRef, children: [\n      renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: blockRef, contentEditable: !1, children: renderedBlockFromProps }),\n      !renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultBlockObject, { selected, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultObject, { value }) })\n    ] })\n  ] }, element._key);\n}, PortableTextEditorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null), usePortableTextEditor = () => {\n  const editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorContext);\n  if (!editor)\n    throw new Error(\n      \"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\"\n    );\n  return editor;\n};\nfunction DefaultAnnotation(props) {\n  const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => alert(JSON.stringify(props.annotation)), [props.annotation]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: { color: \"blue\" }, onClick: handleClick, children: props.children });\n}\nfunction getPortableTextMemberSchemaTypes(portableTextType) {\n  var _a, _b, _c;\n  if (!portableTextType)\n    throw new Error(\"Parameter 'portabletextType' missing (required)\");\n  const blockType = (_a = portableTextType.of) == null ? void 0 : _a.find(findBlockType);\n  if (!blockType)\n    throw new Error(\"Block type is not defined in this schema (required)\");\n  const childrenField = (_b = blockType.fields) == null ? void 0 : _b.find((field) => field.name === \"children\");\n  if (!childrenField)\n    throw new Error(\"Children field for block type found in schema (required)\");\n  const ofType = childrenField.type.of;\n  if (!ofType)\n    throw new Error(\"Valid types for block children not found in schema (required)\");\n  const spanType = ofType.find((memberType) => memberType.name === \"span\");\n  if (!spanType)\n    throw new Error(\"Span type not found in schema (required)\");\n  const inlineObjectTypes = ofType.filter((memberType) => memberType.name !== \"span\") || [], blockObjectTypes = ((_c = portableTextType.of) == null ? void 0 : _c.filter((field) => field.name !== blockType.name)) || [];\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: spanType.annotations\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  var _a, _b, _c;\n  const styleField = (_a = blockType.fields) == null ? void 0 : _a.find((btField) => btField.name === \"style\");\n  if (!styleField)\n    throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n  const textStyles = ((_b = styleField.type.options) == null ? void 0 : _b.list) && ((_c = styleField.type.options.list) == null ? void 0 : _c.filter((style) => style.value));\n  if (!textStyles || textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  var _a, _b;\n  const listField = (_a = blockType.fields) == null ? void 0 : _a.find((btField) => btField.name === \"listItem\");\n  if (!listField)\n    throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n  const listItems = ((_b = listField.type.options) == null ? void 0 : _b.list) && listField.type.options.list.filter((list) => list.value);\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction compileType(rawType) {\n  return _sanity_schema__WEBPACK_IMPORTED_MODULE_17__.Schema.compile({\n    name: \"blockTypeSchema\",\n    types: [rawType]\n  }).get(rawType.name);\n}\nconst debug$j = debugWithName(\"operationToPatches\");\ndebug$j.enabled = !1;\nfunction createOperationToPatches(types) {\n  const textBlockName = types.block.name;\n  function insertTextPatch(editor, operation, beforeValue) {\n    debug$j.enabled && debug$j(\"Operation\", JSON.stringify(operation, null, 2));\n    const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{ _key: block._key }, \"children\", { _key: textChild._key }, \"text\"], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.diffMatchPatch)(prevText, textChild.text, path);\n    return patch.value.length ? [patch] : [];\n  }\n  function removeTextPatch(editor, operation, beforeValue) {\n    const block = editor && editor.children[operation.path[0]];\n    if (!block)\n      throw new Error(\"Could not find block\");\n    const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n    if (child && !textChild)\n      throw new Error(\"Expected span\");\n    if (!textChild)\n      throw new Error(\"Could not find child\");\n    const path = [{ _key: block._key }, \"children\", { _key: textChild._key }, \"text\"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n    return patch.value ? [patch] : [];\n  }\n  function setNodePatch(editor, operation) {\n    if (operation.path.length === 1) {\n      const block = editor.children[operation.path[0]];\n      if (typeof block._key != \"string\")\n        throw new Error(\"Expected block to have a _key\");\n      const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_8__(\n        { ...editor.children[operation.path[0]], ...operation.newProperties },\n        lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_7__\n      );\n      return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(fromSlateValue([setNode], textBlockName)[0], [{ _key: block._key }])];\n    } else if (operation.path.length === 2) {\n      const block = editor.children[operation.path[0]];\n      if (editor.isTextBlock(block)) {\n        const child = block.children[operation.path[1]];\n        if (child) {\n          const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n          return keys.forEach((keyName) => {\n            if (keys.length === 1 && keyName === \"_key\") {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_6__(operation.newProperties, keyName);\n              patches.push(\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(val, [{ _key: blockKey }, \"children\", block.children.indexOf(child), keyName])\n              );\n            } else {\n              const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_6__(operation.newProperties, keyName);\n              patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(val, [{ _key: blockKey }, \"children\", { _key: childKey }, keyName]));\n            }\n          }), patches;\n        }\n        throw new Error(\"Could not find a valid child\");\n      }\n      throw new Error(\"Could not find a valid block\");\n    } else\n      throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n  }\n  function insertNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);\n    if (operation.path.length === 1) {\n      const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block == null ? void 0 : block._key : beforeBlock == null ? void 0 : beforeBlock._key;\n      return targetKey ? [\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([fromSlateValue([operation.node], textBlockName)[0]], position, [\n          { _key: targetKey }\n        ])\n      ] : [\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.setIfMissing)(beforeValue, []),\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([fromSlateValue([operation.node], textBlockName)[0]], \"before\", [\n          operation.path[0]\n        ])\n      ];\n    } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {\n      const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = { ...operation.node };\n      !node._type && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n      const child = fromSlateValue(\n        [\n          {\n            _key: \"bogus\",\n            _type: textBlockName,\n            children: [node]\n          }\n        ],\n        textBlockName\n      )[0].children[0];\n      return [\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([child], position, [\n          { _key: block._key },\n          \"children\",\n          block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : { _key: block.children[operation.path[1] - 1]._key }\n        ])\n      ];\n    }\n    return debug$j(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n  }\n  function splitNodePatch(editor, operation, beforeValue) {\n    const patches = [], splitBlock = editor.children[operation.path[0]];\n    if (!editor.isTextBlock(splitBlock))\n      throw new Error(\n        `Block with path ${JSON.stringify(\n          operation.path[0]\n        )} is not a text block and can't be split`\n      );\n    if (operation.path.length === 1) {\n      const oldBlock = beforeValue[operation.path[0]];\n      if (editor.isTextBlock(oldBlock)) {\n        const targetValue = fromSlateValue(\n          [editor.children[operation.path[0] + 1]],\n          textBlockName\n        )[0];\n        targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([targetValue], \"after\", [{ _key: splitBlock._key }])), oldBlock.children.slice(operation.position).forEach((span) => {\n          const path = [{ _key: oldBlock._key }, \"children\", { _key: span._key }];\n          patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)(path));\n        }));\n      }\n      return patches;\n    }\n    if (operation.path.length === 2) {\n      const splitSpan = splitBlock.children[operation.path[1]];\n      if (editor.isTextSpan(splitSpan)) {\n        const targetSpans = fromSlateValue(\n          [\n            {\n              ...splitBlock,\n              children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n            }\n          ],\n          textBlockName\n        )[0].children;\n        patches.push(\n          (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)(targetSpans, \"after\", [\n            { _key: splitBlock._key },\n            \"children\",\n            { _key: splitSpan._key }\n          ])\n        ), patches.push(\n          (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(splitSpan.text, [\n            { _key: splitBlock._key },\n            \"children\",\n            { _key: splitSpan._key },\n            \"text\"\n          ])\n        );\n      }\n      return patches;\n    }\n    return patches;\n  }\n  function removeNodePatch(editor, operation, beforeValue) {\n    const block = beforeValue[operation.path[0]];\n    if (operation.path.length === 1) {\n      if (block && block._key)\n        return [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }])];\n      throw new Error(\"Block not found\");\n    } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n      const spanToRemove = editor.isTextBlock(block) && block.children && block.children[operation.path[1]];\n      return spanToRemove ? [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }, \"children\", { _key: spanToRemove._key }])] : (debug$j(\"Span not found in editor trying to remove node\"), []);\n    } else\n      return debug$j(\"Not creating patch inside object block\"), [];\n  }\n  function mergeNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = editor.children[operation.path[0]];\n    if (operation.path.length === 1)\n      if (block != null && block._key) {\n        const newBlock = fromSlateValue([editor.children[operation.path[0] - 1]], textBlockName)[0];\n        patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(newBlock, [{ _key: newBlock._key }])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }]));\n      } else\n        throw new Error(\"Target key not found!\");\n    else if (operation.path.length === 2 && editor.isTextBlock(targetBlock)) {\n      const mergedSpan = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, targetSpan = targetBlock.children[operation.path[1] - 1];\n      editor.isTextSpan(targetSpan) && (patches.push(\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(targetSpan.text, [{ _key: block._key }, \"children\", { _key: targetSpan._key }, \"text\"])\n      ), mergedSpan && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }, \"children\", { _key: mergedSpan._key }])));\n    } else\n      debug$j(\"Void nodes can't be merged, not creating any patches\");\n    return patches;\n  }\n  function moveNodePatch(editor, operation, beforeValue) {\n    const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n    if (operation.path.length === 1) {\n      const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }])), patches.push(\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([fromSlateValue([block], textBlockName)[0]], position, [{ _key: targetBlock._key }])\n      );\n    } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n      const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([block], textBlockName)[0].children[operation.path[1]];\n      patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: block._key }, \"children\", { _key: child._key }])), patches.push(\n        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([childToInsert], position, [\n          { _key: targetBlock._key },\n          \"children\",\n          { _key: targetChild._key }\n        ])\n      );\n    }\n    return patches;\n  }\n  return {\n    insertNodePatch,\n    insertTextPatch,\n    mergeNodePatch,\n    moveNodePatch,\n    removeNodePatch,\n    removeTextPatch,\n    setNodePatch,\n    splitNodePatch\n  };\n}\nconst debug$i = debugWithName(\"API:editable\");\nfunction createWithEditableAPI(portableTextEditor, types, keyGenerator) {\n  return function(editor) {\n    return portableTextEditor.setEditable({\n      focus: () => {\n        slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.focus(editor);\n      },\n      blur: () => {\n        slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.blur(editor);\n      },\n      toggleMark: (mark) => {\n        editor.pteToggleMark(mark);\n      },\n      toggleList: (listStyle) => {\n        editor.pteToggleListItem(listStyle);\n      },\n      toggleBlockStyle: (blockStyle) => {\n        editor.pteToggleBlockStyle(blockStyle);\n      },\n      isMarkActive: (mark) => {\n        try {\n          return editor.pteIsMarkActive(mark);\n        } catch (err) {\n          return console.warn(err), !1;\n        }\n      },\n      marks: () => ({\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {}\n      }).marks || [],\n      undo: () => editor.undo(),\n      redo: () => editor.redo(),\n      select: (selection) => {\n        const slateSelection = toSlateRange(selection, editor);\n        slateSelection ? slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(editor), editor.onChange();\n      },\n      focusBlock: () => {\n        if (editor.selection) {\n          const block = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n          if (block)\n            return fromSlateValue([block], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n        }\n      },\n      focusChild: () => {\n        if (editor.selection) {\n          const block = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n          if (block && editor.isTextBlock(block))\n            return fromSlateValue(\n              [block],\n              types.block.name,\n              KEY_TO_VALUE_ELEMENT.get(editor)\n            )[0].children[editor.selection.focus.path[1]];\n        }\n      },\n      insertChild: (type, value) => {\n        var _a;\n        if (!editor.selection)\n          throw new Error(\"The editor has no selection\");\n        const [focusBlock] = Array.from(\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n            at: editor.selection.focus.path.slice(0, 1),\n            match: (n) => n._type === types.block.name\n          })\n        )[0] || [void 0];\n        if (!focusBlock)\n          throw new Error(\"No focused text block\");\n        if (type.name !== types.span.name && !types.inlineObjects.some((t) => t.name === type.name))\n          throw new Error(\"This type cannot be inserted as a child to a text block\");\n        const child = toSlateValue(\n          [\n            {\n              _key: keyGenerator(),\n              _type: types.block.name,\n              children: [\n                {\n                  _key: keyGenerator(),\n                  _type: type.name,\n                  ...value || {}\n                }\n              ]\n            }\n          ],\n          portableTextEditor\n        )[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_13__.Node.get(editor, focusChildPath);\n        return isSpanNode && focusNode._type !== types.span.name && (debug$i(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({ distance: 1, unit: \"character\" })), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, child, {\n          select: !0,\n          at: editor.selection\n        }), editor.onChange(), ((_a = toPortableTextRange(\n          fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n          editor.selection,\n          types\n        )) == null ? void 0 : _a.focus.path) || [];\n      },\n      insertBlock: (type, value) => {\n        var _a;\n        if (!editor.selection)\n          throw new Error(\"The editor has no selection\");\n        const block = toSlateValue(\n          [\n            {\n              _key: keyGenerator(),\n              _type: type.name,\n              ...value || {}\n            }\n          ],\n          portableTextEditor\n        )[0], [focusBlock] = Array.from(\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n            at: editor.selection.focus.path.slice(0, 1),\n            match: (n) => n._type === types.block.name\n          })\n        )[0] || [void 0];\n        return focusBlock && isEqualToEmptyEditor([focusBlock], types) && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { at: editor.selection }), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.insertNode(editor, block), editor.onChange(), ((_a = toPortableTextRange(\n          fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n          editor.selection,\n          types\n        )) == null ? void 0 : _a.focus.path) || [];\n      },\n      hasBlockStyle: (style) => {\n        try {\n          return editor.pteHasBlockStyle(style);\n        } catch {\n          return !1;\n        }\n      },\n      hasListStyle: (listStyle) => {\n        try {\n          return editor.pteHasListStyle(listStyle);\n        } catch {\n          return !1;\n        }\n      },\n      isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),\n      findByPath: (path) => {\n        const slatePath = toSlateRange(\n          { focus: { path, offset: 0 }, anchor: { path, offset: 0 } },\n          editor\n        );\n        if (slatePath) {\n          const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n          if (block && blockPath && typeof block._key == \"string\") {\n            if (path.length === 1 && slatePath.focus.path.length === 1)\n              return [fromSlateValue([block], types.block.name)[0], [{ _key: block._key }]];\n            const ptBlock = fromSlateValue(\n              [block],\n              types.block.name,\n              KEY_TO_VALUE_ELEMENT.get(editor)\n            )[0];\n            if (editor.isTextBlock(ptBlock)) {\n              const ptChild = ptBlock.children[slatePath.focus.path[1]];\n              if (ptChild)\n                return [ptChild, [{ _key: block._key }, \"children\", { _key: ptChild._key }]];\n            }\n          }\n        }\n        return [void 0, void 0];\n      },\n      findDOMNode: (element) => {\n        let node;\n        try {\n          const [item] = Array.from(\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n              at: [],\n              match: (n) => n._key === element._key\n            }) || []\n          )[0] || [void 0];\n          node = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, item);\n        } catch {\n        }\n        return node;\n      },\n      activeAnnotations: () => {\n        var _a;\n        if (!editor.selection || editor.selection.focus.path.length < 2)\n          return [];\n        try {\n          const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node) => slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n          });\n          for (const [span, path] of spans) {\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, path, { depth: 1 });\n            editor.isTextBlock(block) && ((_a = block.markDefs) == null || _a.forEach((def) => {\n              slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n            }));\n          }\n          return activeAnnotations;\n        } catch {\n          return [];\n        }\n      },\n      isAnnotationActive: (annotationType) => {\n        if (!editor.selection || editor.selection.focus.path.length < 2)\n          return !1;\n        try {\n          const spans = [\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n              at: editor.selection,\n              match: (node) => slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node)\n            })\n          ];\n          if (spans.some(\n            ([span]) => {\n              var _a;\n              return !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(span) || !span.marks || ((_a = span.marks) == null ? void 0 : _a.length) === 0;\n            }\n          ))\n            return !1;\n          const selectionMarkDefs = spans.reduce((accMarkDefs, [, path]) => {\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, path, { depth: 1 });\n            return editor.isTextBlock(block) && block.markDefs ? [...accMarkDefs, ...block.markDefs] : accMarkDefs;\n          }, []);\n          return spans.every(([span]) => {\n            var _a;\n            if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(span)) return !1;\n            const spanMarkDefs = (_a = span.marks) == null ? void 0 : _a.map(\n              (markKey) => {\n                var _a2;\n                return (_a2 = selectionMarkDefs.find((def) => (def == null ? void 0 : def._key) === markKey)) == null ? void 0 : _a2._type;\n              }\n            );\n            return spanMarkDefs == null ? void 0 : spanMarkDefs.includes(annotationType);\n          });\n        } catch {\n          return !1;\n        }\n      },\n      addAnnotation: (type, value) => {\n        const { selection: originalSelection } = editor;\n        let returnValue;\n        if (originalSelection) {\n          const [block] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, originalSelection.focus, { depth: 1 });\n          if (!editor.isTextBlock(block))\n            return;\n          slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(originalSelection) && (editor.pteExpandToWord(), editor.onChange());\n          const [textNode] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, originalSelection.focus, { depth: 2 });\n          editor.selection && (slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n            const annotationKey = keyGenerator();\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n              editor,\n              {\n                markDefs: [\n                  ...block.markDefs || [],\n                  { _type: type.name, _key: annotationKey, ...value }\n                ]\n              },\n              { at: originalSelection.focus }\n            ), editor.onChange(), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, {}, { match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText, split: !0 }), editor.onChange(), editor.selection && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(textNode) && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n              editor,\n              {\n                marks: [...textNode.marks || [], annotationKey]\n              },\n              {\n                at: editor.selection,\n                match: (n) => n._type === types.span.name\n              }\n            ), editor.onChange(), editor.selection && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(\n              editor,\n              [{ _type: \"span\", text: \"\", marks: [], _key: keyGenerator() }],\n              {\n                at: slate__WEBPACK_IMPORTED_MODULE_13__.Range.end(editor.selection)\n              }\n            );\n            const newPortableTextEditorSelection = toPortableTextRange(\n              fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n              editor.selection,\n              types\n            );\n            newPortableTextEditorSelection && (returnValue = {\n              spanPath: newPortableTextEditorSelection.focus.path,\n              markDefPath: [{ _key: block._key }, \"markDefs\", { _key: annotationKey }]\n            });\n          }), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.normalize(editor), editor.onChange());\n        }\n        return returnValue;\n      },\n      delete: (selection, options) => {\n        if (selection) {\n          const range = toSlateRange(selection, editor);\n          if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0))\n            throw new Error(\"Invalid range\");\n          if (range) {\n            if (!(options != null && options.mode) || (options == null ? void 0 : options.mode) === \"selected\") {\n              debug$i(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.delete(editor, {\n                at: range,\n                hanging: !0,\n                voids: !0\n              }), editor.onChange();\n              return;\n            }\n            (options == null ? void 0 : options.mode) === \"blocks\" && (debug$i(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, {\n              at: range,\n              voids: !0,\n              match: (node) => editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node)\n            })), (options == null ? void 0 : options.mode) === \"children\" && (debug$i(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, {\n              at: range,\n              voids: !0,\n              match: (node) => node._type === types.span.name || // Text children\n              !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node)\n            })), editor.children.length === 0 && (editor.children = [editor.pteCreateEmptyBlock()]), editor.onChange();\n          }\n        }\n      },\n      removeAnnotation: (type) => {\n        let { selection } = editor;\n        if (debug$i(\"Removing annotation\", type), selection) {\n          if (slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(selection)) {\n            const [node, nodePath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, selection, { depth: 2 });\n            slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && node.marks && typeof node.text == \"string\" && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, nodePath), selection = editor.selection);\n          }\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(selection)) {\n              if (selection = editor.selection, !selection)\n                return;\n              [\n                ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n                  at: selection,\n                  match: (node) => editor.isTextBlock(node) && Array.isArray(node.markDefs) && node.markDefs.some((def) => def._type === type.name)\n                })\n              ].forEach(([block]) => {\n                editor.isTextBlock(block) && Array.isArray(block.markDefs) && block.markDefs.filter((def) => def._type === type.name).forEach((def) => {\n                  slate__WEBPACK_IMPORTED_MODULE_13__.Editor.removeMark(editor, def._key);\n                });\n              });\n            }\n          }), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.normalize(editor), editor.onChange();\n        }\n      },\n      getSelection: () => {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            return existing;\n          ptRange = toPortableTextRange(\n            fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n            editor.selection,\n            types\n          ), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n        }\n        return ptRange;\n      },\n      getValue: () => fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n      isCollapsedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(editor.selection),\n      isExpandedSelection: () => !!editor.selection && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(editor.selection),\n      insertBreak: () => {\n        editor.insertBreak(), editor.onChange();\n      },\n      getFragment: () => fromSlateValue(editor.getFragment(), types.block.name),\n      isSelectionsOverlapping: (selectionA, selectionB) => {\n        const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n        return slate__WEBPACK_IMPORTED_MODULE_13__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_13__.Range.includes(rangeA, rangeB);\n      }\n    }), editor;\n  };\n}\nfunction createWithInsertBreak(types) {\n  return function(editor) {\n    const { insertBreak } = editor;\n    return editor.insertBreak = () => {\n      if (editor.selection) {\n        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, focusBlockPath);\n        if (editor.isTextBlock(focusBlock)) {\n          const [, end] = slate__WEBPACK_IMPORTED_MODULE_13__.Range.edges(editor.selection), isEndAtStartOfNode = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isStart(editor, end, end.path), isEmptyTextBlock = focusBlock && isEqualToEmptyEditor([focusBlock], types);\n          if (isEndAtStartOfNode && !isEmptyTextBlock) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.insertNode(editor, editor.pteCreateEmptyBlock());\n            const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(focusBlockPath);\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, {\n              anchor: { path: [nextBlockPath, 0], offset: 0 },\n              focus: { path: [nextBlockPath, 0], offset: 0 }\n            }), editor.onChange();\n            return;\n          }\n        }\n      }\n      insertBreak();\n    }, editor;\n  };\n}\nfunction createWithMaxBlocks(maxBlocks) {\n  return function(editor) {\n    const { apply: apply2 } = editor;\n    return editor.apply = (operation) => {\n      const rows = maxBlocks;\n      rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n    }, editor;\n  };\n}\nconst PRESERVE_KEYS = /* @__PURE__ */ new WeakMap();\nfunction withPreserveKeys(editor, fn) {\n  const prev = isPreservingKeys(editor);\n  PRESERVE_KEYS.set(editor, !0), fn(), PRESERVE_KEYS.set(editor, prev);\n}\nfunction isPreservingKeys(editor) {\n  return PRESERVE_KEYS.get(editor);\n}\nfunction createWithObjectKeys(schemaTypes, keyGenerator) {\n  return function(editor) {\n    PRESERVE_KEYS.set(editor, !1);\n    const { apply: apply2, normalizeNode } = editor;\n    return editor.apply = (operation) => {\n      if (operation.type === \"split_node\") {\n        const withNewKey = !isPreservingKeys(editor) || !(\"_key\" in operation.properties);\n        operation.properties = {\n          ...operation.properties,\n          ...withNewKey ? { _key: keyGenerator() } : {}\n        };\n      }\n      if (operation.type === \"insert_node\") {\n        const withNewKey = !isPreservingKeys(editor) || !(\"_key\" in operation.node);\n        slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isEditor(operation.node) || (operation.node = {\n          ...operation.node,\n          ...withNewKey ? { _key: keyGenerator() } : {}\n        });\n      }\n      apply2(operation);\n    }, editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n        node._key || slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { _key: keyGenerator() }, { at: path });\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_13__.Node.children(editor, path))\n          if (!child._key) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { _key: keyGenerator() }, { at: childPath });\n            return;\n          }\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n    args[_key] = arguments[_key];\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs) {\n  let editCost = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n    checkLines: !1,\n    deadline\n  }), diffsb = doDiff(text1b, text2b, {\n    checkLines: !1,\n    deadline\n  });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2) {\n  if ((arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1) <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || \"\", bestLongTextB || \"\", bestShortTextA || \"\", bestShortTextB || \"\", bestCommon || \"\"] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return {\n    chars1,\n    chars2,\n    lineArray\n  };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return {\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1),\n    ...opts\n  };\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return {\n    ...DEFAULT_OPTIONS,\n    ...options\n  };\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc) {\n  let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc);\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base) {\n  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction addPadding(patches) {\n  const paddingLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction splitMax(patches) {\n  let margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_MARGIN;\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText) {\n  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, {\n          checkLines: !1\n        });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(\"Invalid patch string: \".concat(lines[textPointer]));\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch {\n        throw new Error(\"Illegal escape in parse: \".concat(currentLine));\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error('Invalid patch mode \"'.concat(sign, '\" in: ').concat(line));\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nconst debug$h = debugWithName(\"applyPatches\"), debugVerbose$3 = debug$h.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n  let previousPatch;\n  return function(editor, patch) {\n    let changed = !1;\n    debugVerbose$3 && (debug$h(`\n\nNEW PATCH =============================================================`), debug$h(JSON.stringify(patch, null, 2)));\n    try {\n      switch (patch.type) {\n        case \"insert\":\n          changed = insertPatch(editor, patch, schemaTypes);\n          break;\n        case \"unset\":\n          changed = unsetPatch(editor, patch, previousPatch);\n          break;\n        case \"set\":\n          changed = setPatch(editor, patch);\n          break;\n        case \"diffMatchPatch\":\n          changed = diffMatchPatch(editor, patch);\n          break;\n        default:\n          debug$h(\"Unhandled patch\", patch.type);\n      }\n    } catch (err) {\n      console.error(err);\n    }\n    return previousPatch = patch, changed;\n  };\n}\nfunction diffMatchPatch(editor, patch) {\n  const { block, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$h(\"Block not found\"), !1;\n  if (!child || !childPath)\n    return debug$h(\"Child not found\"), !1;\n  if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(child))\n    return !1;\n  const patches = parse(patch.value), [newValue] = apply(patches, child.text, { allowExceedingIndices: !0 }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n  debugState(editor, \"before\");\n  let offset = 0;\n  for (const [op, text] of diff$1)\n    op === DIFF_INSERT ? (editor.apply({ type: \"insert_text\", path: childPath, offset, text }), offset += text.length) : op === DIFF_DELETE ? editor.apply({ type: \"remove_text\", path: childPath, offset, text }) : op === DIFF_EQUAL && (offset += text.length);\n  return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n  const {\n    block: targetBlock,\n    child: targetChild,\n    blockPath: targetBlockPath,\n    childPath: targetChildPath\n  } = findBlockAndChildFromPath(editor, patch.path);\n  if (!targetBlock || !targetBlockPath)\n    return debug$h(\"Block not found\"), !1;\n  if (patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$h(\"Ignoring patch targeting void value\"), !1;\n  if (patch.path.length === 1) {\n    const { items: items2, position: position2 } = patch, blocksToInsert = toSlateValue(\n      items2,\n      { schemaTypes },\n      KEY_TO_SLATE_ELEMENT.get(editor)\n    ), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n    return debug$h(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, blocksToInsert, { at: [normalizedIdx2] }), debugState(editor, \"after\"), !0;\n  }\n  const { items, position } = patch;\n  if (!targetChild || !targetChildPath)\n    return debug$h(\"Child not found\"), !1;\n  const childrenToInsert = targetBlock && toSlateValue(\n    [{ ...targetBlock, children: items }],\n    { schemaTypes },\n    KEY_TO_SLATE_ELEMENT.get(editor)\n  ), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [targetChildPath[0], normalizedIdx];\n  return debug$h(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, childrenToInsert[0].children, { at: childInsertPath }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n  let value = patch.value;\n  typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n  const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n  if (!block)\n    return debug$h(\"Block not found\"), !1;\n  const isTextBlock = editor.isTextBlock(block);\n  if (isTextBlock && patch.path.length > 1 && patch.path[1] !== \"children\")\n    return debug$h(\"Ignoring setting void value\"), !1;\n  if (debugState(editor, \"before\"), isTextBlock && child && childPath) {\n    if (slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(child)) {\n      const newText = child.text;\n      value.text !== newText && (debug$h(\"Setting text property\"), editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset: 0,\n        text: newText\n      }), editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset: 0,\n        text: value.text\n      }), editor.onChange());\n    } else\n      debug$h(\"Setting non-text property\"), editor.apply({\n        type: \"set_node\",\n        path: childPath,\n        properties: {},\n        newProperties: value\n      });\n    return !0;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n    debug$h(\"Setting block property\");\n    const { children, ...nextRest } = value, { children: prevChildren, ...prevRest } = block || { children: void 0 };\n    editor.apply({\n      type: \"set_node\",\n      path: blockPath,\n      properties: { ...prevRest },\n      newProperties: nextRest\n    }), debug$h(\"Setting children\"), block.children.forEach((c, cIndex) => {\n      editor.apply({\n        type: \"remove_node\",\n        path: blockPath.concat(block.children.length - 1 - cIndex),\n        node: c\n      });\n    }), Array.isArray(children) && children.forEach((c, cIndex) => {\n      editor.apply({\n        type: \"insert_node\",\n        path: blockPath.concat(cIndex),\n        node: c\n      });\n    });\n  } else if (block && \"value\" in block) {\n    const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.applyAll)([block.value], [patch])[0];\n    return slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { ...block, value: newVal }, { at: blockPath }), !0;\n  }\n  return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch, previousPatch) {\n  if (patch.path.length === 0) {\n    debug$h(\"Removing everything\"), debugState(editor, \"before\");\n    const previousSelection = editor.selection;\n    return slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(editor), editor.children.forEach((c, i) => {\n      slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { at: [i] });\n    }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, editor.pteCreateEmptyBlock()), previousSelection && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, {\n      anchor: { path: [0, 0], offset: 0 },\n      focus: { path: [0, 0], offset: 0 }\n    }), editor.onChange(), debugState(editor, \"after\"), !0;\n  }\n  const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n  if (patch.path.length === 1) {\n    if (!block || !blockPath)\n      return debug$h(\"Block not found\"), !1;\n    const blockIndex = blockPath[0];\n    return debug$h(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { at: [blockIndex] }), debugState(editor, \"after\"), !0;\n  }\n  return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$h(\"Child not found\"), !1) : (debug$h(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose$3 && debug$h(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { at: childPath }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n  return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n  debugVerbose$3 && (debug$h(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$h(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n  let blockIndex = -1;\n  const block = editor.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n    return isMatch && (blockIndex = index), isMatch;\n  });\n  return block ? { block, path: [blockIndex] } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n  const { block, path: blockPath } = findBlockFromPath(editor, path);\n  if (!(slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block) && path[1] === \"children\"))\n    return { block, blockPath, child: void 0, childPath: void 0 };\n  let childIndex = -1;\n  const child = block.children.find((node, index) => {\n    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n    return isMatch && (childIndex = index), isMatch;\n  });\n  return child ? { block, child, blockPath, childPath: blockPath == null ? void 0 : blockPath.concat(childIndex) } : { block, blockPath, child: void 0, childPath: void 0 };\n}\nfunction withRemoteChanges(editor, fn) {\n  const prev = isChangingRemotely(editor) || !1;\n  IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n  return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nfunction isChangingLocally(editor) {\n  return IS_PROCESSING_LOCAL_CHANGES.get(editor);\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n  const prev = isPatching(editor);\n  PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n  return PATCHING.get(editor);\n}\nconst debug$g = debugWithName(\"plugin:withUndoRedo\"), debugVerbose$2 = debug$g.enabled && !1, SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor) => {\n  const state = SAVING.get(editor);\n  return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor) => (REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n  const { readOnly, patches$, blockSchemaType } = options;\n  return (editor) => {\n    let previousSnapshot = fromSlateValue(\n      editor.children,\n      blockSchemaType.name\n    );\n    const remotePatches = getRemotePatches(editor);\n    patches$ && editor.subscriptions.push(() => {\n      debug$g(\"Subscribing to patches\");\n      const sub = patches$.subscribe(({ patches, snapshot }) => {\n        let reset = !1;\n        patches.forEach((patch) => {\n          if (!reset && patch.origin !== \"local\" && remotePatches) {\n            if (patch.type === \"unset\" && patch.path.length === 0) {\n              debug$g(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = { undos: [], redos: [] }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n              return;\n            }\n            remotePatches.push({ patch, time: /* @__PURE__ */ new Date(), snapshot, previousSnapshot });\n          }\n        }), previousSnapshot = snapshot;\n      });\n      return () => {\n        debug$g(\"Unsubscribing to patches\"), sub.unsubscribe();\n      };\n    }), editor.history = { undos: [], redos: [] };\n    const { apply: apply2 } = editor;\n    return editor.apply = (op) => {\n      if (readOnly) {\n        apply2(op);\n        return;\n      }\n      const { operations, history } = editor, { undos } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);\n      let merge = !0;\n      if (save) {\n        if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge)\n          step.operations.push(op);\n        else {\n          const newStep = {\n            operations: [...editor.selection === null ? [] : [createSelectOperation(editor)], op],\n            timestamp: /* @__PURE__ */ new Date()\n          };\n          undos.push(newStep), debug$g(\"Created new undo step\", step);\n        }\n        for (; undos.length > UNDO_STEP_LIMIT; )\n          undos.shift();\n        shouldClear(op) && (history.redos = []);\n      }\n      apply2(op);\n    }, editor.undo = () => {\n      if (readOnly)\n        return;\n      const { undos } = editor.history;\n      if (undos.length > 0) {\n        const step = undos[undos.length - 1];\n        if (debug$g(\"Undoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_9__(\n              transformedOperations.map(\n                (op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)\n              )\n            );\n          });\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n              withPreserveKeys(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_13__.Operation.inverse).reverse().forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$g(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(editor), editor.history = { undos: [], redos: [] }, SAVING.set(editor, !0), editor.onChange();\n            return;\n          }\n          editor.history.redos.push(step), editor.history.undos.pop();\n        }\n      }\n    }, editor.redo = () => {\n      if (readOnly)\n        return;\n      const { redos } = editor.history;\n      if (redos.length > 0) {\n        const step = redos[redos.length - 1];\n        if (debug$g(\"Redoing\", step), step.operations.length > 0) {\n          const otherPatches = remotePatches.filter((item) => item.time >= step.timestamp);\n          let transformedOperations = step.operations;\n          otherPatches.forEach((item) => {\n            transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_9__(\n              transformedOperations.map(\n                (op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)\n              )\n            );\n          });\n          try {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n              withPreserveKeys(editor, () => {\n                withoutSaving(editor, () => {\n                  transformedOperations.forEach((op) => {\n                    editor.apply(op);\n                  });\n                });\n              });\n            }), editor.normalize(), editor.onChange();\n          } catch (err) {\n            debug$g(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(editor), editor.history = { undos: [], redos: [] }, SAVING.set(editor, !0), editor.onChange();\n            return;\n          }\n          editor.history.undos.push(step), editor.history.redos.pop();\n        }\n      }\n    }, editor;\n  };\n}\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n  debugVerbose$2 && (debug$g(`Adjusting '${operation.type}' operation paths for '${patch.type}' patch`), debug$g(`Operation ${JSON.stringify(operation)}`), debug$g(`Patch ${JSON.stringify(patch)}`));\n  const transformedOperation = { ...operation };\n  if (patch.type === \"insert\" && patch.path.length === 1) {\n    const insertBlockIndex = (snapshot || []).findIndex(\n      (blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({ _key: blk._key }, patch.path[0])\n    );\n    return debug$g(\n      `Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`\n    ), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];\n  }\n  if (patch.type === \"unset\" && patch.path.length === 1) {\n    const unsetBlockIndex = (previousSnapshot || []).findIndex(\n      (blk) => lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({ _key: blk._key }, patch.path[0])\n    );\n    return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$g(\"Skipping transformation that targeted removed block\"), []) : (debugVerbose$2 && (debug$g(`Selection ${JSON.stringify(editor.selection)}`), debug$g(\n      `Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`\n    )), [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)]);\n  }\n  if (patch.type === \"unset\" && patch.path.length === 0)\n    return debug$g(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n  if (patch.type === \"diffMatchPatch\") {\n    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n    return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__({ _key: operationTargetBlock._key }, patch.path[0]) ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {\n      var _a, _b, _c, _d;\n      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n      const { diffs } = diffPatch;\n      if (diffs.forEach((diff2, index) => {\n        const [diffType, text] = diff2;\n        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));\n      }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n        const currentFocus = (_a = transformedOperation.properties) != null && _a.focus ? { ...transformedOperation.properties.focus } : void 0, currentAnchor = (_b = transformedOperation == null ? void 0 : transformedOperation.properties) != null && _b.anchor ? { ...transformedOperation.properties.anchor } : void 0, newFocus = (_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _c.focus ? { ...transformedOperation.newProperties.focus } : void 0, newAnchor = (_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _d.anchor ? { ...transformedOperation.newProperties.anchor } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n          focus: currentFocus,\n          anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n          focus: newFocus,\n          anchor: newAnchor\n        }));\n      }\n    }), [transformedOperation]);\n  }\n  return [transformedOperation];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n  var _a, _b, _c, _d;\n  const transformedOperation = { ...operation };\n  if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];\n    transformedOperation.path = newPath;\n  }\n  if (transformedOperation.type === \"set_selection\") {\n    const currentFocus = (_a = transformedOperation.properties) != null && _a.focus ? { ...transformedOperation.properties.focus } : void 0, currentAnchor = (_b = transformedOperation == null ? void 0 : transformedOperation.properties) != null && _b.anchor ? { ...transformedOperation.properties.anchor } : void 0, newFocus = (_c = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _c.focus ? { ...transformedOperation.newProperties.focus } : void 0, newAnchor = (_d = transformedOperation == null ? void 0 : transformedOperation.newProperties) != null && _d.anchor ? { ...transformedOperation.newProperties.anchor } : void 0;\n    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {\n      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);\n    }), currentFocus && currentAnchor && (transformedOperation.properties = {\n      focus: currentFocus,\n      anchor: currentAnchor\n    }), newFocus && newAnchor && (transformedOperation.newProperties = {\n      focus: newFocus,\n      anchor: newAnchor\n    }));\n  }\n  return transformedOperation;\n}\nconst shouldMerge = (op, prev) => !!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev) => !!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op) => op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n  const prev = isSaving(editor);\n  SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n  return {\n    type: \"set_selection\",\n    properties: { ...editor.selection },\n    newProperties: { ...editor.selection }\n  };\n}\nfunction findOperationTargetBlock(editor, operation) {\n  let block;\n  return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst debug$f = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({\n  change$,\n  patches$,\n  patchFunctions,\n  readOnly,\n  schemaTypes\n}) {\n  let previousChildren;\n  const applyPatch = createApplyPatch(schemaTypes);\n  return function(editor) {\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [...editor.children];\n    const { apply: apply2 } = editor;\n    let bufferedPatches = [];\n    const handleBufferedRemotePatches = () => {\n      if (bufferedPatches.length === 0)\n        return;\n      const patches = bufferedPatches;\n      bufferedPatches = [];\n      let changed = !1;\n      withRemoteChanges(editor, () => {\n        slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n          withoutPatching(editor, () => {\n            withoutSaving(editor, () => {\n              withPreserveKeys(editor, () => {\n                patches.forEach((patch) => {\n                  debug$f.enabled && debug$f(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n                });\n              });\n            });\n          });\n        }), changed && (editor.normalize(), editor.onChange());\n      });\n    }, handlePatches = ({ patches }) => {\n      const remotePatches = patches.filter((p) => p.origin !== \"local\");\n      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n    };\n    return patches$ && editor.subscriptions.push(() => {\n      debug$f(\"Subscribing to patches$\");\n      const sub = patches$.subscribe(handlePatches);\n      return () => {\n        debug$f(\"Unsubscribing to patches$\"), sub.unsubscribe();\n      };\n    }), editor.apply = (operation) => {\n      if (readOnly)\n        return apply2(operation), editor;\n      let patches = [];\n      previousChildren = editor.children;\n      const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n      apply2(operation);\n      const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n      if (!isPatching(editor))\n        return editor;\n      switch (editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)(previousChildren, \"before\", [0])), operation.type) {\n        case \"insert_text\":\n          patches = [\n            ...patches,\n            ...patchFunctions.insertTextPatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"remove_text\":\n          patches = [\n            ...patches,\n            ...patchFunctions.removeTextPatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"remove_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.removeNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"split_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.splitNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"insert_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.insertNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"set_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.setNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"merge_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n        case \"move_node\":\n          patches = [\n            ...patches,\n            ...patchFunctions.moveNodePatch(editor, operation, previousChildren)\n          ];\n          break;\n      }\n      return !editorWasEmpty && editorIsEmpty && [\"merge_node\", \"set_node\", \"remove_text\", \"remove_node\"].includes(operation.type) && (patches = [...patches, (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([])], change$.next({\n        type: \"unset\",\n        previousValue: fromSlateValue(\n          previousChildren,\n          schemaTypes.block.name,\n          KEY_TO_VALUE_ELEMENT.get(editor)\n        )\n      })), editorWasEmpty && patches.length > 0 && (patches = [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.setIfMissing)([], []), ...patches]), patches.length > 0 && patches.forEach((patch) => {\n        change$.next({\n          type: \"patch\",\n          patch: { ...patch, origin: \"local\" }\n        });\n      }), editor;\n    }, editor;\n  };\n}\nconst debug$e = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock() {\n  return function(editor) {\n    const { apply: apply2 } = editor;\n    return editor.apply = (op) => {\n      if (op.type === \"remove_node\") {\n        const node = op.node;\n        if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, node)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(op.path);\n          editor.children[nextPath[0]] || (debug$e(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.insertNode(editor, editor.pteCreateEmptyBlock()));\n        }\n      }\n      apply2(op);\n    }, editor;\n  };\n}\nconst debug$d = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(types) {\n  const defaultStyle = types.styles[0].value;\n  return function(editor) {\n    const { normalizeNode } = editor;\n    return editor.normalizeNode = (nodeEntry) => {\n      normalizeNode(nodeEntry);\n      const [, path] = nodeEntry;\n      for (const op of editor.operations)\n        if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(path, op.path)) {\n          const [child] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, [op.path[0] + 1, 0]);\n          if (slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(child) && child.text === \"\") {\n            debug$d(`Normalizing split node to ${defaultStyle} style`, op), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { style: defaultStyle }, { at: [op.path[0] + 1], voids: !1 });\n            break;\n          }\n        }\n    }, editor.pteHasBlockStyle = (style) => editor.selection ? [\n      ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n        at: editor.selection,\n        match: (node) => editor.isTextBlock(node) && node.style === style\n      })\n    ].length > 0 : !1, editor.pteToggleBlockStyle = (blockStyle) => {\n      editor.selection && ([\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => editor.isTextBlock(node)\n        })\n      ].forEach(([node, path]) => {\n        editor.isTextBlock(node) && node.style === blockStyle ? (debug$d(`Unsetting block style '${blockStyle}'`), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { ...node, style: defaultStyle }, {\n          at: path\n        })) : (blockStyle ? debug$d(`Setting style '${blockStyle}'`) : debug$d(\"Setting default style\", defaultStyle), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n          editor,\n          {\n            ...node,\n            style: blockStyle || defaultStyle\n          },\n          { at: path }\n        ));\n      }), editor.onChange());\n    }, editor;\n  };\n}\nconst debug$c = debugWithName(\"plugin:withPortableTextLists\"), MAX_LIST_LEVEL = 10;\nfunction createWithPortableTextLists(types) {\n  return function(editor) {\n    return editor.pteToggleListItem = (listItemStyle) => {\n      editor.pteHasListStyle(listItemStyle) ? (debug$c(`Remove list item '${listItemStyle}'`), editor.pteUnsetListItem(listItemStyle)) : (debug$c(`Add list item '${listItemStyle}'`), editor.pteSetListItem(listItemStyle));\n    }, editor.pteUnsetListItem = (listItemStyle) => {\n      editor.selection && [\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node) && node._type === types.block.name\n        })\n      ].forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          const { listItem, level, ...rest } = node, newNode = {\n            ...rest,\n            listItem: void 0,\n            level: void 0\n          };\n          debug$c(`Unsetting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, newNode, { at: path });\n        }\n      });\n    }, editor.pteSetListItem = (listItemStyle) => {\n      editor.selection && [\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => editor.isTextBlock(node)\n        })\n      ].forEach(([node, path]) => {\n        debug$c(`Setting list '${listItemStyle}'`), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n          editor,\n          {\n            ...node,\n            level: 1,\n            listItem: listItemStyle || types.lists[0] && types.lists[0].value\n          },\n          { at: path }\n        );\n      });\n    }, editor.pteEndList = () => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node) && editor.isListBlock(node) && node.children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node.children[0]) && node.children[0].text === \"\"\n        })\n      ];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(node) && (debug$c(\"Unset list\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n          editor,\n          {\n            ...node,\n            level: void 0,\n            listItem: void 0\n          },\n          { at: path }\n        ));\n      }), !0);\n    }, editor.pteIncrementBlockLevels = (reverse) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => !!editor.isListBlock(node)\n        })\n      ];\n      return selectedBlocks.length === 0 ? !1 : (selectedBlocks.forEach(([node, path]) => {\n        if (editor.isListBlock(node)) {\n          let level = node.level || 1;\n          reverse ? (level--, debug$c(\"Decrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))) : (level++, debug$c(\"Incrementing list level\", Math.min(MAX_LIST_LEVEL, Math.max(1, level)))), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n            editor,\n            { level: Math.min(MAX_LIST_LEVEL, Math.max(1, level)) },\n            { at: path }\n          );\n        }\n      }), !0);\n    }, editor.pteHasListStyle = (listStyle) => {\n      if (!editor.selection)\n        return !1;\n      const selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: editor.selection,\n          match: (node) => editor.isTextBlock(node)\n        })\n      ];\n      return selectedBlocks.length > 0 ? selectedBlocks.every(\n        ([node]) => editor.isListBlock(node) && node.listItem === listStyle\n      ) : !1;\n    }, editor;\n  };\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(types, change$) {\n  return function(editor) {\n    const { apply: apply2, normalizeNode } = editor, decorators = types.decorators.map((t) => t.value), forceNewSelection = () => {\n      editor.selection && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, { ...editor.selection }), editor.selection = { ...editor.selection });\n      const ptRange = toPortableTextRange(editor.children, editor.selection, types);\n      change$.next({ type: \"selection\", selection: ptRange });\n    };\n    return editor.normalizeNode = (nodeEntry) => {\n      normalizeNode(nodeEntry), editor.operations.some(\n        (op) => [\n          \"insert_node\",\n          \"insert_text\",\n          \"merge_node\",\n          \"remove_node\",\n          \"remove_text\",\n          \"set_node\"\n        ].includes(op.type)\n      ) && mergeSpans(editor);\n      const [node, path] = nodeEntry, isSpan = slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && node._type === types.span.name, isTextBlock = editor.isTextBlock(node);\n      if (isSpan || isTextBlock) {\n        if (isSpan && !Array.isArray(node.marks) && (debug$b(\"Adding .marks to span node\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { marks: [] }, { at: path }), editor.onChange()), isSpan && (node.marks || []).length > 0) {\n          const spanMarks = node.marks || EMPTY_MARKS$1, annotationMarks = spanMarks.filter(\n            (mark) => !types.decorators.map((dec) => dec.value).includes(mark)\n          );\n          if (annotationMarks.length > 0) {\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_13__.Path.parent(path)), orphanedMarks = editor.isTextBlock(block) && annotationMarks.filter(\n              (mark) => {\n                var _a;\n                return !((_a = block.markDefs) != null && _a.find((def) => def._key === mark));\n              }\n            ) || [];\n            orphanedMarks.length > 0 && (debug$b(\"Removing orphaned .marks from span node\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n              editor,\n              { marks: spanMarks.filter((mark) => !orphanedMarks.includes(mark)) },\n              { at: path }\n            ), editor.onChange());\n          }\n        }\n        for (const op of editor.operations) {\n          if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n            const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, [op.path[0] - 1]);\n            if (debug$b(\"Copying markDefs over to merged block\", op), editor.isTextBlock(targetBlock)) {\n              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__([...oldDefs, ...op.properties.markDefs]);\n              lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(newMarkDefs, targetBlock.markDefs) || (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { markDefs: newMarkDefs }, { at: targetPath, voids: !1 }), editor.onChange());\n            }\n          }\n          if (op.type === \"split_node\" && op.path.length === 1 && slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElementProps(op.properties) && op.properties._type === types.block.name && \"markDefs\" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] + 1 < editor.children.length) {\n            const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, [op.path[0] + 1]);\n            if (debug$b(\"Copying markDefs over to split block\", op), editor.isTextBlock(targetBlock)) {\n              const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [];\n              slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n                editor,\n                { markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__([...oldDefs, ...op.properties.markDefs]) },\n                { at: targetPath, voids: !1 }\n              ), editor.onChange();\n            }\n          }\n          if (op.type === \"split_node\" && op.path.length === 2 && op.properties._type === types.span.name && \"marks\" in op.properties && Array.isArray(op.properties.marks) && op.properties.marks.length > 0 && op.path[0] + 1 < editor.children.length) {\n            const [child, childPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, [op.path[0] + 1, 0]);\n            slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(child) && child.text === \"\" && Array.isArray(child.marks) && child.marks.length > 0 && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { marks: [] }, { at: childPath, voids: !1 }), editor.onChange());\n          }\n          if (op.type === \"split_node\" && op.path.length === 1 && op.properties._type === types.block.name && \"markDefs\" in op.properties && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0) {\n            const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, [op.path[0]]);\n            editor.isTextBlock(block) && block.children.length === 1 && block.markDefs && block.markDefs.length > 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(block.children[0]) && block.children[0].text === \"\" && (!block.children[0].marks || block.children[0].marks.length === 0) && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { markDefs: [] }, { at: blockPath }), editor.onChange());\n          }\n        }\n        isSpan && Array.isArray(node.marks) && (!node.marks || node.marks.length > 0 && node.text === \"\") && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { marks: [] }, { at: path, voids: !1 }), editor.onChange());\n      }\n      if (editor.isTextBlock(node) && !editor.operations.some(\n        (op) => op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1\n      )) {\n        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n        node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(newMarkDefs, node.markDefs) && (debug$b(\"Removing markDef not in use\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n          editor,\n          {\n            markDefs: newMarkDefs\n          },\n          { at: path }\n        ), editor.onChange());\n      }\n    }, editor.apply = (op) => {\n      var _a, _b;\n      if (op.type === \"insert_text\") {\n        const { selection } = editor;\n        if (selection && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(selection) && (_b = (_a = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor)) == null ? void 0 : _a.marks) != null && _b.some((mark) => !decorators.includes(mark))) {\n          const [node] = Array.from(\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n              mode: \"lowest\",\n              at: selection.focus,\n              match: (n) => n._type === types.span.name,\n              voids: !1\n            })\n          )[0] || [void 0];\n          if (slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && node.text.length === selection.focus.offset && Array.isArray(node.marks) && node.marks.length > 0) {\n            apply2(op), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.splitNodes(editor, {\n              match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText,\n              at: { ...selection.focus, offset: selection.focus.offset }\n            });\n            const marksWithoutAnnotationMarks = ({\n              ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {}\n            }.marks || []).filter((mark) => decorators.includes(mark));\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n              editor,\n              { marks: marksWithoutAnnotationMarks },\n              { at: slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(selection.focus.path) }\n            ), debug$b(\"Inserting text at end of annotation\");\n            return;\n          }\n        }\n      }\n      apply2(op);\n    }, editor.addMark = (mark) => {\n      if (editor.selection) {\n        if (slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(editor.selection)) {\n          slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, {}, { match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText, split: !0 });\n          const splitTextNodes = [\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, { at: editor.selection, match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText })\n          ];\n          if (splitTextNodes.every((node) => {\n            var _a;\n            return (_a = node[0].marks) == null ? void 0 : _a.includes(mark);\n          }))\n            return editor.removeMark(mark), editor;\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n            splitTextNodes.forEach(([node, path]) => {\n              const marks = [\n                ...(Array.isArray(node.marks) ? node.marks : []).filter(\n                  (eMark) => eMark !== mark\n                ),\n                mark\n              ];\n              slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n                editor,\n                { marks },\n                { at: path, match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText, split: !0, hanging: !0 }\n              );\n            });\n          }), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.normalize(editor);\n        } else {\n          const existingMarks = {\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {}\n          }.marks || [], marks = {\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {},\n            marks: [...existingMarks, mark]\n          };\n          return editor.marks = marks, forceNewSelection(), editor;\n        }\n        editor.onChange(), forceNewSelection();\n      }\n      return editor;\n    }, editor.removeMark = (mark) => {\n      const { selection } = editor;\n      if (selection) {\n        if (slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(selection))\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(editor, () => {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, {}, { match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText, split: !0 }), editor.selection && [\n              ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, { at: editor.selection, match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText })\n            ].forEach(([node, path]) => {\n              const block = editor.children[path[0]];\n              slate__WEBPACK_IMPORTED_MODULE_13__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n                editor,\n                {\n                  marks: (Array.isArray(node.marks) ? node.marks : []).filter(\n                    (eMark) => eMark !== mark\n                  ),\n                  _type: \"span\"\n                },\n                { at: path }\n              );\n            });\n          }), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.normalize(editor);\n        else {\n          const existingMarks = {\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {}\n          }.marks || [], marks = {\n            ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {},\n            marks: existingMarks.filter((eMark) => eMark !== mark)\n          };\n          return editor.marks = { marks: marks.marks, _type: \"span\" }, forceNewSelection(), editor;\n        }\n        editor.onChange(), forceNewSelection();\n      }\n      return editor;\n    }, editor.pteIsMarkActive = (mark) => {\n      if (!editor.selection)\n        return !1;\n      const selectedNodes = Array.from(\n        slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, { match: slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText, at: editor.selection })\n      );\n      return slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(editor.selection) ? selectedNodes.every((n) => {\n        var _a;\n        const [node] = n;\n        return (_a = node.marks) == null ? void 0 : _a.includes(mark);\n      }) : ({\n        ...slate__WEBPACK_IMPORTED_MODULE_13__.Editor.marks(editor) || {}\n      }.marks || []).includes(mark);\n    }, editor.pteToggleMark = (mark) => {\n      editor.pteIsMarkActive(mark) ? (debug$b(`Remove mark '${mark}'`), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.removeMark(editor, mark)) : (debug$b(`Add mark '${mark}'`), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.addMark(editor, mark, !0));\n    }, editor;\n  };\n  function mergeSpans(editor) {\n    const { selection } = editor;\n    if (selection)\n      for (const [node, path] of Array.from(\n        slate__WEBPACK_IMPORTED_MODULE_13__.Editor.nodes(editor, {\n          at: slate__WEBPACK_IMPORTED_MODULE_13__.Editor.range(editor, [selection.anchor.path[0]], [selection.focus.path[0]])\n        })\n      ).reverse()) {\n        const [parent] = path.length > 1 ? slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_13__.Path.parent(path)) : [void 0], nextPath = [path[0], path[1] + 1];\n        if (editor.isTextBlock(parent)) {\n          const nextNode = parent.children[nextPath[1]];\n          slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(node) && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(nextNode) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextNode.marks, node.marks) && (debug$b(\"Merging spans\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.mergeNodes(editor, { at: nextPath, voids: !0 }), editor.onChange());\n        }\n      }\n  }\n}\nconst debug$a = debugWithName(\"plugin:withPortableTextSelections\"), debugVerbose$1 = debug$a.enabled && !1;\nfunction createWithPortableTextSelections(change$, types) {\n  let prevSelection = null;\n  return function(editor) {\n    const emitPortableTextSelection = () => {\n      if (prevSelection !== editor.selection) {\n        let ptRange = null;\n        if (editor.selection) {\n          const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n          if (existing)\n            ptRange = existing;\n          else {\n            const value = editor.children;\n            ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n          }\n        }\n        debugVerbose$1 && debug$a(\n          `Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(\n            editor.selection\n          )})`\n        ), ptRange ? change$.next({ type: \"selection\", selection: ptRange }) : change$.next({ type: \"selection\", selection: null });\n      }\n      prevSelection = editor.selection;\n    }, { onChange } = editor;\n    return editor.onChange = () => {\n      const hasChanges = editor.operations.length > 0;\n      onChange(), hasChanges && emitPortableTextSelection();\n    }, editor;\n  };\n}\nconst debug$9 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({\n  schemaTypes,\n  keyGenerator\n}) {\n  return function(editor) {\n    editor.isTextBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(value) && value._type == schemaTypes.span.name, editor.isListBlock = (value) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element) => schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj) => obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => schemaTypes.inlineObjects.map((obj) => obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n    const { normalizeNode } = editor;\n    return editor.normalizeNode = (entry) => {\n      const [node, path] = entry;\n      if (node._type === void 0 && path.length === 2) {\n        debug$9(\"Setting span type on text node without a type\");\n        const span = node, key = span._key || keyGenerator();\n        slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { ...span, _type: schemaTypes.span.name, _key: key }, { at: path });\n      }\n      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n        debug$9(\"Setting missing key on child node without a key\");\n        const key = keyGenerator();\n        slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(editor, { _key: key }, { at: path });\n      }\n      normalizeNode(entry);\n    }, editor;\n  };\n}\nconst debug$8 = debugWithName(\"plugin:withUtils\");\nfunction createWithUtils({ schemaTypes, keyGenerator, portableTextEditor }) {\n  return function(editor) {\n    return editor.pteExpandToWord = () => {\n      const { selection } = editor;\n      if (selection && !slate__WEBPACK_IMPORTED_MODULE_13__.Range.isExpanded(selection)) {\n        const [textNode] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, selection.focus, { depth: 2 });\n        if (!textNode || !slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(textNode) || textNode.text.length === 0) {\n          debug$8(\"pteExpandToWord: Can't expand to word here\");\n          return;\n        }\n        const { focus } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str) => str.match(/\\s/g), whiteSpaceBeforeIndex = charsBefore.split(\"\").reverse().findIndex((str) => isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split(\"\").findIndex((obj) => isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);\n        if (!(newStartOffset === newEndOffset || isNaN(newStartOffset) || isNaN(newEndOffset))) {\n          debug$8(\"pteExpandToWord: Expanding to focused word\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setSelection(editor, {\n            anchor: { ...selection.anchor, offset: newStartOffset },\n            focus: { ...selection.focus, offset: newEndOffset }\n          });\n          return;\n        }\n        debug$8(\"pteExpandToWord: Can't expand to word here\");\n      }\n    }, editor.pteCreateEmptyBlock = () => toSlateValue(\n      [\n        {\n          _type: schemaTypes.block.name,\n          _key: keyGenerator(),\n          style: schemaTypes.styles[0].value || \"normal\",\n          markDefs: [],\n          children: [\n            {\n              _type: \"span\",\n              _key: keyGenerator(),\n              text: \"\",\n              marks: []\n            }\n          ]\n        }\n      ],\n      portableTextEditor\n    )[0], editor;\n  };\n}\nconst debug$7 = debugWithName(\"plugin:withHotKeys\"), DEFAULT_HOTKEYS = {\n  marks: {\n    \"mod+b\": \"strong\",\n    \"mod+i\": \"em\",\n    \"mod+u\": \"underline\",\n    \"mod+'\": \"code\"\n  },\n  custom: {}\n};\nfunction createWithHotkeys(types, portableTextEditor, hotkeysFromOptions) {\n  const reservedHotkeys = [\"enter\", \"tab\", \"shift\", \"delete\", \"end\"], activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;\n  return function(editor) {\n    return editor.pteWithHotKeys = (event) => {\n      var _a, _b, _c, _d;\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === \"marks\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(hotkey, event.nativeEvent)) {\n              event.preventDefault();\n              const possibleMark = activeHotkeys[cat];\n              if (possibleMark) {\n                const mark = possibleMark[hotkey];\n                debug$7(`HotKey ${hotkey} to toggle ${mark}`), editor.pteToggleMark(mark);\n              }\n            }\n          }\n        if (cat === \"custom\")\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey))\n              throw new Error(`The hotkey ${hotkey} is reserved!`);\n            if ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat];\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey];\n                command(event, portableTextEditor);\n              }\n            }\n          }\n      });\n      const isEnter = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"enter\", event.nativeEvent), isTab = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"tab\", event.nativeEvent), isShiftEnter = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"shift+enter\", event.nativeEvent), isShiftTab = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"shift+tab\", event.nativeEvent), isBackspace = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"backspace\", event.nativeEvent), isDelete = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"delete\", event.nativeEvent), isArrowDown = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"down\", event.nativeEvent), isArrowUp = (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"up\", event.nativeEvent);\n      if (isArrowDown && editor.selection) {\n        const focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (focusBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, focusBlock)) {\n          const nextPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(editor.selection.focus.path.slice(0, 1));\n          if (!slate__WEBPACK_IMPORTED_MODULE_13__.Node.has(editor, nextPath)) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, editor.pteCreateEmptyBlock(), { at: nextPath }), editor.onChange();\n            return;\n          }\n        }\n      }\n      if (isArrowUp && editor.selection) {\n        const isFirstBlock = editor.selection.focus.path[0] === 0, focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (isFirstBlock && focusBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, focusBlock)) {\n          slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(editor, editor.pteCreateEmptyBlock(), { at: [0] }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, { path: [0, 0], offset: 0 }), editor.onChange();\n          return;\n        }\n      }\n      if (isBackspace && editor.selection && editor.selection.focus.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(editor.selection)) {\n        const focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1)), nextPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(editor.selection.focus.path.slice(0, 1)), nextBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.has(editor, nextPath), isTextBlock = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock), isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_b = (_a = focusBlock.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.text) === \"\";\n        if (nextBlock && isTextBlock && isEmptyFocusBlock) {\n          event.preventDefault(), event.stopPropagation(), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), editor.onChange();\n          return;\n        }\n      }\n      if (isBackspace && editor.selection && editor.selection.focus.path[0] > 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(editor.selection)) {\n        const prevPath = slate__WEBPACK_IMPORTED_MODULE_13__.Path.previous(editor.selection.focus.path.slice(0, 1)), prevBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, prevPath), focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n        if (prevBlock && focusBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, prevBlock) && editor.selection.focus.offset === 0) {\n          debug$7(\"Preventing deleting void block above\"), event.preventDefault(), event.stopPropagation();\n          const isTextBlock = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock), isEmptyFocusBlock = isTextBlock && focusBlock.children.length === 1 && ((_d = (_c = focusBlock.children) == null ? void 0 : _c[0]) == null ? void 0 : _d.text) === \"\";\n          if (!isTextBlock || isEmptyFocusBlock) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, prevPath), editor.onChange();\n            return;\n          }\n          if (isTextBlock && !isEmptyFocusBlock) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, prevPath), editor.onChange();\n            return;\n          }\n          return;\n        }\n      }\n      if (isDelete && editor.selection && editor.selection.focus.offset === 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(editor.selection) && editor.children[editor.selection.focus.path[0] + 1]) {\n        const nextBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(\n          editor,\n          slate__WEBPACK_IMPORTED_MODULE_13__.Path.next(editor.selection.focus.path.slice(0, 1))\n        ), focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, focusBlockPath);\n        if (nextBlock && focusBlock && !slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, focusBlock) && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, nextBlock)) {\n          debug$7(\"Preventing deleting void block below\"), event.preventDefault(), event.stopPropagation(), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { match: (n) => n === focusBlock }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(editor, focusBlockPath), editor.onChange();\n          return;\n        }\n      }\n      if ((isTab || isShiftTab) && editor.selection) {\n        const [focusChild] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, editor.selection.focus, { depth: 2 }), [focusBlock] = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) ? slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, editor.selection.focus, { depth: 1 }) : [], hasAnnotationFocus = focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)(focusBlock) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) && (focusChild.marks || []).filter(\n          (m) => (focusBlock.markDefs || []).map((def) => def._key).includes(m)\n        ).length > 0, [start] = slate__WEBPACK_IMPORTED_MODULE_13__.Range.edges(editor.selection), atStartOfNode = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isStart(editor, start, start.path);\n        focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextSpan)(focusChild) && (!hasAnnotationFocus || atStartOfNode) && editor.pteIncrementBlockLevels(isShiftTab) && event.preventDefault();\n      }\n      if (isEnter && !isShiftEnter && editor.selection) {\n        const focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(editor, focusBlockPath);\n        if (editor.isListBlock(focusBlock)) {\n          editor.pteEndList() && event.preventDefault();\n          return;\n        }\n        if (editor.isTextBlock(focusBlock) && focusBlock.style && focusBlock.style !== types.styles[0].value) {\n          const [, end] = slate__WEBPACK_IMPORTED_MODULE_13__.Range.edges(editor.selection);\n          if (slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isEnd(editor, end, end.path)) {\n            slate__WEBPACK_IMPORTED_MODULE_13__.Editor.insertNode(editor, editor.pteCreateEmptyBlock()), event.preventDefault(), editor.onChange();\n            return;\n          }\n        }\n        if (focusBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(editor, focusBlock)) {\n          slate__WEBPACK_IMPORTED_MODULE_13__.Editor.insertNode(editor, editor.pteCreateEmptyBlock()), event.preventDefault(), editor.onChange();\n          return;\n        }\n        event.preventDefault(), editor.insertBreak(), editor.onChange();\n      }\n      if (isShiftEnter) {\n        event.preventDefault(), editor.insertText(`\n`);\n        return;\n      }\n      if ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"mod+z\", event.nativeEvent)) {\n        event.preventDefault(), editor.undo();\n        return;\n      }\n      ((0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"mod+y\", event.nativeEvent) || (0,is_hotkey_esm__WEBPACK_IMPORTED_MODULE_19__.isHotkey)(\"mod+shift+z\", event.nativeEvent)) && (event.preventDefault(), editor.redo());\n    }, editor;\n  };\n}\nfunction validateValue(value, types, keyGenerator) {\n  let resolution = null, valid = !0;\n  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];\n  return value === void 0 ? { valid: !0, resolution: null, value } : !Array.isArray(value) || value.length === 0 ? {\n    valid: !1,\n    resolution: {\n      patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([])],\n      description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n      action: \"Unset the value\",\n      item: value,\n      i18n: {\n        description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n        action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n      }\n    },\n    value\n  } : (value.some((blk, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_10__(blk))\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([index])],\n        description: `Block must be an object, got ${String(blk)}`,\n        action: \"Unset invalid item\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n          action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n          values: { index }\n        }\n      }, !0;\n    if (!blk._key || typeof blk._key != \"string\")\n      return resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ ...blk, _key: keyGenerator() }, [index])],\n        description: `Block at index ${index} is missing required _key.`,\n        action: \"Set the block with a random _key value\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-key.description\",\n          action: \"inputs.portable-text.invalid-value.missing-key.action\",\n          values: { index }\n        }\n      }, !0;\n    if (!blk._type || !validBlockTypes.includes(blk._type)) {\n      if (blk._type === \"block\") {\n        const currentBlockTypeName = types.block.name;\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ ...blk, _type: currentBlockTypeName }, [{ _key: blk._key }])],\n          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n          action: `Use type '${currentBlockTypeName}'`,\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n            action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n            values: { key: blk._key, expectedTypeName: currentBlockTypeName }\n          }\n        }, !0;\n      }\n      return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_14__.isPortableTextTextBlock)({ ...blk, _type: types.block.name }) ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ ...blk, _type: types.block.name }, [{ _key: blk._key }])],\n        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n        action: `Use type '${types.block.name}'`,\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n          values: { key: blk._key, expectedTypeName: types.block.name }\n        }\n      }, !0) : blk._type ? (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }])],\n        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n          action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n          values: { key: blk._key, typeName: blk._type }\n        }\n      }, !0) : (resolution = {\n        patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }])],\n        description: `Block with _key '${blk._key}' is missing an _type property`,\n        action: \"Remove the block\",\n        item: blk,\n        i18n: {\n          description: \"inputs.portable-text.invalid-value.missing-type.description\",\n          action: \"inputs.portable-text.invalid-value.missing-type.action\",\n          values: { key: blk._key }\n        }\n      }, !0);\n    }\n    if (blk._type === types.block.name) {\n      const textBlock = blk;\n      if (textBlock.children && !Array.isArray(textBlock.children))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ children: [] }, [{ _key: textBlock._key }])],\n          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n          action: \"Reset the children property\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n            values: { key: textBlock._key }\n          }\n        }, !0;\n      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n        const newSpan = {\n          _type: types.span.name,\n          _key: keyGenerator(),\n          text: \"\",\n          marks: []\n        };\n        return resolution = {\n          autoResolve: !0,\n          patches: [\n            (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.setIfMissing)([], [{ _key: blk._key }, \"children\"]),\n            (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.insert)([newSpan], \"after\", [{ _key: blk._key }, \"children\", 0])\n          ],\n          description: `Children for text block with _key '${blk._key}' is empty.`,\n          action: \"Insert an empty text\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.empty-children.description\",\n            action: \"inputs.portable-text.invalid-value.empty-children.action\",\n            values: { key: blk._key }\n          }\n        }, !0;\n      }\n      if (blk.markDefs && !Array.isArray(blk.markDefs))\n        return resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ ...textBlock, markDefs: EMPTY_MARKDEFS }, [{ _key: textBlock._key }])],\n          description: \"Block has invalid required property 'markDefs'.\",\n          action: \"Add empty markDefs array\",\n          item: textBlock,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-or-invalid-markdefs.description\",\n            action: \"inputs.portable-text.invalid-value.missing-or-invalid-markdefs.action\",\n            values: { key: textBlock._key }\n          }\n        }, !0;\n      const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__(\n        lodash_flatten_js__WEBPACK_IMPORTED_MODULE_9__(\n          textBlock.children.filter((cld) => cld._type === types.span.name).map((cld) => cld.marks || [])\n        )\n      );\n      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n        const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__(\n          blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key))\n        );\n        if (unusedMarkDefs.length > 0)\n          return resolution = {\n            autoResolve: !0,\n            patches: unusedMarkDefs.map(\n              (markDefKey) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }, \"markDefs\", { _key: markDefKey }])\n            ),\n            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\n              \", \"\n            )}.`,\n            action: \"Remove unused mark definition item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n              values: { key: blk._key, unusedMarkDefs: unusedMarkDefs.map((m) => m.toString()) }\n            }\n          }, !0;\n      }\n      const orphanedMarks = allUsedMarks.filter(\n        (mark) => !types.decorators.map((dec) => dec.value).includes(mark)\n      ).filter(\n        (mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark)\n      );\n      if (orphanedMarks.length > 0) {\n        const spanChildren = textBlock.children.filter(\n          (cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark))\n        );\n        if (spanChildren) {\n          const orphaned = orphanedMarks.join(\", \");\n          return resolution = {\n            autoResolve: !0,\n            patches: spanChildren.map((child) => (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(\n              (child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)),\n              [{ _key: blk._key }, \"children\", { _key: child._key }, \"marks\"]\n            )),\n            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n            action: \"Remove invalid marks\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n              action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n              values: { key: blk._key, orphanedMarks: orphanedMarks.map((m) => m.toString()) }\n            }\n          }, !0;\n        }\n      }\n      textBlock.children.some((child, cIndex) => {\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_10__(child))\n          return resolution = {\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }, \"children\", cIndex])],\n            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n            action: \"Remove the item\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n              action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n              values: { key: blk._key, index: cIndex }\n            }\n          }, !0;\n        if (!child._key || typeof child._key != \"string\") {\n          const newChild = { ...child, _key: keyGenerator() };\n          return resolution = {\n            autoResolve: !0,\n            patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)(newChild, [{ _key: blk._key }, \"children\", cIndex])],\n            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n            action: \"Set a new random _key on the object\",\n            item: blk,\n            i18n: {\n              description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n              action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n              values: { key: blk._key, index: cIndex }\n            }\n          }, !0;\n        }\n        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n          patches: [\n            (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.set)({ ...child, text: \"\" }, [{ _key: blk._key }, \"children\", { _key: child._key }])\n          ],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n          action: \"Write an empty text property to the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n            action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n            values: { key: blk._key, childKey: child._key }\n          }\n        }, !0) : !1 : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }, \"children\", { _key: child._key }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n            values: { key: blk._key, childKey: child._key, childType: child._type }\n          }\n        }, !0) : (resolution = {\n          patches: [(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_18__.unset)([{ _key: blk._key }, \"children\", { _key: child._key }])],\n          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n          action: \"Remove the object\",\n          item: blk,\n          i18n: {\n            description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n            action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n            values: { key: blk._key, childKey: child._key }\n          }\n        }, !0);\n      }) && (valid = !1);\n    }\n    return !1;\n  }) && (valid = !1), { valid, resolution, value });\n}\nconst debug$6 = debugWithName(\"plugin:withInsertData\");\nfunction createWithInsertData(change$, schemaTypes, keyGenerator) {\n  return function(editor) {\n    const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks) => blocks.map((block) => {\n      var _a;\n      return editor.isTextBlock(block) ? block.children.map((child) => {\n        var _a2;\n        return child._type === spanTypeName ? child.text : `[${((_a2 = schemaTypes.inlineObjects.find((t) => t.name === child._type)) == null ? void 0 : _a2.title) || \"Object\"}]`;\n      }).join(\"\") : `[${((_a = schemaTypes.blockObjects.find((t) => t.name === block._type)) == null ? void 0 : _a.title) || \"Object\"}]`;\n    }).join(`\n\n`);\n    return editor.setFragmentData = (data, originEvent) => {\n      const { selection } = editor;\n      if (!selection)\n        return;\n      const [start, end] = slate__WEBPACK_IMPORTED_MODULE_13__.Range.edges(selection), startVoid = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.void(editor, { at: start.path }), endVoid = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.void(editor, { at: end.path });\n      if (slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(selection) && !startVoid)\n        return;\n      const domRange = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMRange(editor, selection);\n      let contents = domRange.cloneContents();\n      if (endVoid) {\n        const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(editor, voidNode);\n        r.setEndAfter(domNode), contents = r.cloneContents();\n      }\n      Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw) => {\n        const isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n        zw.textContent = isNewline ? `\n` : \"\";\n      }), Array.from(contents.querySelectorAll(\"*\")).forEach((elm) => {\n        elm.removeAttribute(\"contentEditable\"), elm.removeAttribute(\"data-slate-inline\"), elm.removeAttribute(\"data-slate-leaf\"), elm.removeAttribute(\"data-slate-node\"), elm.removeAttribute(\"data-slate-spacer\"), elm.removeAttribute(\"data-slate-string\"), elm.removeAttribute(\"data-slate-zero-width\"), elm.removeAttribute(\"draggable\");\n        for (const key in elm.attributes)\n          elm.hasAttribute(key) && elm.removeAttribute(key);\n      });\n      const div = contents.ownerDocument.createElement(\"div\");\n      div.appendChild(contents), div.setAttribute(\"hidden\", \"true\"), contents.ownerDocument.body.appendChild(div);\n      const asHTML = div.innerHTML;\n      contents.ownerDocument.body.removeChild(div);\n      const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);\n      data.clearData(), data.setData(\"text/plain\", asPlainText), data.setData(\"text/html\", asHTML), data.setData(\"application/json\", asJSON), data.setData(\"application/x-portable-text\", asJSON), debug$6(\"text\", asPlainText), data.setData(\"application/x-portable-text-event-origin\", originEvent || \"external\"), debug$6(\"Set fragment data\", asJSON, asHTML);\n    }, editor.insertPortableTextData = (data) => {\n      var _a, _b;\n      if (!editor.selection)\n        return !1;\n      const pText = data.getData(\"application/x-portable-text\"), origin = data.getData(\"application/x-portable-text-event-origin\");\n      if (debug$6(`Inserting portable text from ${origin} event`, pText), pText) {\n        const parsed = JSON.parse(pText);\n        if (Array.isArray(parsed) && parsed.length > 0) {\n          const slateValue = _regenerateKeys(\n            editor,\n            toSlateValue(parsed, { schemaTypes }),\n            keyGenerator,\n            spanTypeName,\n            schemaTypes\n          ), validation = validateValue(parsed, schemaTypes, keyGenerator);\n          if (!validation.valid && !((_a = validation.resolution) != null && _a.autoResolve)) {\n            const errorDescription = `${(_b = validation.resolution) == null ? void 0 : _b.description}`;\n            return change$.next({\n              type: \"error\",\n              level: \"warning\",\n              name: \"pasteError\",\n              description: errorDescription,\n              data: validation\n            }), debug$6(\"Invalid insert result\", validation), !1;\n          }\n          return _insertFragment(editor, slateValue, schemaTypes), !0;\n        }\n      }\n      return !1;\n    }, editor.insertTextOrHTMLData = (data) => {\n      var _a;\n      if (!editor.selection)\n        return debug$6(\"No selection, not inserting\"), !1;\n      change$.next({ type: \"loading\", isLoading: !0 });\n      const html = data.getData(\"text/html\"), text = data.getData(\"text/plain\");\n      if (html || text) {\n        debug$6(\"Inserting data\", data);\n        let portableText, fragment, insertedType;\n        if (html) {\n          if (portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_20__.htmlToBlocks)(html, schemaTypes.portableText, {\n            unstable_whitespaceOnPasteMode: whitespaceOnPasteMode\n          }).map((block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_20__.normalizeBlock)(block, { blockTypeName })), fragment = toSlateValue(portableText, { schemaTypes }), insertedType = \"HTML\", portableText.length === 0)\n            return !1;\n        } else {\n          const textToHtml = `<html><body>${escapeHtml(text).split(/\\n{2,}/).map(\n            (line) => line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\"\n          ).join(\"\")}</body></html>`;\n          portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_20__.htmlToBlocks)(textToHtml, schemaTypes.portableText).map(\n            (block) => (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_20__.normalizeBlock)(block, { blockTypeName })\n          ), fragment = toSlateValue(portableText, {\n            schemaTypes\n          }), insertedType = \"text\";\n        }\n        const validation = validateValue(portableText, schemaTypes, keyGenerator);\n        if (!validation.valid) {\n          const errorDescription = `Could not validate the resulting portable text to insert.\n${(_a = validation.resolution) == null ? void 0 : _a.description}\nTry to insert as plain text (shift-paste) instead.`;\n          return change$.next({\n            type: \"error\",\n            level: \"warning\",\n            name: \"pasteError\",\n            description: errorDescription,\n            data: validation\n          }), debug$6(\"Invalid insert result\", validation), !1;\n        }\n        return debug$6(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), change$.next({ type: \"loading\", isLoading: !1 }), !0;\n      }\n      return change$.next({ type: \"loading\", isLoading: !1 }), !1;\n    }, editor.insertData = (data) => {\n      editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);\n    }, editor.insertFragmentData = (data) => {\n      const fragment = data.getData(\"application/x-portable-text\");\n      if (fragment) {\n        const parsed = JSON.parse(fragment);\n        return editor.insertFragment(parsed), !0;\n      }\n      return !1;\n    }, editor;\n  };\n}\nconst entityMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#x60;\",\n  \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n  return String(str).replace(/[&<>\"'`=/]/g, (s) => entityMap[s]);\n}\nfunction _regenerateKeys(editor, fragment, keyGenerator, spanTypeName, editorTypes) {\n  return fragment.map((node) => {\n    const newNode = { ...node };\n    if (editor.isTextBlock(newNode)) {\n      const annotations = editorTypes.annotations.map((t) => t.name);\n      if (annotations.length === 0) {\n        const { markDefs, ...NewNodeNoDefs } = newNode;\n        return { ...NewNodeNoDefs, _key: keyGenerator() };\n      }\n      if ((newNode.markDefs || []).some((def) => !annotations.includes(def._type))) {\n        const allowedAnnotations = (newNode.markDefs || []).filter((def) => annotations.includes(def._type));\n        return { ...newNode, markDefs: allowedAnnotations, _key: keyGenerator() };\n      }\n      newNode.markDefs = (newNode.markDefs || []).map((def) => {\n        const oldKey = def._key, newKey = keyGenerator();\n        return newNode.children = newNode.children.map(\n          (child) => child._type === spanTypeName && editor.isTextSpan(child) ? {\n            ...child,\n            marks: child.marks && child.marks.includes(oldKey) ? (\n              // eslint-disable-next-line max-nested-callbacks\n              [...child.marks].filter((mark) => mark !== oldKey).concat(newKey)\n            ) : child.marks\n          } : child\n        ), { ...def, _key: newKey };\n      });\n    }\n    const nodeWithNewKeys = { ...newNode, _key: keyGenerator() };\n    return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child) => ({\n      ...child,\n      _key: keyGenerator()\n    }))), nodeWithNewKeys;\n  });\n}\nfunction _insertFragment(editor, fragment, schemaTypes) {\n  editor.withoutNormalizing(() => {\n    if (!editor.selection)\n      return;\n    const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_13__.Editor.node(editor, editor.selection, { depth: 1 });\n    if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n      const { markDefs } = focusBlock;\n      debug$6(\"Mixing markDefs of focusBlock and fragments[0] block\", markDefs, fragment[0].markDefs), lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n        editor,\n        {\n          markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__([...fragment[0].markDefs || [], ...markDefs || []])\n        },\n        { at: focusPath, mode: \"lowest\", voids: !1 }\n      );\n    }\n    isEqualToEmptyEditor(editor.children, schemaTypes) ? (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.splitNodes(editor, { at: [0, 0] }), editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(editor, { at: [0] })) : editor.insertFragment(fragment);\n  }), editor.onChange();\n}\nconst originalFnMap = /* @__PURE__ */ new WeakMap(), withPlugins = (editor, options) => {\n  const e = editor, { keyGenerator, portableTextEditor, patches$, readOnly, maxBlocks } = options, { schemaTypes, change$ } = portableTextEditor;\n  e.subscriptions = [], e.destroy ? e.destroy() : originalFnMap.set(e, {\n    apply: e.apply,\n    onChange: e.onChange,\n    normalizeNode: e.normalizeNode\n  });\n  const operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(schemaTypes, keyGenerator), withSchemaTypes = createWithSchemaTypes({ schemaTypes, keyGenerator }), withEditableAPI = createWithEditableAPI(portableTextEditor, schemaTypes, keyGenerator), withPatches = createWithPatches({\n    change$,\n    keyGenerator,\n    patches$,\n    patchFunctions: operationToPatches,\n    readOnly,\n    schemaTypes\n  }), withMaxBlocks = createWithMaxBlocks(maxBlocks || -1), withPortableTextLists = createWithPortableTextLists(schemaTypes), withUndoRedo = createWithUndoRedo({\n    readOnly,\n    patches$,\n    blockSchemaType: schemaTypes.block\n  }), withPortableTextMarkModel = createWithPortableTextMarkModel(schemaTypes, change$), withPortableTextBlockStyle = createWithPortableTextBlockStyle(schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(), withInsertBreak = createWithInsertBreak(schemaTypes), withUtils = createWithUtils({ keyGenerator, schemaTypes, portableTextEditor }), withPortableTextSelections = createWithPortableTextSelections(change$, schemaTypes);\n  return e.destroy = () => {\n    const originalFunctions = originalFnMap.get(e);\n    if (!originalFunctions)\n      throw new Error(\"Could not find pristine versions of editor functions\");\n    e.apply = originalFunctions.apply, e.history = { undos: [], redos: [] }, e.normalizeNode = originalFunctions.normalizeNode, e.onChange = originalFunctions.onChange;\n  }, readOnly ? {\n    editor: withSchemaTypes(\n      withObjectKeys(\n        withPortableTextMarkModel(\n          withPortableTextBlockStyle(\n            withUtils(\n              withPlaceholderBlock(\n                withPortableTextLists(\n                  withPortableTextSelections(withEditableAPI(withInsertBreak(e)))\n                )\n              )\n            )\n          )\n        )\n      )\n    ),\n    subscribe: () => lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__\n  } : {\n    editor: withSchemaTypes(\n      withObjectKeys(\n        withPortableTextMarkModel(\n          withPortableTextBlockStyle(\n            withPortableTextLists(\n              withPlaceholderBlock(\n                withUtils(\n                  withMaxBlocks(\n                    withUndoRedo(\n                      withPatches(withPortableTextSelections(withEditableAPI(withInsertBreak(e))))\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    ),\n    subscribe: () => {\n      const unsubscribes = [];\n      return editor.subscriptions.forEach((subscribeFn) => {\n        unsubscribes.push(subscribeFn());\n      }), () => {\n        unsubscribes.forEach((unsubscribeFn) => {\n          unsubscribeFn();\n        });\n      };\n    }\n  };\n}, debug$5 = debugWithName(\"component:PortableTextEditor:SlateContainer\");\nfunction SlateContainer(props) {\n  const { patches$, portableTextEditor, readOnly, maxBlocks, keyGenerator } = props, [[slateEditor, subscribe]] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(() => {\n    debug$5(\"Creating new Slate editor instance\");\n    const { editor, subscribe: _sub } = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_16__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_13__.createEditor)()), {\n      keyGenerator,\n      maxBlocks,\n      patches$,\n      portableTextEditor,\n      readOnly\n    });\n    return KEY_TO_VALUE_ELEMENT.set(editor, {}), KEY_TO_SLATE_ELEMENT.set(editor, {}), [editor, _sub];\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const unsubscribe = subscribe();\n    return () => {\n      unsubscribe();\n    };\n  }, [subscribe]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    debug$5(\"Re-initializing plugin chain\"), withPlugins(slateEditor, {\n      keyGenerator,\n      maxBlocks,\n      patches$,\n      portableTextEditor,\n      readOnly\n    });\n  }, [keyGenerator, portableTextEditor, maxBlocks, readOnly, patches$, slateEditor]);\n  const initialValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => [slateEditor.pteCreateEmptyBlock()], [slateEditor]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => () => {\n    debug$5(\"Destroying Slate editor\"), slateEditor.destroy();\n  }, [slateEditor]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_16__.Slate, { editor: slateEditor, initialValue, children: props.children });\n}\nconst defaultKeyGenerator = () => (0,_sanity_util_content__WEBPACK_IMPORTED_MODULE_21__.randomKey)(12), PortableTextEditorKeyGeneratorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(defaultKeyGenerator), usePortableTextEditorKeyGenerator = () => {\n  const keyGenerator = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorKeyGeneratorContext);\n  if (keyGenerator === void 0)\n    throw new Error(\n      \"The `usePortableTextEditorKeyGenerator` hook must be used inside the <PortableTextEditor> component's context.\"\n    );\n  return keyGenerator;\n}, PortableTextEditorSelectionContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null), usePortableTextEditorSelection = () => {\n  const selection = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorSelectionContext);\n  if (selection === void 0)\n    throw new Error(\n      \"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\"\n    );\n  return selection;\n}, PortableTextEditorValueContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(\n  void 0\n), PortableTextEditorReadOnlyContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(!1), usePortableTextEditorReadOnlyStatus = () => {\n  const readOnly = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(PortableTextEditorReadOnlyContext);\n  if (readOnly === void 0)\n    throw new Error(\n      \"The `usePortableTextEditorReadOnly` hook must be used inside the <PortableTextEditor> component's context.\"\n    );\n  return readOnly;\n}, debug$4 = debugWithName(\"hook:useSyncValue\"), CURRENT_VALUE = /* @__PURE__ */ new WeakMap();\nfunction useSyncValue(props) {\n  const { portableTextEditor, readOnly, keyGenerator } = props, { change$, schemaTypes } = portableTextEditor, previousValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlate)(), updateValueFunctionRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(), updateFromCurrentValue = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    const currentValue = CURRENT_VALUE.get(portableTextEditor);\n    if (previousValue.current === currentValue) {\n      debug$4(\"Value is the same object as previous, not need to sync\");\n      return;\n    }\n    updateValueFunctionRef.current && currentValue && (debug$4(\"Updating the value debounced\"), updateValueFunctionRef.current(currentValue));\n  }, [portableTextEditor]), updateValueDebounced = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => lodash_debounce_js__WEBPACK_IMPORTED_MODULE_12__(updateFromCurrentValue, 1e3, { trailing: !0, leading: !1 }),\n    [updateFromCurrentValue]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    const updateFunction = (value) => {\n      CURRENT_VALUE.set(portableTextEditor, value);\n      const isProcessingLocalChanges = isChangingLocally(slateEditor), isProcessingRemoteChanges = isChangingRemotely(slateEditor);\n      if (!readOnly) {\n        if (isProcessingLocalChanges) {\n          debug$4(\"Has local changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n        if (isProcessingRemoteChanges) {\n          debug$4(\"Has remote changes, not syncing value right now\"), updateValueDebounced();\n          return;\n        }\n      }\n      let isChanged = !1, isValid = !0;\n      const hadSelection = !!slateEditor.selection;\n      if ((!value || value.length === 0) && (debug$4(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(slateEditor, () => {\n        withoutSaving(slateEditor, () => {\n          withoutPatching(slateEditor, () => {\n            hadSelection && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(slateEditor);\n            const childrenLength = slateEditor.children.length;\n            slateEditor.children.forEach((_, index) => {\n              slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(slateEditor, {\n                at: [childrenLength - 1 - index]\n              });\n            }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateEmptyBlock(), { at: [0] }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, [0, 0]);\n          });\n        });\n      }), isChanged = !0), value && value.length > 0) {\n        const slateValueFromProps = toSlateValue(value, {\n          schemaTypes\n        });\n        slate__WEBPACK_IMPORTED_MODULE_13__.Editor.withoutNormalizing(slateEditor, () => {\n          withRemoteChanges(slateEditor, () => {\n            withoutSaving(slateEditor, () => {\n              withoutPatching(slateEditor, () => {\n                const childrenLength = slateEditor.children.length;\n                if (slateValueFromProps.length < childrenLength) {\n                  for (let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)\n                    slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(slateEditor, {\n                      at: [i]\n                    });\n                  isChanged = !0;\n                }\n                slateValueFromProps.forEach((currentBlock, currentBlockIndex) => {\n                  var _a, _b, _c, _d, _e;\n                  const oldBlock = slateEditor.children[currentBlockIndex];\n                  if (oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlock, oldBlock) && isValid) {\n                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, keyGenerator);\n                    !validation.valid && (_a = validation.resolution) != null && _a.autoResolve && ((_b = validation.resolution) == null ? void 0 : _b.patches.length) > 0 && !readOnly && previousValue.current && previousValue.current !== value && (console.warn(\n                      `${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${(_c = validation.resolution) == null ? void 0 : _c.description}`\n                    ), validation.resolution.patches.forEach((patch) => {\n                      change$.next({ type: \"patch\", patch });\n                    })), validation.valid || (_d = validation.resolution) != null && _d.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$4.enabled && debug$4(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$4.enabled && debug$4(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), isChanged = !0) : (change$.next({\n                      type: \"invalidValue\",\n                      resolution: validation.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                  if (!oldBlock && isValid) {\n                    const validationValue = [value[currentBlockIndex]], validation = validateValue(validationValue, schemaTypes, keyGenerator);\n                    debug$4.enabled && debug$4(\n                      \"Validating and inserting new block in the end of the value\",\n                      currentBlock\n                    ), validation.valid || (_e = validation.resolution) != null && _e.autoResolve ? withPreserveKeys(slateEditor, () => {\n                      slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, currentBlock, {\n                        at: [currentBlockIndex]\n                      });\n                    }) : (debug$4(\"Invalid\", validation), change$.next({\n                      type: \"invalidValue\",\n                      resolution: validation.resolution,\n                      value\n                    }), isValid = !1);\n                  }\n                });\n              });\n            });\n          });\n        });\n      }\n      if (!isValid) {\n        debug$4(\"Invalid value, returning\");\n        return;\n      }\n      if (isChanged) {\n        debug$4(\"Server value changed, syncing editor\");\n        try {\n          slateEditor.onChange();\n        } catch (err) {\n          console.error(err), change$.next({\n            type: \"invalidValue\",\n            resolution: null,\n            value\n          });\n          return;\n        }\n        hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, {\n          anchor: { path: [0, 0], offset: 0 },\n          focus: { path: [0, 0], offset: 0 }\n        }), slateEditor.onChange()), change$.next({ type: \"value\", value });\n      } else\n        debug$4(\"Server value and editor value is equal, no need to sync.\");\n      previousValue.current = value;\n    };\n    return updateValueFunctionRef.current = updateFunction, updateFunction;\n  }, [\n    change$,\n    keyGenerator,\n    portableTextEditor,\n    readOnly,\n    schemaTypes,\n    slateEditor,\n    updateValueDebounced\n  ]);\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n  const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n  selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(slateEditor, { at: [currentBlockIndex] }), withPreserveKeys(slateEditor, () => {\n    slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, currentBlock, { at: [currentBlockIndex] });\n  }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n  if (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(slateEditor, currentBlock, {\n    at: [currentBlockIndex]\n  }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n    const oldBlockChildrenLength = oldBlock.children.length;\n    currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach(\n      (_, index) => {\n        const childIndex = oldBlockChildrenLength - 1 - index;\n        childIndex > 0 && (debug$4(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, childIndex]\n        }));\n      }\n    ), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {\n      const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(currentBlockChild.text, oldBlockChild == null ? void 0 : oldBlockChild.text), path = [currentBlockIndex, currentBlockChildIndex];\n      if (isChildChanged)\n        if (currentBlockChild._key === (oldBlockChild == null ? void 0 : oldBlockChild._key)) {\n          debug$4(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(slateEditor, currentBlockChild, {\n            at: path\n          });\n          const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n          isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.delete(slateEditor, {\n            at: { focus: { path, offset: 0 }, anchor: { path, offset: oldBlockChild.text.length } }\n          }), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n            at: path\n          }), slateEditor.onChange()) : isSpanNode || (debug$4(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.setNodes(\n            slateEditor,\n            { _key: VOID_CHILD_KEY },\n            {\n              at: [...path, 0],\n              voids: !0\n            }\n          ));\n        } else oldBlockChild ? (debug$4(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.removeNodes(slateEditor, {\n          at: [currentBlockIndex, currentBlockChildIndex]\n        }), withPreserveKeys(slateEditor, () => {\n          slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n            at: [currentBlockIndex, currentBlockChildIndex]\n          });\n        }), slateEditor.onChange()) : oldBlockChild || (debug$4(\"Inserting new child\", currentBlockChild), withPreserveKeys(slateEditor, () => {\n          slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n            at: [currentBlockIndex, currentBlockChildIndex]\n          }), slateEditor.onChange();\n        }));\n    });\n  }\n}\nconst debug$3 = debugWithName(\"component:PortableTextEditor:Synchronizer\"), debugVerbose = debug$3.enabled && !1, FLUSH_PATCHES_THROTTLED_MS =  false ? 0 : 1e3;\nfunction Synchronizer(props) {\n  const { change$, portableTextEditor, onChange, keyGenerator, readOnly, value } = props, [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null), pendingPatches = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]), syncValue = useSyncValue({\n    keyGenerator,\n    onChange,\n    portableTextEditor,\n    readOnly\n  }), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlate)();\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, [slateEditor]);\n  const onFlushPendingPatches = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (pendingPatches.current.length > 0) {\n      debug$3(\"Flushing pending patches\"), debugVerbose && debug$3(`Patches:\n${JSON.stringify(pendingPatches.current, null, 2)}`);\n      const snapshot = PortableTextEditor.getValue(portableTextEditor);\n      change$.next({ type: \"mutation\", patches: pendingPatches.current, snapshot }), pendingPatches.current = [];\n    }\n    IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !1);\n  }, [slateEditor, portableTextEditor, change$]), onFlushPendingPatchesThrottled = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => lodash_throttle_js__WEBPACK_IMPORTED_MODULE_11__(\n    () => {\n      if (slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isNormalizing(slateEditor)) {\n        onFlushPendingPatches();\n        return;\n      }\n      onFlushPendingPatchesThrottled();\n    },\n    FLUSH_PATCHES_THROTTLED_MS,\n    {\n      leading: !1,\n      trailing: !0\n    }\n  ), [onFlushPendingPatches, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => () => {\n    onFlushPendingPatches();\n  }, [onFlushPendingPatches]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    debug$3(\"Subscribing to editor changes$\");\n    const sub = change$.subscribe((next) => {\n      switch (next.type) {\n        case \"patch\":\n          IS_PROCESSING_LOCAL_CHANGES.set(slateEditor, !0), pendingPatches.current.push(next.patch), onFlushPendingPatchesThrottled(), onChange(next);\n          break;\n        case \"selection\":\n          (0,react__WEBPACK_IMPORTED_MODULE_3__.startTransition)(() => {\n            debugVerbose && debug$3(\"Setting selection\"), setSelection(next.selection);\n          }), onChange(next);\n          break;\n        default:\n          onChange(next);\n      }\n    });\n    return () => {\n      debug$3(\"Unsubscribing to changes$\"), sub.unsubscribe();\n    };\n  }, [change$, onChange, onFlushPendingPatchesThrottled, slateEditor]);\n  const handleOnline = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    debug$3(\"Editor is online, syncing from props.value\"), change$.next({ type: \"connection\", value: \"online\" }), syncValue(value);\n  }, [change$, syncValue, value]), handleOffline = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    debug$3(\"Editor is offline\"), change$.next({ type: \"connection\", value: \"offline\" });\n  }, [change$]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => (portableTextEditor.props.patches$ && (window.addEventListener(\"online\", handleOnline), window.addEventListener(\"offline\", handleOffline)), () => {\n    portableTextEditor.props.patches$ && (window.removeEventListener(\"online\", handleOnline), window.removeEventListener(\"offline\", handleOffline));\n  }));\n  const isInitialValueFromProps = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(!0);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    debug$3(\"Value from props changed, syncing new value\"), syncValue(value), isInitialValueFromProps.current && (change$.next({ type: \"loading\", isLoading: !1 }), change$.next({ type: \"ready\" }), isInitialValueFromProps.current = !1);\n  }, [change$, syncValue, value]), /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorKeyGeneratorContext.Provider, { value: keyGenerator, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorContext.Provider, { value: portableTextEditor, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorValueContext.Provider, { value, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorReadOnlyContext.Provider, { value: readOnly, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PortableTextEditorSelectionContext.Provider, { value: selection, children: props.children }) }) }) }) });\n}\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => __defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value);\nconst debug$2 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n  constructor(props) {\n    if (super(props), __publicField(this, \"change$\", new rxjs__WEBPACK_IMPORTED_MODULE_22__.Subject()), __publicField(this, \"schemaTypes\"), __publicField(this, \"editable\"), __publicField(this, \"setEditable\", (editable) => {\n      this.editable = { ...this.editable, ...editable };\n    }), !props.schemaType)\n      throw new Error('PortableTextEditor: missing \"type\" property');\n    props.incomingPatches$ && console.warn(\"The prop 'incomingPatches$' is deprecated and renamed to 'patches$'\"), this.change$.next({ type: \"loading\", isLoading: !0 }), this.schemaTypes = getPortableTextMemberSchemaTypes(\n      props.schemaType.hasOwnProperty(\"jsonType\") ? props.schemaType : compileType(props.schemaType)\n    );\n  }\n  componentDidUpdate(prevProps) {\n    this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = getPortableTextMemberSchemaTypes(\n      this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)\n    )), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this);\n  }\n  render() {\n    const { onChange, value, children, patches$, incomingPatches$ } = this.props, { change$ } = this, _patches$ = incomingPatches$ || patches$, maxBlocks = typeof this.props.maxBlocks > \"u\" ? void 0 : parseInt(this.props.maxBlocks.toString(), 10) || void 0, readOnly = !!this.props.readOnly, keyGenerator = this.props.keyGenerator || defaultKeyGenerator;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      SlateContainer,\n      {\n        keyGenerator,\n        maxBlocks,\n        patches$: _patches$,\n        portableTextEditor: this,\n        readOnly,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          Synchronizer,\n          {\n            change$,\n            keyGenerator,\n            onChange,\n            portableTextEditor: this,\n            readOnly,\n            value,\n            children\n          }\n        )\n      }\n    );\n  }\n}\n__publicField(PortableTextEditor, \"activeAnnotations\", (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : []), __publicField(PortableTextEditor, \"isAnnotationActive\", (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1), __publicField(PortableTextEditor, \"addAnnotation\", (editor, type, value) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.addAnnotation(type, value);\n}), __publicField(PortableTextEditor, \"blur\", (editor) => {\n  var _a;\n  debug$2(\"Host blurred\"), (_a = editor.editable) == null || _a.blur();\n}), __publicField(PortableTextEditor, \"delete\", (editor, selection, options) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.delete(selection, options);\n}), __publicField(PortableTextEditor, \"findDOMNode\", (editor, element) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.findDOMNode(element);\n}), __publicField(PortableTextEditor, \"findByPath\", (editor, path) => {\n  var _a;\n  return ((_a = editor.editable) == null ? void 0 : _a.findByPath(path)) || [];\n}), __publicField(PortableTextEditor, \"focus\", (editor) => {\n  var _a;\n  debug$2(\"Host requesting focus\"), (_a = editor.editable) == null || _a.focus();\n}), __publicField(PortableTextEditor, \"focusBlock\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.focusBlock();\n}), __publicField(PortableTextEditor, \"focusChild\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.focusChild();\n}), __publicField(PortableTextEditor, \"getSelection\", (editor) => editor.editable ? editor.editable.getSelection() : null), __publicField(PortableTextEditor, \"getValue\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.getValue();\n}), __publicField(PortableTextEditor, \"hasBlockStyle\", (editor, blockStyle) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.hasBlockStyle(blockStyle);\n}), __publicField(PortableTextEditor, \"hasListStyle\", (editor, listStyle) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.hasListStyle(listStyle);\n}), __publicField(PortableTextEditor, \"isCollapsedSelection\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.isCollapsedSelection();\n}), __publicField(PortableTextEditor, \"isExpandedSelection\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.isExpandedSelection();\n}), __publicField(PortableTextEditor, \"isMarkActive\", (editor, mark) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.isMarkActive(mark);\n}), __publicField(PortableTextEditor, \"insertChild\", (editor, type, value) => {\n  var _a;\n  return debug$2(\"Host inserting child\"), (_a = editor.editable) == null ? void 0 : _a.insertChild(type, value);\n}), __publicField(PortableTextEditor, \"insertBlock\", (editor, type, value) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.insertBlock(type, value);\n}), __publicField(PortableTextEditor, \"insertBreak\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.insertBreak();\n}), __publicField(PortableTextEditor, \"isVoid\", (editor, element) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.isVoid(element);\n}), __publicField(PortableTextEditor, \"isObjectPath\", (editor, path) => {\n  if (!path || !Array.isArray(path)) return !1;\n  const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n  return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n}), __publicField(PortableTextEditor, \"marks\", (editor) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.marks();\n}), __publicField(PortableTextEditor, \"select\", (editor, selection) => {\n  var _a;\n  debug$2(\"Host setting selection\", selection), (_a = editor.editable) == null || _a.select(selection);\n}), __publicField(PortableTextEditor, \"removeAnnotation\", (editor, type) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.removeAnnotation(type);\n}), __publicField(PortableTextEditor, \"toggleBlockStyle\", (editor, blockStyle) => {\n  var _a;\n  return debug$2(\"Host is toggling block style\"), (_a = editor.editable) == null ? void 0 : _a.toggleBlockStyle(blockStyle);\n}), __publicField(PortableTextEditor, \"toggleList\", (editor, listStyle) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.toggleList(listStyle);\n}), __publicField(PortableTextEditor, \"toggleMark\", (editor, mark) => {\n  var _a;\n  debug$2(\"Host toggling mark\", mark), (_a = editor.editable) == null || _a.toggleMark(mark);\n}), __publicField(PortableTextEditor, \"getFragment\", (editor) => {\n  var _a;\n  return debug$2(\"Host getting fragment\"), (_a = editor.editable) == null ? void 0 : _a.getFragment();\n}), __publicField(PortableTextEditor, \"undo\", (editor) => {\n  var _a;\n  debug$2(\"Host undoing\"), (_a = editor.editable) == null || _a.undo();\n}), __publicField(PortableTextEditor, \"redo\", (editor) => {\n  var _a;\n  debug$2(\"Host redoing\"), (_a = editor.editable) == null || _a.redo();\n}), __publicField(PortableTextEditor, \"isSelectionsOverlapping\", (editor, selectionA, selectionB) => {\n  var _a;\n  return (_a = editor.editable) == null ? void 0 : _a.isSelectionsOverlapping(selectionA, selectionB);\n});\nconst debug$1 = debugWithName(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props) => {\n  const { attributes, children, leaf, schemaTypes, renderChild, renderDecorator, renderAnnotation } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => block ? [{ _key: block == null ? void 0 : block._key }, \"children\", { _key: leaf._key }] : [],\n    [block, leaf._key]\n  ), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators]\n  ), marks = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => lodash_uniq_js__WEBPACK_IMPORTED_MODULE_5__((leaf.marks || EMPTY_MARKS).filter((mark) => decoratorValues.includes(mark))),\n    [decoratorValues, leaf.marks]\n  ), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => annotationMarks.map(\n      (mark) => {\n        var _a;\n        return !decoratorValues.includes(mark) && ((_a = block == null ? void 0 : block.markDefs) == null ? void 0 : _a.find((def) => def._key === mark));\n      }\n    ).filter(Boolean),\n    [annotationMarks, block, decoratorValues]\n  ), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(!1);\n      return;\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor);\n    sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_3__.startTransition)(() => {\n      setFocused(!0);\n    });\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor]);\n  const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    debug$1(\"Setting selection and focus from range\");\n    const winSelection = window.getSelection();\n    if (!winSelection) {\n      setSelected(!1);\n      return;\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0);\n      spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n    } else\n      setSelected(!1);\n  }, [shouldTrackSelectionAndFocus]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (!shouldTrackSelectionAndFocus)\n      return;\n    const sub = portableTextEditor.change$.subscribe((next) => {\n      if (next.type === \"blur\") {\n        setFocused(!1), setSelected(!1);\n        return;\n      }\n      if (next.type === \"focus\") {\n        const sel = PortableTextEditor.getSelection(portableTextEditor);\n        sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n        return;\n      }\n      next.type === \"selection\" && (next.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(next.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange());\n    });\n    return () => {\n      sub.unsubscribe();\n    };\n  }, [path, portableTextEditor, setSelectedFromRange, shouldTrackSelectionAndFocus]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => setSelectedFromRange(), [setSelectedFromRange]);\n  const content = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    let returnedChildren = children;\n    if (slate__WEBPACK_IMPORTED_MODULE_13__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark) => {\n      const schemaType = schemaTypes.decorators.find((dec) => dec.value === mark);\n      if (schemaType && renderDecorator) {\n        const _props = Object.defineProperty(\n          {\n            children: returnedChildren,\n            editorElementRef: spanRef,\n            focused,\n            path,\n            selected,\n            schemaType,\n            value: mark\n          },\n          \"type\",\n          {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n            }\n          }\n        );\n        returnedChildren = renderDecorator(_props);\n      }\n    }), block && annotations.length > 0 && annotations.forEach((annotation) => {\n      const schemaType = schemaTypes.annotations.find((t) => t.name === annotation._type);\n      if (schemaType)\n        if (renderAnnotation) {\n          const _props = Object.defineProperty(\n            {\n              block,\n              children: returnedChildren,\n              editorElementRef: spanRef,\n              focused,\n              path,\n              selected,\n              schemaType,\n              value: annotation\n            },\n            \"type\",\n            {\n              enumerable: !1,\n              get() {\n                return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n              }\n            }\n          );\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: renderAnnotation(_props) });\n        } else\n          returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultAnnotation, { annotation, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ref: spanRef, children: returnedChildren }) });\n    }), block && renderChild)) {\n      const child = block.children.find((_child) => _child._key === leaf._key);\n      if (child) {\n        const _props = Object.defineProperty(\n          {\n            annotations,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: returnedChildren }),\n            editorElementRef: spanRef,\n            focused,\n            path,\n            schemaType: schemaTypes.span,\n            selected,\n            value: child\n          },\n          \"type\",\n          {\n            enumerable: !1,\n            get() {\n              return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n            }\n          }\n        );\n        returnedChildren = renderChild(_props);\n      }\n    }\n    return returnedChildren;\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected\n  ]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { ...attributes, ref: spanRef, children: content }, leaf._key),\n    [leaf, attributes, content]\n  );\n}, debug = debugWithName(\"component:Editable\"), PLACEHOLDER_STYLE = {\n  position: \"absolute\",\n  userSelect: \"none\",\n  pointerEvents: \"none\",\n  left: 0,\n  right: 0\n}, EMPTY_DECORATIONS_STATE = [], PortableTextEditable = (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)(function(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onClick,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props, portableTextEditor = usePortableTextEditor(), readOnly = usePortableTextEditorReadOnlyStatus(), keyGenerator = usePortableTextEditorKeyGenerator(), ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(EMPTY_DECORATIONS_STATE);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useImperativeHandle)(forwardedRef, () => ref.current);\n  const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(rangeDecorations), { change$, schemaTypes } = portableTextEditor, slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_16__.useSlate)(), blockTypeName = schemaTypes.block.name, withInsertData = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => createWithInsertData(change$, schemaTypes, keyGenerator),\n    [change$, keyGenerator, schemaTypes]\n  ), withHotKeys = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(\n    () => createWithHotkeys(schemaTypes, portableTextEditor, hotkeys),\n    [hotkeys, portableTextEditor, schemaTypes]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => readOnly ? (debug(\"Editable is in read only mode\"), withInsertData(slateEditor)) : (debug(\"Editable is in edit mode\"), withInsertData(withHotKeys(slateEditor))), [readOnly, slateEditor, withHotKeys, withInsertData]);\n  const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (eProps) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      Element,\n      {\n        ...eProps,\n        readOnly,\n        renderBlock,\n        renderChild,\n        renderListItem,\n        renderStyle,\n        schemaTypes,\n        spellCheck\n      }\n    ),\n    [schemaTypes, spellCheck, readOnly, renderBlock, renderChild, renderListItem, renderStyle]\n  ), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (lProps) => {\n      if (lProps.leaf._type === \"span\") {\n        let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          Leaf,\n          {\n            ...lProps,\n            schemaTypes,\n            renderAnnotation,\n            renderChild,\n            renderDecorator,\n            readOnly\n          }\n        );\n        if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\")\n          return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: renderPlaceholder() }),\n            rendered\n          ] });\n        const decoration = lProps.leaf.rangeDecoration;\n        return decoration && (rendered = decoration.component({ children: rendered })), rendered;\n      }\n      return lProps.children;\n    },\n    [readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder, schemaTypes]\n  ), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName)\n      );\n      if (normalizedSelection !== null) {\n        debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n        const slateRange = toSlateRange(normalizedSelection, slateEditor);\n        slateRange && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o) => o.type === \"set_selection\") || change$.next({ type: \"selection\", selection: normalizedSelection }), slateEditor.onChange());\n      }\n    }\n  }, [propsSelection, slateEditor, blockTypeName, change$]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges = [];\n        if (rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(rangeDecorationItem.selection, slateEditor);\n          if (!slate__WEBPACK_IMPORTED_MODULE_13__.Range.isRange(slateRange)) {\n            rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n              newSelection: null,\n              rangeDecoration: rangeDecorationItem,\n              origin: \"local\"\n            });\n            return;\n          }\n          let newRange;\n          if (operation && (newRange = moveRangeByOperation(slateRange, operation), newRange && newRange !== slateRange || newRange === null && slateRange)) {\n            const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);\n            rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n              newSelection: newRangeSelection,\n              rangeDecoration: rangeDecorationItem,\n              origin: \"local\"\n            });\n          }\n          newRange !== null && newSlateRanges.push({ ...newRange || slateRange, rangeDecoration: rangeDecorationItem });\n        }), newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges);\n          return;\n        }\n      }\n      setRangeDecorationsState(EMPTY_DECORATIONS_STATE);\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    const sub = change$.subscribe((next) => {\n      switch (next.type) {\n        case \"ready\":\n          restoreSelectionFromProps();\n          break;\n        case \"invalidValue\":\n          setHasInvalidValue(!0);\n          break;\n        case \"value\":\n          setHasInvalidValue(!1);\n          break;\n      }\n    });\n    return () => {\n      sub.unsubscribe();\n    };\n  }, [change$, restoreSelectionFromProps]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps]);\n  const originalApply = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => slateEditor.apply, [slateEditor]), [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n  }, [syncRangeDecorations, syncedRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n  }, [rangeDecorations, syncRangeDecorations]), (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => (slateEditor.apply = (op) => {\n    originalApply(op), op.type !== \"set_selection\" && syncRangeDecorations(op);\n  }, () => {\n    slateEditor.apply = originalApply;\n  }), [originalApply, slateEditor, syncRangeDecorations]);\n  const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      onCopy && onCopy(event) !== void 0 && event.preventDefault();\n    },\n    [onCopy]\n  ), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      if (event.preventDefault(), !slateEditor.selection)\n        return;\n      if (!onPaste) {\n        debug(\"Pasting normally\"), slateEditor.insertData(event.clipboardData);\n        return;\n      }\n      const value = PortableTextEditor.getValue(portableTextEditor), ptRange = toPortableTextRange(value, slateEditor.selection, schemaTypes), path = (ptRange == null ? void 0 : ptRange.focus.path) || [], onPasteResult = onPaste({ event, value, path, schemaTypes });\n      onPasteResult === void 0 ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event.clipboardData)) : (change$.next({ type: \"loading\", isLoading: !0 }), Promise.resolve(onPasteResult).then((result) => {\n        debug(\"Custom paste function from client resolved\", result), !result || !result.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event.clipboardData)) : result.insert ? slateEditor.insertFragment(\n          toSlateValue(result.insert, { schemaTypes })\n        ) : console.warn(\"Your onPaste function returned something unexpected:\", result);\n      }).catch((error) => (console.error(error), error)).finally(() => {\n        change$.next({ type: \"loading\", isLoading: !1 });\n      }));\n    },\n    [change$, onPaste, portableTextEditor, schemaTypes, slateEditor]\n  ), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      if (onFocus && onFocus(event), !event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor);\n        selection === null && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_13__.Editor.start(slateEditor, [])), slateEditor.onChange()), change$.next({ type: \"focus\", event });\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n        selection === newSelection && change$.next({\n          type: \"selection\",\n          selection\n        });\n      }\n    },\n    [onFocus, portableTextEditor, change$, slateEditor]\n  ), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      if (onClick && onClick(event), slateEditor.selection && event.target === event.currentTarget) {\n        const [lastBlock, path] = slate__WEBPACK_IMPORTED_MODULE_13__.Node.last(slateEditor, []), focusPath = slateEditor.selection.focus.path.slice(0, 1), lastPath = path.slice(0, 1);\n        if (slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(focusPath, lastPath)) {\n          const node = slate__WEBPACK_IMPORTED_MODULE_13__.Node.descendant(slateEditor, path.slice(0, 1));\n          lastBlock && slate__WEBPACK_IMPORTED_MODULE_13__.Editor.isVoid(slateEditor, node) && (slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateEmptyBlock()), slateEditor.onChange());\n        }\n      }\n    },\n    [onClick, slateEditor]\n  ), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      onBlur && onBlur(event), event.isPropagationStopped() || change$.next({ type: \"blur\", event });\n    },\n    [change$, onBlur]\n  ), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      onBeforeInput && onBeforeInput(event);\n    },\n    [onBeforeInput]\n  ), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(() => {\n    if (!slateEditor.selection)\n      return;\n    const root = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.findDocumentOrShadowRoot(slateEditor), { activeElement } = root;\n    if (ref.current !== activeElement)\n      return;\n    const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.getWindow(slateEditor).getSelection();\n    if (!domSelection || domSelection.rangeCount === 0)\n      return;\n    const existingDOMRange = domSelection.getRangeAt(0);\n    try {\n      const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n      (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection == null || domSelection.removeAllRanges(), domSelection.addRange(newDOMRange));\n    } catch {\n      debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_13__.Transforms.select(slateEditor, [0, 0]), slateEditor.onChange();\n    }\n  }, [ref, slateEditor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection);\n      return mutationObserver.observe(editableElement, {\n        attributeOldValue: !1,\n        attributes: !1,\n        characterData: !1,\n        childList: !0,\n        subtree: !0\n      }), () => {\n        mutationObserver.disconnect();\n      };\n    }\n  }, [validateSelection, editableElement]);\n  const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    (event) => {\n      props.onKeyDown && props.onKeyDown(event), event.isDefaultPrevented() || slateEditor.pteWithHotKeys(event);\n    },\n    [props, slateEditor]\n  ), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(() => {\n    if (scrollSelectionIntoView !== void 0)\n      return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_2__ : (editor, domRange) => {\n        scrollSelectionIntoView(portableTextEditor, domRange);\n      };\n  }, [portableTextEditor, scrollSelectionIntoView]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes))\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0\n            },\n            placeholder: !0\n          }\n        ];\n      if (path.length === 0)\n        return EMPTY_DECORATIONS_STATE;\n      const result = rangeDecorationState.filter((item) => slate__WEBPACK_IMPORTED_MODULE_13__.Range.isCollapsed(item) ? path.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(item.focus.path, path) && slate__WEBPACK_IMPORTED_MODULE_13__.Path.equals(item.anchor.path, path) : slate__WEBPACK_IMPORTED_MODULE_13__.Range.intersection(item, { anchor: { path, offset: 0 }, focus: { path, offset: 0 } }) || slate__WEBPACK_IMPORTED_MODULE_13__.Range.includes(item, path));\n      return result.length > 0 ? result : EMPTY_DECORATIONS_STATE;\n    },\n    [slateEditor, schemaTypes, rangeDecorationState]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(() => {\n    ref.current = slate_react__WEBPACK_IMPORTED_MODULE_16__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n  }, [slateEditor, ref]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    slate_react__WEBPACK_IMPORTED_MODULE_16__.Editable,\n    {\n      ...restProps,\n      autoFocus: !1,\n      className: restProps.className || \"pt-editable\",\n      decorate,\n      onBlur: handleOnBlur,\n      onCopy: handleCopy,\n      onClick: handleClick,\n      onDOMBeforeInput: handleOnBeforeInput,\n      onFocus: handleOnFocus,\n      onKeyDown: handleKeyDown,\n      onPaste: handlePaste,\n      readOnly,\n      renderPlaceholder: void 0,\n      renderElement,\n      renderLeaf,\n      scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }\n  ) : null;\n});\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ2hCO0FBQ047QUFDZ0k7QUFDeEM7QUFDYjtBQUNqRjtBQUN1RjtBQUN4RTtBQUNUO0FBQ0g7QUFDUztBQUMrRTtBQUN2RjtBQUNnQjtBQUNWO0FBQ0U7QUFDQztBQUMwQjtBQUNmO0FBQ1Y7QUFDTztBQUNQO0FBQzFDO0FBQ0Esa0NBQU87QUFDUDtBQUNBLHVCQUF1QixTQUFTLEVBQUUsS0FBSztBQUN2QyxTQUFTLGtDQUFPLElBQUksMENBQWUsY0FBYyxrQ0FBTyxjQUFjLGtDQUFPO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQ0FBTTtBQUNWO0FBQ0Esb0JBQW9CLDREQUFZO0FBQ2hDLEtBQUs7QUFDTDtBQUNBLGlCQUFpQiwyQ0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsOENBQU8sSUFBSSxrQkFBa0I7QUFDbkg7QUFDQTtBQUNBLFdBQVcsMkNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IseUNBQUssbUJBQW1CLHlDQUFLO0FBQ25ELDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGdCQUFnQjtBQUMxRztBQUNBO0FBQ0EsaUJBQWlCLHlDQUFLLDZDQUE2Qyx5Q0FBSztBQUN4RSxvREFBb0Qs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QVU7QUFDbko7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixrREFBVztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDLDhDQUFPO0FBQzdDO0FBQ0EsZ0RBQWdELDJDQUFJO0FBQ3BEO0FBQ0E7QUFDQSxHQUFHLDZEQUE2RCxrREFBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx5Q0FBSyw4Q0FBOEMsd0NBQUksa0NBQWtDLHdDQUFJLGtDQUFrQyx5Q0FBSyxzQkFBc0IsVUFBVSxpQkFBaUIsV0FBVyxtQkFBbUIsS0FBSyx5Q0FBSztBQUN4UjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUyxnREFBUztBQUNsQixrQkFBa0IscURBQVc7QUFDN0IsR0FBRyxxRkFBcUYsc0RBQUc7QUFDM0YsSUFBSSxrREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQU9DO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmNvbW1vbm9yZy1ibG9nLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9pbmRleC5tanM/ZGZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIEZyYWdtZW50LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCBub29wIGZyb20gXCJsb2Rhc2gvbm9vcC5qc1wiO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgc3RhcnRUcmFuc2l0aW9uLCBDb21wb25lbnQsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEVkaXRvciwgRWxlbWVudCBhcyBFbGVtZW50JDEsIFJhbmdlLCBQb2ludCwgVGV4dCwgUGF0aCwgVHJhbnNmb3JtcywgTm9kZSwgT3BlcmF0aW9uLCBjcmVhdGVFZGl0b3IgfSBmcm9tIFwic2xhdGVcIjtcbmltcG9ydCB7IHVzZVNsYXRlU3RhdGljLCBSZWFjdEVkaXRvciwgdXNlU2VsZWN0ZWQsIHdpdGhSZWFjdCwgU2xhdGUsIHVzZVNsYXRlLCBFZGl0YWJsZSB9IGZyb20gXCJzbGF0ZS1yZWFjdFwiO1xuaW1wb3J0IGRlYnVnJGwgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBpc0tleVNlZ21lbnQsIGlzUG9ydGFibGVUZXh0U3BhbiwgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0TGlzdEJsb2NrIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IHN0eWxlZCB9IGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcImxvZGFzaC91bmlxLmpzXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gXCJAc2FuaXR5L3NjaGVtYVwiO1xuaW1wb3J0IHsgZGlmZk1hdGNoUGF0Y2ggYXMgZGlmZk1hdGNoUGF0Y2gkMSwgc2V0LCBpbnNlcnQsIHNldElmTWlzc2luZywgdW5zZXQsIGFwcGx5QWxsIH0gZnJvbSBcIkBwb3J0YWJsZXRleHQvcGF0Y2hlc1wiO1xuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoL2dldC5qc1wiO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gXCJsb2Rhc2gvaXNVbmRlZmluZWQuanNcIjtcbmltcG9ydCBvbWl0QnkgZnJvbSBcImxvZGFzaC9vbWl0QnkuanNcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IHsgaXNIb3RrZXkgfSBmcm9tIFwiaXMtaG90a2V5LWVzbVwiO1xuaW1wb3J0IHsgaHRtbFRvQmxvY2tzLCBub3JtYWxpemVCbG9jayB9IGZyb20gXCJAc2FuaXR5L2Jsb2NrLXRvb2xzXCI7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tIFwibG9kYXNoL2lzUGxhaW5PYmplY3QuanNcIjtcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwibG9kYXNoL3Rocm90dGxlLmpzXCI7XG5pbXBvcnQgeyByYW5kb21LZXkgfSBmcm9tIFwiQHNhbml0eS91dGlsL2NvbnRlbnRcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwibG9kYXNoL2RlYm91bmNlLmpzXCI7XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJGwocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckbCAmJiBkZWJ1ZyRsLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJGwobmFtZXNwYWNlKSA6IGRlYnVnJGwocm9vdE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5ZWRQYXRoKHBvaW50LCB2YWx1ZSwgdHlwZXMpIHtcbiAgY29uc3QgYmxvY2tQYXRoID0gW3BvaW50LnBhdGhbMF1dO1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBibG9jayA9IHZhbHVlW2Jsb2NrUGF0aFswXV07XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGtleWVkQmxvY2tQYXRoID0gW3sgX2tleTogYmxvY2suX2tleSB9XTtcbiAgaWYgKGJsb2NrLl90eXBlICE9PSB0eXBlcy5ibG9jay5uYW1lKVxuICAgIHJldHVybiBrZXllZEJsb2NrUGF0aDtcbiAgbGV0IGtleWVkQ2hpbGRQYXRoO1xuICBjb25zdCBjaGlsZFBhdGggPSBwb2ludC5wYXRoLnNsaWNlKDAsIDIpLCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuW2NoaWxkUGF0aFsxXV07XG4gIHJldHVybiBjaGlsZCAmJiAoa2V5ZWRDaGlsZFBhdGggPSBbXCJjaGlsZHJlblwiLCB7IF9rZXk6IGNoaWxkLl9rZXkgfV0pLCBrZXllZENoaWxkUGF0aCA/IFsuLi5rZXllZEJsb2NrUGF0aCwgLi4ua2V5ZWRDaGlsZFBhdGhdIDoga2V5ZWRCbG9ja1BhdGg7XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheWVkUGF0aChwb2ludCwgZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gQXJyYXkuZnJvbShcbiAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogW10sXG4gICAgICBtYXRjaDogKG4pID0+IGlzS2V5U2VnbWVudChwb2ludC5wYXRoWzBdKSAmJiBuLl9rZXkgPT09IHBvaW50LnBhdGhbMF0uX2tleVxuICAgIH0pXG4gIClbMF0gfHwgW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFibG9jayB8fCAhRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoZWRpdG9yLmlzVm9pZChibG9jaykpXG4gICAgcmV0dXJuIFtibG9ja1BhdGhbMF0sIDBdO1xuICBjb25zdCBjaGlsZFBhdGggPSBbcG9pbnQucGF0aFsyXV0sIGNoaWxkSW5kZXggPSBibG9jay5jaGlsZHJlbi5maW5kSW5kZXgoKGNoaWxkKSA9PiBpc0VxdWFsKFt7IF9rZXk6IGNoaWxkLl9rZXkgfV0sIGNoaWxkUGF0aCkpO1xuICBpZiAoY2hpbGRJbmRleCA+PSAwICYmIGJsb2NrLmNoaWxkcmVuW2NoaWxkSW5kZXhdKSB7XG4gICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltjaGlsZEluZGV4XTtcbiAgICByZXR1cm4gRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZCkgJiYgZWRpdG9yLmlzVm9pZChjaGlsZCkgPyBibG9ja1BhdGguY29uY2F0KGNoaWxkSW5kZXgpLmNvbmNhdCgwKSA6IGJsb2NrUGF0aC5jb25jYXQoY2hpbGRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIGJsb2NrUGF0aDtcbn1cbmZ1bmN0aW9uIHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIHJhbmdlLCB0eXBlcykge1xuICBpZiAoIXJhbmdlKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgYW5jaG9yID0gbnVsbCwgZm9jdXMgPSBudWxsO1xuICBjb25zdCBhbmNob3JQYXRoID0gcmFuZ2UuYW5jaG9yICYmIGNyZWF0ZUtleWVkUGF0aChyYW5nZS5hbmNob3IsIHZhbHVlLCB0eXBlcyk7XG4gIGFuY2hvclBhdGggJiYgcmFuZ2UuYW5jaG9yICYmIChhbmNob3IgPSB7XG4gICAgcGF0aDogYW5jaG9yUGF0aCxcbiAgICBvZmZzZXQ6IHJhbmdlLmFuY2hvci5vZmZzZXRcbiAgfSk7XG4gIGNvbnN0IGZvY3VzUGF0aCA9IHJhbmdlLmZvY3VzICYmIGNyZWF0ZUtleWVkUGF0aChyYW5nZS5mb2N1cywgdmFsdWUsIHR5cGVzKTtcbiAgZm9jdXNQYXRoICYmIHJhbmdlLmZvY3VzICYmIChmb2N1cyA9IHtcbiAgICBwYXRoOiBmb2N1c1BhdGgsXG4gICAgb2Zmc2V0OiByYW5nZS5mb2N1cy5vZmZzZXRcbiAgfSk7XG4gIGNvbnN0IGJhY2t3YXJkID0gISEoUmFuZ2UuaXNSYW5nZShyYW5nZSkgJiYgUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkpO1xuICByZXR1cm4gYW5jaG9yICYmIGZvY3VzID8geyBhbmNob3IsIGZvY3VzLCBiYWNrd2FyZCB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcikge1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhZWRpdG9yKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBhbmNob3IgPSB7XG4gICAgcGF0aDogY3JlYXRlQXJyYXllZFBhdGgoc2VsZWN0aW9uLmFuY2hvciwgZWRpdG9yKSxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0XG4gIH0sIGZvY3VzID0ge1xuICAgIHBhdGg6IGNyZWF0ZUFycmF5ZWRQYXRoKHNlbGVjdGlvbi5mb2N1cywgZWRpdG9yKSxcbiAgICBvZmZzZXQ6IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXRcbiAgfTtcbiAgcmV0dXJuIGZvY3VzLnBhdGgubGVuZ3RoID09PSAwIHx8IGFuY2hvci5wYXRoLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBhbmNob3IgJiYgZm9jdXMgPyB7IGFuY2hvciwgZm9jdXMgfSA6IG51bGw7XG59XG5mdW5jdGlvbiBtb3ZlUmFuZ2VCeU9wZXJhdGlvbihyYW5nZSwgb3BlcmF0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyYW5nZS5hbmNob3IsIG9wZXJhdGlvbiksIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmZvY3VzLCBvcGVyYXRpb24pO1xuICByZXR1cm4gYW5jaG9yID09PSBudWxsIHx8IGZvY3VzID09PSBudWxsID8gbnVsbCA6IFBvaW50LmVxdWFscyhhbmNob3IsIHJhbmdlLmFuY2hvcikgJiYgUG9pbnQuZXF1YWxzKGZvY3VzLCByYW5nZS5mb2N1cykgPyByYW5nZSA6IHsgYW5jaG9yLCBmb2N1cyB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHsgX2tleTogYmxvY2suX2tleSB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHsgX2tleTogY2hpbGQuX2tleSB9KSwgbmV3T2Zmc2V0ID0gY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCA+PSBwb2ludC5vZmZzZXQgPyBwb2ludC5vZmZzZXQgOiBjaGlsZC50ZXh0ICYmIGNoaWxkLnRleHQubGVuZ3RoIHx8IDA7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgcGF0aDogbmV3UGF0aCwgb2Zmc2V0OiBuZXdPZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24sIHZhbHVlKSB7XG4gIGlmICghc2VsZWN0aW9uIHx8ICF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuZXdBbmNob3IgPSBudWxsLCBuZXdGb2N1cyA9IG51bGw7XG4gIGNvbnN0IHsgYW5jaG9yLCBmb2N1cyB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7IF9rZXk6IGJsay5fa2V5IH0sIGFuY2hvci5wYXRoWzBdKSkgJiYgKG5ld0FuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGFuY2hvciwgdmFsdWUpKSwgZm9jdXMgJiYgdmFsdWUuZmluZCgoYmxrKSA9PiBpc0VxdWFsKHsgX2tleTogYmxrLl9rZXkgfSwgZm9jdXMucGF0aFswXSkpICYmIChuZXdGb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGZvY3VzLCB2YWx1ZSkpLCBuZXdBbmNob3IgJiYgbmV3Rm9jdXMgPyB7IGFuY2hvcjogbmV3QW5jaG9yLCBmb2N1czogbmV3Rm9jdXMsIGJhY2t3YXJkOiBzZWxlY3Rpb24uYmFja3dhcmQgfSA6IG51bGw7XG59XG5jb25zdCBFTVBUWV9NQVJLREVGUyA9IFtdLCBFTVBUWV9NQVJLUyQxID0gW10sIFZPSURfQ0hJTERfS0VZID0gXCJ2b2lkLWNoaWxkXCI7XG5mdW5jdGlvbiBrZWVwT2JqZWN0RXF1YWxpdHkob2JqZWN0LCBrZXlNYXApIHtcbiAgY29uc3QgdmFsdWUgPSBrZXlNYXBbb2JqZWN0Ll9rZXldO1xuICByZXR1cm4gdmFsdWUgJiYgaXNFcXVhbChvYmplY3QsIHZhbHVlKSA/IHZhbHVlIDogKGtleU1hcFtvYmplY3QuX2tleV0gPSBvYmplY3QsIG9iamVjdCk7XG59XG5mdW5jdGlvbiB0b1NsYXRlVmFsdWUodmFsdWUsIHsgc2NoZW1hVHlwZXMgfSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHsgX3R5cGUsIF9rZXksIC4uLnJlc3QgfSA9IGJsb2NrLCB2b2lkQ2hpbGRyZW4gPSBbeyBfa2V5OiBWT0lEX0NISUxEX0tFWSwgX3R5cGU6IFwic3BhblwiLCB0ZXh0OiBcIlwiLCBtYXJrczogW10gfV07XG4gICAgaWYgKGJsb2NrICYmIGJsb2NrLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibG9jaztcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBoYXNNaXNzaW5nU3R5bGUgPSB0eXBlb2YgdGV4dEJsb2NrLnN0eWxlID4gXCJ1XCIsIGhhc01pc3NpbmdNYXJrRGVmcyA9IHR5cGVvZiB0ZXh0QmxvY2subWFya0RlZnMgPiBcInVcIiwgaGFzTWlzc2luZ0NoaWxkcmVuID0gdHlwZW9mIHRleHRCbG9jay5jaGlsZHJlbiA+IFwidVwiLCBjaGlsZHJlbiA9ICh0ZXh0QmxvY2suY2hpbGRyZW4gfHwgW10pLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3QgeyBfdHlwZTogY1R5cGUsIF9rZXk6IGNLZXksIC4uLmNSZXN0IH0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIGNUeXBlICE9PSBcInNwYW5cIiA/IChoYXNJbmxpbmVzID0gITAsIGtlZXBPYmplY3RFcXVhbGl0eShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdHlwZTogY1R5cGUsXG4gICAgICAgICAgICBfa2V5OiBjS2V5LFxuICAgICAgICAgICAgY2hpbGRyZW46IHZvaWRDaGlsZHJlbixcbiAgICAgICAgICAgIHZhbHVlOiBjUmVzdCxcbiAgICAgICAgICAgIF9faW5saW5lOiAhMFxuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5TWFwXG4gICAgICAgICkpIDogY2hpbGQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhaGFzTWlzc2luZ1N0eWxlICYmICFoYXNNaXNzaW5nTWFya0RlZnMgJiYgIWhhc01pc3NpbmdDaGlsZHJlbiAmJiAhaGFzSW5saW5lcyAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSA/IGJsb2NrIDogKGhhc01pc3NpbmdTdHlsZSAmJiAocmVzdC5zdHlsZSA9IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSksIGtlZXBPYmplY3RFcXVhbGl0eSh7IF90eXBlLCBfa2V5LCAuLi5yZXN0LCBjaGlsZHJlbiB9LCBrZXlNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eShcbiAgICAgIHtcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIF9rZXksXG4gICAgICAgIGNoaWxkcmVuOiB2b2lkQ2hpbGRyZW4sXG4gICAgICAgIHZhbHVlOiByZXN0XG4gICAgICB9LFxuICAgICAga2V5TWFwXG4gICAgKTtcbiAgfSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGZyb21TbGF0ZVZhbHVlKHZhbHVlLCB0ZXh0QmxvY2tUeXBlLCBrZXlNYXAgPSB7fSkge1xuICByZXR1cm4gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHsgX2tleSwgX3R5cGUgfSA9IGJsb2NrO1xuICAgIGlmICghX2tleSB8fCAhX3R5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBibG9ja1wiKTtcbiAgICBpZiAoX3R5cGUgPT09IHRleHRCbG9ja1R5cGUgJiYgXCJjaGlsZHJlblwiIGluIGJsb2NrICYmIEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIF9rZXkpIHtcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3QgeyBfdHlwZTogX2NUeXBlIH0gPSBjaGlsZDtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBjaGlsZCAmJiBfY1R5cGUgIT09IFwic3BhblwiKSB7XG4gICAgICAgICAgaGFzSW5saW5lcyA9ICEwO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IHYsIF9rZXk6IGssIF90eXBlOiB0LCBfX2lubGluZTogX2ksIGNoaWxkcmVuOiBfYywgLi4ucmVzdCB9ID0gY2hpbGQ7XG4gICAgICAgICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7IC4uLnJlc3QsIC4uLnYsIF9rZXk6IGssIF90eXBlOiB0IH0sIGtleU1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGFzSW5saW5lcyA/IGtlZXBPYmplY3RFcXVhbGl0eSh7IC4uLmJsb2NrLCBjaGlsZHJlbiwgX2tleSwgX3R5cGUgfSwga2V5TWFwKSA6IGJsb2NrO1xuICAgIH1cbiAgICBjb25zdCBibG9ja1ZhbHVlID0gXCJ2YWx1ZVwiIGluIGJsb2NrICYmIGJsb2NrLnZhbHVlO1xuICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoXG4gICAgICB7IF9rZXksIF90eXBlLCAuLi50eXBlb2YgYmxvY2tWYWx1ZSA9PSBcIm9iamVjdFwiID8gYmxvY2tWYWx1ZSA6IHt9IH0sXG4gICAgICBrZXlNYXBcbiAgICApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxUb0VtcHR5RWRpdG9yKGNoaWxkcmVuLCBzY2hlbWFUeXBlcykge1xuICB2YXIgX2E7XG4gIHJldHVybiBjaGlsZHJlbiA9PT0gdm9pZCAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbiAmJiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblswXSkgJiYgY2hpbGRyZW5bMF0uX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUgJiYgXCJzdHlsZVwiIGluIGNoaWxkcmVuWzBdICYmIGNoaWxkcmVuWzBdLnN0eWxlID09PSBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUgJiYgIShcImxpc3RJdGVtXCIgaW4gY2hpbGRyZW5bMF0pICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW5bMF0uY2hpbGRyZW4pICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBUZXh0LmlzVGV4dChjaGlsZHJlblswXS5jaGlsZHJlblswXSkgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uX3R5cGUgPT09IFwic3BhblwiICYmICEoKF9hID0gY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0ubWFya3MpICE9IG51bGwgJiYgX2Euam9pbihcIlwiKSkgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIjtcbn1cbmNvbnN0IElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19TTEFURV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19WQUxVRV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgRGVmYXVsdE9iamVjdCA9IChwcm9wcykgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwicHJlXCIsIHsgY2hpbGRyZW46IEpTT04uc3RyaW5naWZ5KHByb3BzLnZhbHVlLCBudWxsLCAyKSB9KSB9KSwgRGVmYXVsdEJsb2NrT2JqZWN0ID0gc3R5bGVkLmRpdmBcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIGJvcmRlcjogJHsocHJvcHMpID0+IHByb3BzLnNlbGVjdGVkID8gXCIxcHggc29saWQgYmx1ZVwiIDogXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIn07XG5gO1xuc3R5bGVkLnNwYW5gXG4gIGJhY2tncm91bmQ6ICM5OTk7XG4gIGJvcmRlcjogJHsocHJvcHMpID0+IHByb3BzLnNlbGVjdGVkID8gXCIxcHggc29saWQgYmx1ZVwiIDogXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIn07XG5gO1xuY29uc3QgRGVmYXVsdExpc3RJdGVtID0gc3R5bGVkLmRpdmBcbiAgJi5wdC1saXN0LWl0ZW0ge1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogYmxvY2s7XG5cbiAgICAvKiBJbXBvcnRhbnQgJ3RyYW5zZm9ybScgaW4gb3JkZXIgdG8gZm9yY2UgcmVmcmVzaCB0aGUgOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgcnVsZXNcbiAgICAgIGluIFdlYmtpdDogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxOTQ3NjI4LzgzMTQ4MFxuICAgICovXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgIG1hcmdpbi1sZWZ0OiAkeyhwcm9wcykgPT4gZ2V0TGVmdFBvc2l0aW9uRm9yTGlzdExldmVsKHByb3BzLmxpc3RMZXZlbCl9O1xuICB9XG4gICYucHQtbGlzdC1pdGVtID4gLnB0LWxpc3QtaXRlbS1pbm5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICAmOmJlZm9yZSB7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xuICAgIH1cbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1idWxsZXQgPiAucHQtbGlzdC1pdGVtLWlubmVyOmJlZm9yZSB7XG4gICAgICBjb250ZW50OiAnJHsocHJvcHMpID0+IGdldENvbnRlbnRGb3JMaXN0TGV2ZWxBbmRTdHlsZShwcm9wcy5saXN0TGV2ZWwsIHByb3BzLmxpc3RTdHlsZSl9JztcbiAgICAgIGZvbnQtc2l6ZTogMC40Mzc1cmVtOyAvKiA3cHggKi9cbiAgICAgIGxpbmUtaGVpZ2h0OiAxLjVyZW07IC8qIFNhbWUgYXMgYm9keSB0ZXh0ICovXG4gICAgICAvKiBPcHRpY2FsIGFsaWdubWVudCAqL1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIH1cbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1idWxsZXQgPiAucHQtbGlzdC1pdGVtLWlubmVyIHtcbiAgICAmOmJlZm9yZSB7XG4gICAgICBtaW4td2lkdGg6IDEuNXJlbTsgLyogTWFrZSBzdXJlIHNwYWNlIGJldHdlZW4gYnVsbGV0IGFuZCB0ZXh0IG5ldmVyIHNocmlua3MgKi9cbiAgICB9XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0tbnVtYmVyIHtcbiAgICBjb3VudGVyLWluY3JlbWVudDogJHsocHJvcHMpID0+IGdldENvdW50ZXJJbmNyZW1lbnRGb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gICAgY291bnRlci1yZXNldDogJHsocHJvcHMpID0+IGdldENvdW50ZXJSZXNldEZvckxpc3RMZXZlbChwcm9wcy5saXN0TGV2ZWwpfTtcbiAgfVxuICAmICsgOm5vdCgucHQtbGlzdC1pdGVtLW51bWJlcikge1xuICAgIGNvdW50ZXItcmVzZXQ6IGxpc3RJdGVtTnVtYmVyO1xuICB9XG4gICYucHQtbGlzdC1pdGVtLW51bWJlciA+IC5wdC1saXN0LWl0ZW0taW5uZXI6YmVmb3JlIHtcbiAgICBjb250ZW50OiAkeyhwcm9wcykgPT4gZ2V0Q291bnRlckNvbnRlbnRGb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gICAgbWluLXdpZHRoOiAxLjVyZW07IC8qIE1ha2Ugc3VyZSBzcGFjZSBiZXR3ZWVuIG51bWJlciBhbmQgdGV4dCBuZXZlciBzaHJpbmtzICovXG4gICAgLyogT3B0aWNhbCBhbGlnbm1lbnQgKi9cbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdG9wOiAxcHg7XG4gIH1cbmAsIERlZmF1bHRMaXN0SXRlbUlubmVyID0gc3R5bGVkLmRpdmBgO1xuZnVuY3Rpb24gZ2V0TGVmdFBvc2l0aW9uRm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAoTnVtYmVyKGxldmVsKSkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcIjEuNWVtXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwiM2VtXCI7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFwiNC41ZW1cIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCI2ZW1cIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCI3LjVlbVwiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcIjllbVwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcIjEwLjVlbVwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcIjEyZW1cIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCIxMy41ZW1cIjtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIFwiMTVlbVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCIwZW1cIjtcbiAgfVxufVxuY29uc3QgYnVsbGV0cyA9IFtcIlxcdTI1Q0ZcIiwgXCJcXHUyNUNCXCIsIFwiXFx1MjVBMFwiXTtcbmZ1bmN0aW9uIGdldENvbnRlbnRGb3JMaXN0TGV2ZWxBbmRTdHlsZShsZXZlbCwgc3R5bGUpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExldmVsID0gKGxldmVsIC0gMSkgJSAzO1xuICByZXR1cm4gc3R5bGUgPT09IFwiYnVsbGV0XCIgPyBidWxsZXRzW25vcm1hbGl6ZWRMZXZlbF0gOiBcIipcIjtcbn1cbmZ1bmN0aW9uIGdldENvdW50ZXJJbmNyZW1lbnRGb3JMaXN0TGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1BbHBoYVwiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5cIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHRcIjtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUxldHRlck5leHRcIjtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dFwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHRcIjtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhTmV4dE5leHRcIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuTmV4dE5leHRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHRcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q291bnRlclJlc2V0Rm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hblwiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dFwiO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTGV0dGVyTmV4dFwiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0XCI7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dFwiO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtQWxwaGFOZXh0TmV4dFwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0TmV4dFwiO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dE5leHROZXh0XCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvdW50ZXJDb250ZW50Rm9yTGlzdExldmVsKGxldmVsKSB7XG4gIHN3aXRjaCAobGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyKSAnLiAnXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbUFscGhhLCBsb3dlci1hbHBoYSkgJy4gJ1wiO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1Sb21hbiwgbG93ZXItcm9tYW4pICcuICdcIjtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyTmV4dCkgJy4gJ1wiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1MZXR0ZXJOZXh0LCBsb3dlci1hbHBoYSkgJy4gJ1wiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1Sb21hbk5leHQsIGxvd2VyLXJvbWFuKSAnLiAnXCI7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbU51bWJlck5leHROZXh0KSAnLiAnXCI7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbUFscGhhTmV4dE5leHQsIGxvd2VyLWFscGhhKSAnLiAnXCI7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbVJvbWFuTmV4dE5leHQsIGxvd2VyLXJvbWFuKSAnLiAnXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHQpICcuICdcIjtcbiAgfVxufVxuY29uc3QgZGVidWckayA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkRyYWdnYWJsZUJsb2NrXCIpLCBEcmFnZ2FibGVCbG9jayA9ICh7IGNoaWxkcmVuLCBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYgfSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBkcmFnR2hvc3RSZWYgPSB1c2VSZWYoKSwgW2lzRHJhZ092ZXIsIHNldElzRHJhZ092ZXJdID0gdXNlU3RhdGUoITEpLCBpc1ZvaWQgPSB1c2VNZW1vKCgpID0+IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSwgW2VkaXRvciwgZWxlbWVudF0pLCBpc0lubGluZSA9IHVzZU1lbW8oKCkgPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgZWxlbWVudCksIFtlZGl0b3IsIGVsZW1lbnRdKSwgW2Jsb2NrRWxlbWVudCwgc2V0QmxvY2tFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICB1c2VFZmZlY3QoXG4gICAgKCkgPT4gc2V0QmxvY2tFbGVtZW50KGJsb2NrUmVmID8gYmxvY2tSZWYuY3VycmVudCA6IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVsZW1lbnQpKSxcbiAgICBbZWRpdG9yLCBlbGVtZW50LCBibG9ja1JlZl1cbiAgKTtcbiAgY29uc3QgaGFuZGxlRHJhZ092ZXIgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGlzTXlEcmFnT3ZlciA9IElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgICBpZiAoIWlzTXlEcmFnT3ZlciB8fCAhYmxvY2tFbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5zZXQoZWRpdG9yLCBlbGVtZW50KTtcbiAgICAgIGNvbnN0IGVsZW1lbnRSZWN0ID0gYmxvY2tFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBvZmZzZXQgPSBlbGVtZW50UmVjdC50b3AsIGhlaWdodCA9IGVsZW1lbnRSZWN0LmhlaWdodCwgWSA9IGV2ZW50LnBhZ2VZLCBsb2MgPSBNYXRoLmFicyhvZmZzZXQgLSBZKTtcbiAgICAgIGxldCBwb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgICBpZiAoZWxlbWVudCA9PT0gZWRpdG9yLmNoaWxkcmVuWzBdID8gcG9zaXRpb24gPSBcInRvcFwiIDogbG9jIDwgaGVpZ2h0IC8gMiA/IChwb3NpdGlvbiA9IFwidG9wXCIsIElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5zZXQoZWRpdG9yLCBwb3NpdGlvbikpIDogKHBvc2l0aW9uID0gXCJib3R0b21cIiwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLnNldChlZGl0b3IsIHBvc2l0aW9uKSksIGlzTXlEcmFnT3ZlciA9PT0gZWxlbWVudCkge1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibm9uZVwiO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJc0RyYWdPdmVyKCEwKTtcbiAgICB9LFxuICAgIFtibG9ja0VsZW1lbnQsIGVkaXRvciwgZWxlbWVudF1cbiAgKSwgaGFuZGxlRHJhZ0xlYXZlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzRHJhZ092ZXIoITEpO1xuICB9LCBbXSksIGhhbmRsZURyYWdFbmQgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldEJsb2NrID0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvcik7XG4gICAgICBpZiAodGFyZ2V0QmxvY2spIHtcbiAgICAgICAgSVNfRFJBR0dJTkcuc2V0KGVkaXRvciwgITEpLCBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZGVsZXRlKGVkaXRvciksIGRyYWdHaG9zdFJlZi5jdXJyZW50ICYmIChkZWJ1ZyRrKFwiUmVtb3ZpbmcgZHJhZyBnaG9zdFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkcmFnR2hvc3RSZWYuY3VycmVudCkpO1xuICAgICAgICBjb25zdCBkcmFnUG9zaXRpb24yID0gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmdldChlZGl0b3IpO1xuICAgICAgICBJU19EUkFHR0lOR19CTE9DS19UQVJHRVRfUE9TSVRJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIGxldCB0YXJnZXRQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCB0YXJnZXRCbG9jayk7XG4gICAgICAgIGNvbnN0IG15UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCksIGlzQmVmb3JlID0gUGF0aC5pc0JlZm9yZShteVBhdGgsIHRhcmdldFBhdGgpO1xuICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uMiA9PT0gXCJib3R0b21cIiAmJiAhaXNCZWZvcmUpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0UGF0aFswXSA+PSBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZGVidWckayhcInRhcmdldCBpcyBhbHJlYWR5IGF0IHRoZSBib3R0b20sIG5vdCBtb3ZpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IHRhcmdldFBhdGg7XG4gICAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgubmV4dCh0YXJnZXRQYXRoKSwgZGVidWckayhcbiAgICAgICAgICAgIGBBZGp1c3RpbmcgdGFyZ2V0UGF0aCBmcm9tICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWxQYXRoKX0gdG8gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgdGFyZ2V0UGF0aFxuICAgICAgICAgICAgKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uMiA9PT0gXCJ0b3BcIiAmJiBpc0JlZm9yZSAmJiB0YXJnZXRQYXRoWzBdICE9PSBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IHRhcmdldFBhdGg7XG4gICAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgucHJldmlvdXModGFyZ2V0UGF0aCksIGRlYnVnJGsoXG4gICAgICAgICAgICBgQWRqdXN0aW5nIHRhcmdldFBhdGggZnJvbSAke0pTT04uc3RyaW5naWZ5KG9yaWdpbmFsUGF0aCl9IHRvICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHRhcmdldFBhdGhcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFBhdGgsIG15UGF0aCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBkZWJ1ZyRrKFwidGFyZ2V0UGF0aCBhbmQgbXlQYXRoIGlzIHRoZSBzYW1lLCBub3QgbW92aW5nXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyRrKFxuICAgICAgICAgIGBNb3ZpbmcgZWxlbWVudCAke2VsZW1lbnQuX2tleX0gZnJvbSBwYXRoICR7SlNPTi5zdHJpbmdpZnkobXlQYXRoKX0gdG8gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHRhcmdldFBhdGhcbiAgICAgICAgICApfSAoJHtkcmFnUG9zaXRpb24yfSlgXG4gICAgICAgICksIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwgeyBhdDogbXlQYXRoLCB0bzogdGFyZ2V0UGF0aCB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnJGsoXCJObyB0YXJnZXQgZWxlbWVudCwgbm90IGRvaW5nIGFueXRoaW5nXCIpO1xuICAgIH0sXG4gICAgW2VkaXRvciwgZWxlbWVudF1cbiAgKSwgaGFuZGxlRHJvcCA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5nZXQoZWRpdG9yKSAmJiAoZGVidWckayhcIk9uIGRyb3AgKHByZXZlbnRlZClcIiwgZWxlbWVudCksIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCBzZXRJc0RyYWdPdmVyKCExKSk7XG4gICAgfSxcbiAgICBbZWRpdG9yLCBlbGVtZW50XVxuICApLCBoYW5kbGVEcmFnID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzVm9pZCkge1xuICAgICAgICBJU19EUkFHR0lOR19CTE9DS19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuc2V0KGVkaXRvciwgZWxlbWVudCksIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKHRhcmdldC5zdHlsZS5vcGFjaXR5ID0gXCIxXCIpO1xuICAgIH0sXG4gICAgW2VkaXRvciwgZWxlbWVudCwgaXNWb2lkXVxuICApLCBoYW5kbGVEcmFnU3RhcnQgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNWb2lkIHx8IGlzSW5saW5lKSB7XG4gICAgICAgIGRlYnVnJGsoXCJOb3QgZHJhZ2dpbmcgYmxvY2tcIiksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZGVsZXRlKGVkaXRvciksIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICExKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlYnVnJGsoXCJEcmFnIHN0YXJ0XCIpLCBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIGV2ZW50LmRhdGFUcmFuc2ZlciAmJiAoZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wb3J0YWJsZS10ZXh0XCIsIFwic29tZXRoaW5nXCIpLCBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibW92ZVwiKSwgYmxvY2tFbGVtZW50ICYmIGJsb2NrRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGxldCBkcmFnR2hvc3QgPSBibG9ja0VsZW1lbnQuY2xvbmVOb2RlKCEwKTtcbiAgICAgICAgY29uc3QgY3VzdG9tR2hvc3QgPSBkcmFnR2hvc3QucXVlcnlTZWxlY3RvcihcIltkYXRhLXB0LWRyYWctZ2hvc3QtZWxlbWVudF1cIik7XG4gICAgICAgIGlmIChjdXN0b21HaG9zdCAmJiAoZHJhZ0dob3N0ID0gY3VzdG9tR2hvc3QpLCBkcmFnR2hvc3Quc2V0QXR0cmlidXRlKFwiZGF0YS1kcmFnZ2VkXCIsIFwiXCIpLCBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZHJhZ0dob3N0UmVmLmN1cnJlbnQgPSBkcmFnR2hvc3QsIGRyYWdHaG9zdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIiwgZHJhZ0dob3N0LnN0eWxlLmxlZnQgPSBcIi05OTk5OXB4XCIsIGRyYWdHaG9zdC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIiwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnR2hvc3QpO1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSBibG9ja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0LCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICAgIGRyYWdHaG9zdC5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgLCBkcmFnR2hvc3Quc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgLCBldmVudC5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdHaG9zdCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZURyYWcoZXZlbnQpO1xuICAgIH0sXG4gICAgW2Jsb2NrRWxlbWVudCwgZWRpdG9yLCBoYW5kbGVEcmFnLCBpc0lubGluZSwgaXNWb2lkXVxuICApLCBpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgPSBpc0RyYWdPdmVyICYmIGVkaXRvci5jaGlsZHJlblswXSA9PT0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvciksIGlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrID0gaXNEcmFnT3ZlciAmJiBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5nZXQoZWRpdG9yKSwgZHJhZ1Bvc2l0aW9uID0gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmdldChlZGl0b3IpLCBpc0RyYWdnaW5nT3ZlclRvcCA9IGlzRHJhZ2dpbmdPdmVyRmlyc3RCbG9jayB8fCBpc0RyYWdPdmVyICYmICFpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgJiYgIWlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrICYmIGRyYWdQb3NpdGlvbiA9PT0gXCJ0b3BcIiwgaXNEcmFnZ2luZ092ZXJCb3R0b20gPSBpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayB8fCBpc0RyYWdPdmVyICYmICFpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgJiYgIWlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrICYmIGRyYWdQb3NpdGlvbiA9PT0gXCJib3R0b21cIiwgZHJvcEluZGljYXRvciA9IHVzZU1lbW8oXG4gICAgKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJwdC1kcm9wLWluZGljYXRvclwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIGN1cnJlbnRDb2xvclwiLFxuICAgICAgICAgIHpJbmRleDogNVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKSxcbiAgICBbXVxuICApO1xuICByZXR1cm4gcmVhZE9ubHkgPyAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuIH0pIDogLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBkcmFnZ2FibGU6IGlzVm9pZCxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBoYW5kbGVEcmFnU3RhcnQsXG4gICAgICBvbkRyYWc6IGhhbmRsZURyYWcsXG4gICAgICBvbkRyYWdPdmVyOiBoYW5kbGVEcmFnT3ZlcixcbiAgICAgIG9uRHJhZ0xlYXZlOiBoYW5kbGVEcmFnTGVhdmUsXG4gICAgICBvbkRyYWdFbmQ6IGhhbmRsZURyYWdFbmQsXG4gICAgICBvbkRyb3A6IGhhbmRsZURyb3AsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICBpc0RyYWdnaW5nT3ZlclRvcCAmJiBkcm9wSW5kaWNhdG9yLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaXNEcmFnZ2luZ092ZXJCb3R0b20gJiYgZHJvcEluZGljYXRvclxuICAgICAgXVxuICAgIH1cbiAgKTtcbn07XG5kZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpFbGVtZW50XCIpO1xuY29uc3QgRU1QVFlfQU5OT1RBVElPTlMgPSBbXSwgaW5saW5lQmxvY2tTdHlsZSA9IHsgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIiB9LCBFbGVtZW50ID0gKHtcbiAgYXR0cmlidXRlcyxcbiAgY2hpbGRyZW4sXG4gIGVsZW1lbnQsXG4gIHNjaGVtYVR5cGVzLFxuICByZWFkT25seSxcbiAgcmVuZGVyQmxvY2ssXG4gIHJlbmRlckNoaWxkLFxuICByZW5kZXJMaXN0SXRlbSxcbiAgcmVuZGVyU3R5bGUsXG4gIHNwZWxsQ2hlY2tcbn0pID0+IHtcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKSwgc2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBibG9ja1JlZiA9IHVzZVJlZihudWxsKSwgaW5saW5lQmxvY2tPYmplY3RSZWYgPSB1c2VSZWYobnVsbCksIGZvY3VzZWQgPSBzZWxlY3RlZCAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pIHx8ICExLCB2YWx1ZSA9IHVzZU1lbW8oXG4gICAgKCkgPT4gZnJvbVNsYXRlVmFsdWUoW2VsZW1lbnRdLCBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0sXG4gICAgW2VkaXRvciwgZWxlbWVudCwgc2NoZW1hVHlwZXMuYmxvY2submFtZV1cbiAgKTtcbiAgbGV0IHJlbmRlcmVkQmxvY2sgPSBjaGlsZHJlbiwgY2xhc3NOYW1lO1xuICBjb25zdCBibG9ja1BhdGggPSB1c2VNZW1vKCgpID0+IFt7IF9rZXk6IGVsZW1lbnQuX2tleSB9XSwgW2VsZW1lbnRdKTtcbiAgaWYgKHR5cGVvZiBlbGVtZW50Ll90eXBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBoYXZlIGEgX3R5cGUgcHJvcGVydHlcIik7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBoYXZlIGEgX2tleSBwcm9wZXJ0eVwiKTtcbiAgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgIGNvbnN0IHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpLCBbYmxvY2syXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwgeyBkZXB0aDogMSB9KSwgc2NoZW1hVHlwZTIgPSBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKF90eXBlKSA9PiBfdHlwZS5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgdHlwZSBmb3IgaW5saW5lIGJsb2NrIGVsZW1lbnRcIik7XG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2syKSkge1xuICAgICAgY29uc3QgZWxtUGF0aCA9IFt7IF9rZXk6IGJsb2NrMi5fa2V5IH0sIFwiY2hpbGRyZW5cIiwgeyBfa2V5OiBlbGVtZW50Ll9rZXkgfV07XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJzcGFuXCIsIHsgLi4uYXR0cmlidXRlcywgY2hpbGRyZW46IFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogIXJlYWRPbmx5LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcInB0LWlubGluZS1vYmplY3RcIixcbiAgICAgICAgICAgIFwiZGF0YS10ZXN0aWRcIjogXCJwdC1pbmxpbmUtb2JqZWN0XCIsXG4gICAgICAgICAgICByZWY6IGlubGluZUJsb2NrT2JqZWN0UmVmLFxuICAgICAgICAgICAgc3R5bGU6IGlubGluZUJsb2NrU3R5bGUsXG4gICAgICAgICAgICBjb250ZW50RWRpdGFibGU6ICExLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgcmVuZGVyQ2hpbGQgJiYgcmVuZGVyQ2hpbGQoe1xuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBFTVBUWV9BTk5PVEFUSU9OUyxcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBpbmxpbmUgb2JqZWN0cyBjdXJyZW50bHkgZG9lc24ndCBzdXBwb3J0IGFubm90YXRpb25zLiBUaGlzIGlzIGEgbGltaXRhdGlvbiBvZiB0aGUgY3VycmVudCBQVCBzcGVjL21vZGVsLlxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICAgICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogaW5saW5lQmxvY2tPYmplY3RSZWYsXG4gICAgICAgICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICAgICAgICBwYXRoOiBlbG1QYXRoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGUyLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgIHR5cGU6IHNjaGVtYVR5cGUyLFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAhcmVuZGVyQ2hpbGQgJiYgLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbGVtZW50Ll9rZXlcbiAgICAgICAgKVxuICAgICAgXSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgbm90IGZvdW5kIVwiKTtcbiAgfVxuICBpZiAoZWxlbWVudC5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSkge1xuICAgIGNsYXNzTmFtZSA9IFwicHQtYmxvY2sgcHQtdGV4dC1ibG9ja1wiO1xuICAgIGNvbnN0IGlzTGlzdEl0ZW0gPSBcImxpc3RJdGVtXCIgaW4gZWxlbWVudCwgc3R5bGUgPSBcInN0eWxlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnN0eWxlIHx8IFwibm9ybWFsXCI7XG4gICAgY2xhc3NOYW1lID0gYHB0LWJsb2NrIHB0LXRleHQtYmxvY2sgcHQtdGV4dC1ibG9jay1zdHlsZS0ke3N0eWxlfWA7XG4gICAgY29uc3QgYmxvY2tTdHlsZVR5cGUgPSBzY2hlbWFUeXBlcy5zdHlsZXMuZmluZCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gc3R5bGUpO1xuICAgIHJlbmRlclN0eWxlICYmIGJsb2NrU3R5bGVUeXBlICYmIChyZW5kZXJlZEJsb2NrID0gcmVuZGVyU3R5bGUoe1xuICAgICAgYmxvY2s6IGVsZW1lbnQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBzdHlsZSxcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHNjaGVtYVR5cGU6IGJsb2NrU3R5bGVUeXBlLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWZcbiAgICB9KSk7XG4gICAgbGV0IGxldmVsO1xuICAgIGlmIChpc0xpc3RJdGVtICYmICh0eXBlb2YgZWxlbWVudC5sZXZlbCA9PSBcIm51bWJlclwiICYmIChsZXZlbCA9IGVsZW1lbnQubGV2ZWwpLCBjbGFzc05hbWUgKz0gYCBwdC1saXN0LWl0ZW0gcHQtbGlzdC1pdGVtLSR7ZWxlbWVudC5saXN0SXRlbX0gcHQtbGlzdC1pdGVtLWxldmVsLSR7bGV2ZWwgfHwgMX1gKSwgZWRpdG9yLmlzTGlzdEJsb2NrKHZhbHVlKSAmJiBpc0xpc3RJdGVtICYmIGVsZW1lbnQubGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gc2NoZW1hVHlwZXMubGlzdHMuZmluZCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gZWxlbWVudC5saXN0SXRlbSk7XG4gICAgICByZW5kZXJMaXN0SXRlbSAmJiBsaXN0VHlwZSA/IHJlbmRlcmVkQmxvY2sgPSByZW5kZXJMaXN0SXRlbSh7XG4gICAgICAgIGJsb2NrOiB2YWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2ssXG4gICAgICAgIGZvY3VzZWQsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICB2YWx1ZTogZWxlbWVudC5saXN0SXRlbSxcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgICBzY2hlbWFUeXBlOiBsaXN0VHlwZSxcbiAgICAgICAgbGV2ZWw6IHZhbHVlLmxldmVsIHx8IDEsXG4gICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmXG4gICAgICB9KSA6IHJlbmRlcmVkQmxvY2sgPSAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICBEZWZhdWx0TGlzdEl0ZW0sXG4gICAgICAgIHtcbiAgICAgICAgICBsaXN0U3R5bGU6IHZhbHVlLmxpc3RJdGVtIHx8IHNjaGVtYVR5cGVzLmxpc3RzWzBdLnZhbHVlLFxuICAgICAgICAgIGxpc3RMZXZlbDogdmFsdWUubGV2ZWwgfHwgMSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0TGlzdEl0ZW1Jbm5lciwgeyBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayB9KVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2ssXG4gICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgICBmb2N1c2VkLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgbGlzdEl0ZW06IGlzTGlzdEl0ZW0gPyBlbGVtZW50Lmxpc3RJdGVtIDogdm9pZCAwLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuYmxvY2ssXG4gICAgICAgIHZhbHVlXG4gICAgICB9LFxuICAgICAgXCJ0eXBlXCIsXG4gICAgICB7XG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlcy5ibG9jaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksIHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgPSByZW5kZXJCbG9jayA/IHJlbmRlckJsb2NrKHJlbmRlclByb3BzKSA6IGNoaWxkcmVuO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgLi4uYXR0cmlidXRlcywgY2xhc3NOYW1lLCBzcGVsbENoZWNrLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY2hpbGRyZW46IHByb3BzT3JEZWZhdWx0UmVuZGVyZWQgfSkgfSkgfSwgZWxlbWVudC5fa2V5KTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLmZpbmQoKF90eXBlKSA9PiBfdHlwZS5uYW1lID09PSBlbGVtZW50Ll90eXBlKTtcbiAgaWYgKCFzY2hlbWFUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc2NoZW1hIHR5cGUgZm9yIGJsb2NrIGVsZW1lbnQgb2YgX3R5cGUgJHtlbGVtZW50Ll90eXBlfWApO1xuICBjbGFzc05hbWUgPSBcInB0LWJsb2NrIHB0LW9iamVjdC1ibG9ja1wiO1xuICBjb25zdCBibG9jayA9IGZyb21TbGF0ZVZhbHVlKFxuICAgIFtlbGVtZW50XSxcbiAgICBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLFxuICAgIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpXG4gIClbMF07XG4gIGxldCByZW5kZXJlZEJsb2NrRnJvbVByb3BzO1xuICBpZiAocmVuZGVyQmxvY2spIHtcbiAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmLFxuICAgICAgICBmb2N1c2VkLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICAgIHNjaGVtYVR5cGUsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICB2YWx1ZTogYmxvY2tcbiAgICAgIH0sXG4gICAgICBcInR5cGVcIixcbiAgICAgIHtcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgPSByZW5kZXJCbG9jayhfcHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNsYXNzTmFtZSwgY2hpbGRyZW46IFtcbiAgICBjaGlsZHJlbixcbiAgICAvKiBAX19QVVJFX18gKi8ganN4cyhEcmFnZ2FibGVCbG9jaywgeyBlbGVtZW50LCByZWFkT25seSwgYmxvY2tSZWYsIGNoaWxkcmVuOiBbXG4gICAgICByZW5kZXJlZEJsb2NrRnJvbVByb3BzICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IGJsb2NrUmVmLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyB9KSxcbiAgICAgICFyZW5kZXJlZEJsb2NrRnJvbVByb3BzICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdEJsb2NrT2JqZWN0LCB7IHNlbGVjdGVkLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0T2JqZWN0LCB7IHZhbHVlIH0pIH0pXG4gICAgXSB9KVxuICBdIH0sIGVsZW1lbnQuX2tleSk7XG59LCBQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yID0gKCkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQpO1xuICBpZiAoIWVkaXRvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCJcbiAgICApO1xuICByZXR1cm4gZWRpdG9yO1xufTtcbmZ1bmN0aW9uIERlZmF1bHRBbm5vdGF0aW9uKHByb3BzKSB7XG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4gYWxlcnQoSlNPTi5zdHJpbmdpZnkocHJvcHMuYW5ub3RhdGlvbikpLCBbcHJvcHMuYW5ub3RhdGlvbl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBzdHlsZTogeyBjb2xvcjogXCJibHVlXCIgfSwgb25DbGljazogaGFuZGxlQ2xpY2ssIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKHBvcnRhYmxlVGV4dFR5cGUpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGlmICghcG9ydGFibGVUZXh0VHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgJ3BvcnRhYmxldGV4dFR5cGUnIG1pc3NpbmcgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgYmxvY2tUeXBlID0gKF9hID0gcG9ydGFibGVUZXh0VHlwZS5vZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbmQoZmluZEJsb2NrVHlwZSk7XG4gIGlmICghYmxvY2tUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIHR5cGUgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgY2hpbGRyZW5GaWVsZCA9IChfYiA9IGJsb2NrVHlwZS5maWVsZHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5maW5kKChmaWVsZCkgPT4gZmllbGQubmFtZSA9PT0gXCJjaGlsZHJlblwiKTtcbiAgaWYgKCFjaGlsZHJlbkZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNoaWxkcmVuIGZpZWxkIGZvciBibG9jayB0eXBlIGZvdW5kIGluIHNjaGVtYSAocmVxdWlyZWQpXCIpO1xuICBjb25zdCBvZlR5cGUgPSBjaGlsZHJlbkZpZWxkLnR5cGUub2Y7XG4gIGlmICghb2ZUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkIHR5cGVzIGZvciBibG9jayBjaGlsZHJlbiBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IHNwYW5UeXBlID0gb2ZUeXBlLmZpbmQoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUubmFtZSA9PT0gXCJzcGFuXCIpO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNwYW4gdHlwZSBub3QgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcigobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lICE9PSBcInNwYW5cIikgfHwgW10sIGJsb2NrT2JqZWN0VHlwZXMgPSAoKF9jID0gcG9ydGFibGVUZXh0VHlwZS5vZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgIT09IGJsb2NrVHlwZS5uYW1lKSkgfHwgW107XG4gIHJldHVybiB7XG4gICAgc3R5bGVzOiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpLFxuICAgIGRlY29yYXRvcnM6IHJlc29sdmVFbmFibGVkRGVjb3JhdG9ycyhzcGFuVHlwZSksXG4gICAgbGlzdHM6IHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSksXG4gICAgYmxvY2s6IGJsb2NrVHlwZSxcbiAgICBzcGFuOiBzcGFuVHlwZSxcbiAgICBwb3J0YWJsZVRleHQ6IHBvcnRhYmxlVGV4dFR5cGUsXG4gICAgaW5saW5lT2JqZWN0czogaW5saW5lT2JqZWN0VHlwZXMsXG4gICAgYmxvY2tPYmplY3RzOiBibG9ja09iamVjdFR5cGVzLFxuICAgIGFubm90YXRpb25zOiBzcGFuVHlwZS5hbm5vdGF0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBzdHlsZUZpZWxkID0gKF9hID0gYmxvY2tUeXBlLmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJzdHlsZVwiKTtcbiAgaWYgKCFzdHlsZUZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZmllbGQgd2l0aCBuYW1lICdzdHlsZScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IHRleHRTdHlsZXMgPSAoKF9iID0gc3R5bGVGaWVsZC50eXBlLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5saXN0KSAmJiAoKF9jID0gc3R5bGVGaWVsZC50eXBlLm9wdGlvbnMubGlzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmZpbHRlcigoc3R5bGUpID0+IHN0eWxlLnZhbHVlKSk7XG4gIGlmICghdGV4dFN0eWxlcyB8fCB0ZXh0U3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBzdHlsZSBmaWVsZHMgbmVlZCBhdCBsZWFzdCBvbmUgc3R5bGUgZGVmaW5lZC4gSS5lOiB7dGl0bGU6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCd9LlwiXG4gICAgKTtcbiAgcmV0dXJuIHRleHRTdHlsZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpIHtcbiAgcmV0dXJuIHNwYW5UeXBlLmRlY29yYXRvcnM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZExpc3RJdGVtcyhibG9ja1R5cGUpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgbGlzdEZpZWxkID0gKF9hID0gYmxvY2tUeXBlLmZpZWxkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJsaXN0SXRlbVwiKTtcbiAgaWYgKCFsaXN0RmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmaWVsZCB3aXRoIG5hbWUgJ2xpc3RJdGVtJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3QgbGlzdEl0ZW1zID0gKChfYiA9IGxpc3RGaWVsZC50eXBlLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5saXN0KSAmJiBsaXN0RmllbGQudHlwZS5vcHRpb25zLmxpc3QuZmlsdGVyKChsaXN0KSA9PiBsaXN0LnZhbHVlKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGZpbmRCbG9ja1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID8gZmluZEJsb2NrVHlwZSh0eXBlLnR5cGUpIDogdHlwZS5uYW1lID09PSBcImJsb2NrXCIgPyB0eXBlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlKHJhd1R5cGUpIHtcbiAgcmV0dXJuIFNjaGVtYS5jb21waWxlKHtcbiAgICBuYW1lOiBcImJsb2NrVHlwZVNjaGVtYVwiLFxuICAgIHR5cGVzOiBbcmF3VHlwZV1cbiAgfSkuZ2V0KHJhd1R5cGUubmFtZSk7XG59XG5jb25zdCBkZWJ1ZyRqID0gZGVidWdXaXRoTmFtZShcIm9wZXJhdGlvblRvUGF0Y2hlc1wiKTtcbmRlYnVnJGouZW5hYmxlZCA9ICExO1xuZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHR5cGVzKSB7XG4gIGNvbnN0IHRleHRCbG9ja05hbWUgPSB0eXBlcy5ibG9jay5uYW1lO1xuICBmdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgZGVidWckai5lbmFibGVkICYmIGRlYnVnJGooXCJPcGVyYXRpb25cIiwgSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLCBudWxsLCAyKSk7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbeyBfa2V5OiBibG9jay5fa2V5IH0sIFwiY2hpbGRyZW5cIiwgeyBfa2V5OiB0ZXh0Q2hpbGQuX2tleSB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKHByZXZCbG9jaykgJiYgcHJldkJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2Q2hpbGQpID8gcHJldkNoaWxkLnRleHQgOiBcIlwiLCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUubGVuZ3RoID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvciAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCBjaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIHx8IHZvaWQgMCwgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpID8gY2hpbGQgOiB2b2lkIDA7XG4gICAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzcGFuXCIpO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7IF9rZXk6IGJsb2NrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IHRleHRDaGlsZC5fa2V5IH0sIFwidGV4dFwiXSwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZUZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9jayB0byBoYXZlIGEgX2tleVwiKTtcbiAgICAgIGNvbnN0IHNldE5vZGUgPSBvbWl0QnkoXG4gICAgICAgIHsgLi4uZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSwgLi4ub3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMgfSxcbiAgICAgICAgaXNVbmRlZmluZWRcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3NldChmcm9tU2xhdGVWYWx1ZShbc2V0Tm9kZV0sIHRleHRCbG9ja05hbWUpWzBdLCBbeyBfa2V5OiBibG9jay5fa2V5IH1dKV07XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBjb25zdCBibG9ja0tleSA9IGJsb2NrLl9rZXksIGNoaWxkS2V5ID0gY2hpbGQuX2tleSwgcGF0Y2hlcyA9IFtdLCBrZXlzID0gT2JqZWN0LmtleXMob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgICAgIHJldHVybiBrZXlzLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlOYW1lID09PSBcIl9rZXlcIikge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goXG4gICAgICAgICAgICAgICAgc2V0KHZhbCwgW3sgX2tleTogYmxvY2tLZXkgfSwgXCJjaGlsZHJlblwiLCBibG9jay5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSwga2V5TmFtZV0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3sgX2tleTogYmxvY2tLZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IGNoaWxkS2V5IH0sIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHBhdGNoZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSB2YWxpZCBjaGlsZFwiKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgYmxvY2tcIik7XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcGF0aCBlbmNvdW50ZXJlZDogJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24ucGF0aCl9YCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IGJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF1dLCBpc1RleHRCbG9jayA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jayk7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBvcGVyYXRpb24ucGF0aFswXSA9PT0gMCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIsIGJlZm9yZUJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLnBhdGhbMF0gLSAxXSwgdGFyZ2V0S2V5ID0gb3BlcmF0aW9uLnBhdGhbMF0gPT09IDAgPyBibG9jayA9PSBudWxsID8gdm9pZCAwIDogYmxvY2suX2tleSA6IGJlZm9yZUJsb2NrID09IG51bGwgPyB2b2lkIDAgOiBiZWZvcmVCbG9jay5fa2V5O1xuICAgICAgcmV0dXJuIHRhcmdldEtleSA/IFtcbiAgICAgICAgaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbb3BlcmF0aW9uLm5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbXG4gICAgICAgICAgeyBfa2V5OiB0YXJnZXRLZXkgfVxuICAgICAgICBdKVxuICAgICAgXSA6IFtcbiAgICAgICAgc2V0SWZNaXNzaW5nKGJlZm9yZVZhbHVlLCBbXSksXG4gICAgICAgIGluc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBcImJlZm9yZVwiLCBbXG4gICAgICAgICAgb3BlcmF0aW9uLnBhdGhbMF1cbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgfSBlbHNlIGlmIChpc1RleHRCbG9jayAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLCBub2RlID0geyAuLi5vcGVyYXRpb24ubm9kZSB9O1xuICAgICAgIW5vZGUuX3R5cGUgJiYgVGV4dC5pc1RleHQobm9kZSkgJiYgKG5vZGUuX3R5cGUgPSBcInNwYW5cIiwgbm9kZS5tYXJrcyA9IFtdKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gZnJvbVNsYXRlVmFsdWUoXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfa2V5OiBcImJvZ3VzXCIsXG4gICAgICAgICAgICBfdHlwZTogdGV4dEJsb2NrTmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHRleHRCbG9ja05hbWVcbiAgICAgIClbMF0uY2hpbGRyZW5bMF07XG4gICAgICByZXR1cm4gW1xuICAgICAgICBpbnNlcnQoW2NoaWxkXSwgcG9zaXRpb24sIFtcbiAgICAgICAgICB7IF9rZXk6IGJsb2NrLl9rZXkgfSxcbiAgICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgICAgYmxvY2suY2hpbGRyZW4ubGVuZ3RoIDw9IDEgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyAwIDogeyBfa2V5OiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdLl9rZXkgfVxuICAgICAgICBdKVxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlYnVnJGooXCJTb21ldGhpbmcgd2FzIGluc2VydGVkIGludG8gYSB2b2lkIGJsb2NrLiBOb3QgcHJvZHVjaW5nIGVkaXRvciBwYXRjaGVzLlwiKSwgW107XG4gIH1cbiAgZnVuY3Rpb24gc3BsaXROb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBzcGxpdEJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWVkaXRvci5pc1RleHRCbG9jayhzcGxpdEJsb2NrKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJsb2NrIHdpdGggcGF0aCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIG9wZXJhdGlvbi5wYXRoWzBdXG4gICAgICAgICl9IGlzIG5vdCBhIHRleHQgYmxvY2sgYW5kIGNhbid0IGJlIHNwbGl0YFxuICAgICAgKTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBvbGRCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sob2xkQmxvY2spKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZnJvbVNsYXRlVmFsdWUoXG4gICAgICAgICAgW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSArIDFdXSxcbiAgICAgICAgICB0ZXh0QmxvY2tOYW1lXG4gICAgICAgIClbMF07XG4gICAgICAgIHRhcmdldFZhbHVlICYmIChwYXRjaGVzLnB1c2goaW5zZXJ0KFt0YXJnZXRWYWx1ZV0sIFwiYWZ0ZXJcIiwgW3sgX2tleTogc3BsaXRCbG9jay5fa2V5IH1dKSksIG9sZEJsb2NrLmNoaWxkcmVuLnNsaWNlKG9wZXJhdGlvbi5wb3NpdGlvbikuZm9yRWFjaCgoc3BhbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSBbeyBfa2V5OiBvbGRCbG9jay5fa2V5IH0sIFwiY2hpbGRyZW5cIiwgeyBfa2V5OiBzcGFuLl9rZXkgfV07XG4gICAgICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KHBhdGgpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNwbGl0U3BhbiA9IHNwbGl0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKHNwbGl0U3BhbikpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhbnMgPSBmcm9tU2xhdGVWYWx1ZShcbiAgICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLnNwbGl0QmxvY2ssXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBzcGxpdEJsb2NrLmNoaWxkcmVuLnNsaWNlKG9wZXJhdGlvbi5wYXRoWzFdICsgMSwgb3BlcmF0aW9uLnBhdGhbMV0gKyAyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgdGV4dEJsb2NrTmFtZVxuICAgICAgICApWzBdLmNoaWxkcmVuO1xuICAgICAgICBwYXRjaGVzLnB1c2goXG4gICAgICAgICAgaW5zZXJ0KHRhcmdldFNwYW5zLCBcImFmdGVyXCIsIFtcbiAgICAgICAgICAgIHsgX2tleTogc3BsaXRCbG9jay5fa2V5IH0sXG4gICAgICAgICAgICBcImNoaWxkcmVuXCIsXG4gICAgICAgICAgICB7IF9rZXk6IHNwbGl0U3Bhbi5fa2V5IH1cbiAgICAgICAgICBdKVxuICAgICAgICApLCBwYXRjaGVzLnB1c2goXG4gICAgICAgICAgc2V0KHNwbGl0U3Bhbi50ZXh0LCBbXG4gICAgICAgICAgICB7IF9rZXk6IHNwbGl0QmxvY2suX2tleSB9LFxuICAgICAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICAgICAgeyBfa2V5OiBzcGxpdFNwYW4uX2tleSB9LFxuICAgICAgICAgICAgXCJ0ZXh0XCJcbiAgICAgICAgICBdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgYmxvY2suX2tleSlcbiAgICAgICAgcmV0dXJuIFt1bnNldChbeyBfa2V5OiBibG9jay5fa2V5IH1dKV07XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmRcIik7XG4gICAgfSBlbHNlIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BhblRvUmVtb3ZlID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbiAmJiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICByZXR1cm4gc3BhblRvUmVtb3ZlID8gW3Vuc2V0KFt7IF9rZXk6IGJsb2NrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IHNwYW5Ub1JlbW92ZS5fa2V5IH1dKV0gOiAoZGVidWckaihcIlNwYW4gbm90IGZvdW5kIGluIGVkaXRvciB0cnlpbmcgdG8gcmVtb3ZlIG5vZGVcIiksIFtdKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBkZWJ1ZyRqKFwiTm90IGNyZWF0aW5nIHBhdGNoIGluc2lkZSBvYmplY3QgYmxvY2tcIiksIFtdO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHRhcmdldEJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgaWYgKGJsb2NrICE9IG51bGwgJiYgYmxvY2suX2tleSkge1xuICAgICAgICBjb25zdCBuZXdCbG9jayA9IGZyb21TbGF0ZVZhbHVlKFtlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gLSAxXV0sIHRleHRCbG9ja05hbWUpWzBdO1xuICAgICAgICBwYXRjaGVzLnB1c2goc2V0KG5ld0Jsb2NrLCBbeyBfa2V5OiBuZXdCbG9jay5fa2V5IH1dKSksIHBhdGNoZXMucHVzaCh1bnNldChbeyBfa2V5OiBibG9jay5fa2V5IH1dKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGtleSBub3QgZm91bmQhXCIpO1xuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICBjb25zdCBtZXJnZWRTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0gfHwgdm9pZCAwLCB0YXJnZXRTcGFuID0gdGFyZ2V0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXTtcbiAgICAgIGVkaXRvci5pc1RleHRTcGFuKHRhcmdldFNwYW4pICYmIChwYXRjaGVzLnB1c2goXG4gICAgICAgIHNldCh0YXJnZXRTcGFuLnRleHQsIFt7IF9rZXk6IGJsb2NrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IHRhcmdldFNwYW4uX2tleSB9LCBcInRleHRcIl0pXG4gICAgICApLCBtZXJnZWRTcGFuICYmIHBhdGNoZXMucHVzaCh1bnNldChbeyBfa2V5OiBibG9jay5fa2V5IH0sIFwiY2hpbGRyZW5cIiwgeyBfa2V5OiBtZXJnZWRTcGFuLl9rZXkgfV0pKSk7XG4gICAgfSBlbHNlXG4gICAgICBkZWJ1ZyRqKFwiVm9pZCBub2RlcyBjYW4ndCBiZSBtZXJnZWQsIG5vdCBjcmVhdGluZyBhbnkgcGF0Y2hlc1wiKTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBmdW5jdGlvbiBtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBiZWZvcmVWYWx1ZSkge1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXSwgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHRhcmdldEJsb2NrID0gYmVmb3JlVmFsdWVbb3BlcmF0aW9uLm5ld1BhdGhbMF1dO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlcmF0aW9uLnBhdGhbMF0gPiBvcGVyYXRpb24ubmV3UGF0aFswXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gICAgICBwYXRjaGVzLnB1c2godW5zZXQoW3sgX2tleTogYmxvY2suX2tleSB9XSkpLCBwYXRjaGVzLnB1c2goXG4gICAgICAgIGluc2VydChbZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3sgX2tleTogdGFyZ2V0QmxvY2suX2tleSB9XSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgdGFyZ2V0Q2hpbGQgPSB0YXJnZXRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ubmV3UGF0aFsxXV0sIHBvc2l0aW9uID0gb3BlcmF0aW9uLm5ld1BhdGhbMV0gPT09IHRhcmdldEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIsIGNoaWxkVG9JbnNlcnQgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0ZXh0QmxvY2tOYW1lKVswXS5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICBwYXRjaGVzLnB1c2godW5zZXQoW3sgX2tleTogYmxvY2suX2tleSB9LCBcImNoaWxkcmVuXCIsIHsgX2tleTogY2hpbGQuX2tleSB9XSkpLCBwYXRjaGVzLnB1c2goXG4gICAgICAgIGluc2VydChbY2hpbGRUb0luc2VydF0sIHBvc2l0aW9uLCBbXG4gICAgICAgICAgeyBfa2V5OiB0YXJnZXRCbG9jay5fa2V5IH0sXG4gICAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICAgIHsgX2tleTogdGFyZ2V0Q2hpbGQuX2tleSB9XG4gICAgICAgIF0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4ge1xuICAgIGluc2VydE5vZGVQYXRjaCxcbiAgICBpbnNlcnRUZXh0UGF0Y2gsXG4gICAgbWVyZ2VOb2RlUGF0Y2gsXG4gICAgbW92ZU5vZGVQYXRjaCxcbiAgICByZW1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlVGV4dFBhdGNoLFxuICAgIHNldE5vZGVQYXRjaCxcbiAgICBzcGxpdE5vZGVQYXRjaFxuICB9O1xufVxuY29uc3QgZGVidWckaSA9IGRlYnVnV2l0aE5hbWUoXCJBUEk6ZWRpdGFibGVcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoRWRpdGFibGVBUEkocG9ydGFibGVUZXh0RWRpdG9yLCB0eXBlcywga2V5R2VuZXJhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gcG9ydGFibGVUZXh0RWRpdG9yLnNldEVkaXRhYmxlKHtcbiAgICAgIGZvY3VzOiAoKSA9PiB7XG4gICAgICAgIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcik7XG4gICAgICB9LFxuICAgICAgYmx1cjogKCkgPT4ge1xuICAgICAgICBSZWFjdEVkaXRvci5ibHVyKGVkaXRvcik7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTWFyazogKG1hcmspID0+IHtcbiAgICAgICAgZWRpdG9yLnB0ZVRvZ2dsZU1hcmsobWFyayk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTGlzdDogKGxpc3RTdHlsZSkgPT4ge1xuICAgICAgICBlZGl0b3IucHRlVG9nZ2xlTGlzdEl0ZW0obGlzdFN0eWxlKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVCbG9ja1N0eWxlOiAoYmxvY2tTdHlsZSkgPT4ge1xuICAgICAgICBlZGl0b3IucHRlVG9nZ2xlQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgICAgIH0sXG4gICAgICBpc01hcmtBY3RpdmU6IChtYXJrKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5wdGVJc01hcmtBY3RpdmUobWFyayk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oZXJyKSwgITE7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtYXJrczogKCkgPT4gKHtcbiAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgIH0pLm1hcmtzIHx8IFtdLFxuICAgICAgdW5kbzogKCkgPT4gZWRpdG9yLnVuZG8oKSxcbiAgICAgIHJlZG86ICgpID0+IGVkaXRvci5yZWRvKCksXG4gICAgICBzZWxlY3Q6IChzZWxlY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3Qgc2xhdGVTZWxlY3Rpb24gPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgICBzbGF0ZVNlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2xhdGVTZWxlY3Rpb24pIDogVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBmb2N1c0Jsb2NrOiAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgYmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1c0NoaWxkOiAoKSA9PiB7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgYmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICAgIGlmIChibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21TbGF0ZVZhbHVlKFxuICAgICAgICAgICAgICBbYmxvY2tdLFxuICAgICAgICAgICAgICB0eXBlcy5ibG9jay5uYW1lLFxuICAgICAgICAgICAgICBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKVxuICAgICAgICAgICAgKVswXS5jaGlsZHJlbltlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5zZXJ0Q2hpbGQ6ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZWRpdG9yIGhhcyBubyBzZWxlY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IEFycmF5LmZyb20oXG4gICAgICAgICAgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gbi5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIClbMF0gfHwgW3ZvaWQgMF07XG4gICAgICAgIGlmICghZm9jdXNCbG9jaylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmb2N1c2VkIHRleHQgYmxvY2tcIik7XG4gICAgICAgIGlmICh0eXBlLm5hbWUgIT09IHR5cGVzLnNwYW4ubmFtZSAmJiAhdHlwZXMuaW5saW5lT2JqZWN0cy5zb21lKCh0KSA9PiB0Lm5hbWUgPT09IHR5cGUubmFtZSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0eXBlIGNhbm5vdCBiZSBpbnNlcnRlZCBhcyBhIGNoaWxkIHRvIGEgdGV4dCBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0b1NsYXRlVmFsdWUoXG4gICAgICAgICAgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICBfdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgLi4udmFsdWUgfHwge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHBvcnRhYmxlVGV4dEVkaXRvclxuICAgICAgICApWzBdLmNoaWxkcmVuWzBdLCBmb2N1c0NoaWxkUGF0aCA9IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAyKSwgaXNTcGFuTm9kZSA9IGNoaWxkLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWUsIGZvY3VzTm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgZm9jdXNDaGlsZFBhdGgpO1xuICAgICAgICByZXR1cm4gaXNTcGFuTm9kZSAmJiBmb2N1c05vZGUuX3R5cGUgIT09IHR5cGVzLnNwYW4ubmFtZSAmJiAoZGVidWckaShcIkluc2VydGluZyBzcGFuIGNoaWxkIG5leHQgdG8gaW5saW5lIG9iamVjdCBjaGlsZCwgbW92aW5nIHNlbGVjdGlvbiArIDFcIiksIGVkaXRvci5tb3ZlKHsgZGlzdGFuY2U6IDEsIHVuaXQ6IFwiY2hhcmFjdGVyXCIgfSkpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGQsIHtcbiAgICAgICAgICBzZWxlY3Q6ICEwLFxuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgKChfYSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoXG4gICAgICAgICAgZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksXG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICB0eXBlc1xuICAgICAgICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMucGF0aCkgfHwgW107XG4gICAgICB9LFxuICAgICAgaW5zZXJ0QmxvY2s6ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZWRpdG9yIGhhcyBubyBzZWxlY3Rpb25cIik7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgIF90eXBlOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIC4uLnZhbHVlIHx8IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBwb3J0YWJsZVRleHRFZGl0b3JcbiAgICAgICAgKVswXSwgW2ZvY3VzQmxvY2tdID0gQXJyYXkuZnJvbShcbiAgICAgICAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBuLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lXG4gICAgICAgICAgfSlcbiAgICAgICAgKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgICAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgaXNFcXVhbFRvRW1wdHlFZGl0b3IoW2ZvY3VzQmxvY2tdLCB0eXBlcykgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IGVkaXRvci5zZWxlY3Rpb24gfSksIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgYmxvY2spLCBlZGl0b3Iub25DaGFuZ2UoKSwgKChfYSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoXG4gICAgICAgICAgZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksXG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICB0eXBlc1xuICAgICAgICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMucGF0aCkgfHwgW107XG4gICAgICB9LFxuICAgICAgaGFzQmxvY2tTdHlsZTogKHN0eWxlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5wdGVIYXNCbG9ja1N0eWxlKHN0eWxlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzTGlzdFN0eWxlOiAobGlzdFN0eWxlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5wdGVIYXNMaXN0U3R5bGUobGlzdFN0eWxlKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaXNWb2lkOiAoZWxlbWVudCkgPT4gIVt0eXBlcy5ibG9jay5uYW1lLCB0eXBlcy5zcGFuLm5hbWVdLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpLFxuICAgICAgZmluZEJ5UGF0aDogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3Qgc2xhdGVQYXRoID0gdG9TbGF0ZVJhbmdlKFxuICAgICAgICAgIHsgZm9jdXM6IHsgcGF0aCwgb2Zmc2V0OiAwIH0sIGFuY2hvcjogeyBwYXRoLCBvZmZzZXQ6IDAgfSB9LFxuICAgICAgICAgIGVkaXRvclxuICAgICAgICApO1xuICAgICAgICBpZiAoc2xhdGVQYXRoKSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzbGF0ZVBhdGguZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgaWYgKGJsb2NrICYmIGJsb2NrUGF0aCAmJiB0eXBlb2YgYmxvY2suX2tleSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgc2xhdGVQYXRoLmZvY3VzLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gW2Zyb21TbGF0ZVZhbHVlKFtibG9ja10sIHR5cGVzLmJsb2NrLm5hbWUpWzBdLCBbeyBfa2V5OiBibG9jay5fa2V5IH1dXTtcbiAgICAgICAgICAgIGNvbnN0IHB0QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShcbiAgICAgICAgICAgICAgW2Jsb2NrXSxcbiAgICAgICAgICAgICAgdHlwZXMuYmxvY2submFtZSxcbiAgICAgICAgICAgICAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcilcbiAgICAgICAgICAgIClbMF07XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHB0QmxvY2spKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHB0Q2hpbGQgPSBwdEJsb2NrLmNoaWxkcmVuW3NsYXRlUGF0aC5mb2N1cy5wYXRoWzFdXTtcbiAgICAgICAgICAgICAgaWYgKHB0Q2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwdENoaWxkLCBbeyBfa2V5OiBibG9jay5fa2V5IH0sIFwiY2hpbGRyZW5cIiwgeyBfa2V5OiBwdENoaWxkLl9rZXkgfV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgIH0sXG4gICAgICBmaW5kRE9NTm9kZTogKGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgW2l0ZW1dID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IFtdLFxuICAgICAgICAgICAgICBtYXRjaDogKG4pID0+IG4uX2tleSA9PT0gZWxlbWVudC5fa2V5XG4gICAgICAgICAgICB9KSB8fCBbXVxuICAgICAgICAgIClbMF0gfHwgW3ZvaWQgMF07XG4gICAgICAgICAgbm9kZSA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGl0ZW0pO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0sXG4gICAgICBhY3RpdmVBbm5vdGF0aW9uczogKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlQW5ub3RhdGlvbnMgPSBbXSwgc3BhbnMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gVGV4dC5pc1RleHQobm9kZSkgJiYgbm9kZS5tYXJrcyAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5sZW5ndGggPiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChjb25zdCBbc3BhbiwgcGF0aF0gb2Ygc3BhbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHsgZGVwdGg6IDEgfSk7XG4gICAgICAgICAgICBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmICgoX2EgPSBibG9jay5tYXJrRGVmcykgPT0gbnVsbCB8fCBfYS5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgVGV4dC5pc1RleHQoc3BhbikgJiYgc3Bhbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpICYmIHNwYW4ubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpICYmIGFjdGl2ZUFubm90YXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZUFubm90YXRpb25zO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0Fubm90YXRpb25BY3RpdmU6IChhbm5vdGF0aW9uVHlwZSkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLmxlbmd0aCA8IDIpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNwYW5zID0gW1xuICAgICAgICAgICAgLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBUZXh0LmlzVGV4dChub2RlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdO1xuICAgICAgICAgIGlmIChzcGFucy5zb21lKFxuICAgICAgICAgICAgKFtzcGFuXSkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgIHJldHVybiAhaXNQb3J0YWJsZVRleHRTcGFuKHNwYW4pIHx8ICFzcGFuLm1hcmtzIHx8ICgoX2EgPSBzcGFuLm1hcmtzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbk1hcmtEZWZzID0gc3BhbnMucmVkdWNlKChhY2NNYXJrRGVmcywgWywgcGF0aF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHsgZGVwdGg6IDEgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5tYXJrRGVmcyA/IFsuLi5hY2NNYXJrRGVmcywgLi4uYmxvY2subWFya0RlZnNdIDogYWNjTWFya0RlZnM7XG4gICAgICAgICAgfSwgW10pO1xuICAgICAgICAgIHJldHVybiBzcGFucy5ldmVyeSgoW3NwYW5dKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgY29uc3Qgc3Bhbk1hcmtEZWZzID0gKF9hID0gc3Bhbi5tYXJrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcChcbiAgICAgICAgICAgICAgKG1hcmtLZXkpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2EyID0gc2VsZWN0aW9uTWFya0RlZnMuZmluZCgoZGVmKSA9PiAoZGVmID09IG51bGwgPyB2b2lkIDAgOiBkZWYuX2tleSkgPT09IG1hcmtLZXkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLl90eXBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHNwYW5NYXJrRGVmcyA9PSBudWxsID8gdm9pZCAwIDogc3Bhbk1hcmtEZWZzLmluY2x1ZGVzKGFubm90YXRpb25UeXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWRkQW5ub3RhdGlvbjogKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uOiBvcmlnaW5hbFNlbGVjdGlvbiB9ID0gZWRpdG9yO1xuICAgICAgICBsZXQgcmV0dXJuVmFsdWU7XG4gICAgICAgIGlmIChvcmlnaW5hbFNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIG9yaWdpbmFsU2VsZWN0aW9uLmZvY3VzLCB7IGRlcHRoOiAxIH0pO1xuICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBSYW5nZS5pc0NvbGxhcHNlZChvcmlnaW5hbFNlbGVjdGlvbikgJiYgKGVkaXRvci5wdGVFeHBhbmRUb1dvcmQoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICAgIGNvbnN0IFt0ZXh0Tm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIG9yaWdpbmFsU2VsZWN0aW9uLmZvY3VzLCB7IGRlcHRoOiAyIH0pO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24gJiYgKEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9uS2V5ID0ga2V5R2VuZXJhdG9yKCk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrRGVmczogW1xuICAgICAgICAgICAgICAgICAgLi4uYmxvY2subWFya0RlZnMgfHwgW10sXG4gICAgICAgICAgICAgICAgICB7IF90eXBlOiB0eXBlLm5hbWUsIF9rZXk6IGFubm90YXRpb25LZXksIC4uLnZhbHVlIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHsgYXQ6IG9yaWdpbmFsU2VsZWN0aW9uLmZvY3VzIH1cbiAgICAgICAgICAgICksIGVkaXRvci5vbkNoYW5nZSgpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHsgbWF0Y2g6IFRleHQuaXNUZXh0LCBzcGxpdDogITAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBlZGl0b3Iuc2VsZWN0aW9uICYmIFRleHQuaXNUZXh0KHRleHROb2RlKSAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrczogWy4uLnRleHROb2RlLm1hcmtzIHx8IFtdLCBhbm5vdGF0aW9uS2V5XVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBuLl90eXBlID09PSB0eXBlcy5zcGFuLm5hbWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSwgZWRpdG9yLm9uQ2hhbmdlKCksIGVkaXRvci5zZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBbeyBfdHlwZTogXCJzcGFuXCIsIHRleHQ6IFwiXCIsIG1hcmtzOiBbXSwgX2tleToga2V5R2VuZXJhdG9yKCkgfV0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdDogUmFuZ2UuZW5kKGVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBuZXdQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb24gPSB0b1BvcnRhYmxlVGV4dFJhbmdlKFxuICAgICAgICAgICAgICBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgdHlwZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBuZXdQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb24gJiYgKHJldHVyblZhbHVlID0ge1xuICAgICAgICAgICAgICBzcGFuUGF0aDogbmV3UG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uLmZvY3VzLnBhdGgsXG4gICAgICAgICAgICAgIG1hcmtEZWZQYXRoOiBbeyBfa2V5OiBibG9jay5fa2V5IH0sIFwibWFya0RlZnNcIiwgeyBfa2V5OiBhbm5vdGF0aW9uS2V5IH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSwgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogKHNlbGVjdGlvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgICAgIGlmICghKHJhbmdlICYmIHJhbmdlLmFuY2hvci5wYXRoLmxlbmd0aCA+IDAgJiYgcmFuZ2UuZm9jdXMucGF0aC5sZW5ndGggPiAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmFuZ2VcIik7XG4gICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5tb2RlKSB8fCAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tb2RlKSA9PT0gXCJzZWxlY3RlZFwiKSB7XG4gICAgICAgICAgICAgIGRlYnVnJGkoXCJEZWxldGluZyBjb250ZW50IGluIHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICAgIGhhbmdpbmc6ICEwLFxuICAgICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpID09PSBcImJsb2Nrc1wiICYmIChkZWJ1ZyRpKFwiRGVsZXRpbmcgYmxvY2tzIHRvdWNoZWQgYnkgc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgfHwgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgICB9KSksIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGUpID09PSBcImNoaWxkcmVuXCIgJiYgKGRlYnVnJGkoXCJEZWxldGluZyBjaGlsZHJlbiB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICB2b2lkczogITAsXG4gICAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lIHx8IC8vIFRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICAgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgICB9KSksIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgKGVkaXRvci5jaGlsZHJlbiA9IFtlZGl0b3IucHRlQ3JlYXRlRW1wdHlCbG9jaygpXSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUFubm90YXRpb246ICh0eXBlKSA9PiB7XG4gICAgICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoZGVidWckaShcIlJlbW92aW5nIGFubm90YXRpb25cIiwgdHlwZSksIHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBjb25zdCBbbm9kZSwgbm9kZVBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHsgZGVwdGg6IDIgfSk7XG4gICAgICAgICAgICBUZXh0LmlzVGV4dChub2RlKSAmJiBub2RlLm1hcmtzICYmIHR5cGVvZiBub2RlLnRleHQgPT0gXCJzdHJpbmdcIiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBub2RlUGF0aCksIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24sICFzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgYXQ6IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIEFycmF5LmlzQXJyYXkobm9kZS5tYXJrRGVmcykgJiYgbm9kZS5tYXJrRGVmcy5zb21lKChkZWYpID0+IGRlZi5fdHlwZSA9PT0gdHlwZS5uYW1lKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF0uZm9yRWFjaCgoW2Jsb2NrXSkgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgQXJyYXkuaXNBcnJheShibG9jay5tYXJrRGVmcykgJiYgYmxvY2subWFya0RlZnMuZmlsdGVyKChkZWYpID0+IGRlZi5fdHlwZSA9PT0gdHlwZS5uYW1lKS5mb3JFYWNoKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgICAgIEVkaXRvci5yZW1vdmVNYXJrKGVkaXRvciwgZGVmLl9rZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFNlbGVjdGlvbjogKCkgPT4ge1xuICAgICAgICBsZXQgcHRSYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgcHRSYW5nZSA9IHRvUG9ydGFibGVUZXh0UmFuZ2UoXG4gICAgICAgICAgICBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgICB0eXBlc1xuICAgICAgICAgICksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0Uuc2V0KGVkaXRvci5zZWxlY3Rpb24sIHB0UmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdFJhbmdlO1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSxcbiAgICAgIGlzQ29sbGFwc2VkU2VsZWN0aW9uOiAoKSA9PiAhIWVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgICBpc0V4cGFuZGVkU2VsZWN0aW9uOiAoKSA9PiAhIWVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSxcbiAgICAgIGluc2VydEJyZWFrOiAoKSA9PiB7XG4gICAgICAgIGVkaXRvci5pbnNlcnRCcmVhaygpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBnZXRGcmFnbWVudDogKCkgPT4gZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmdldEZyYWdtZW50KCksIHR5cGVzLmJsb2NrLm5hbWUpLFxuICAgICAgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmc6IChzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmdlQSA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb25BLCBlZGl0b3IpLCByYW5nZUIgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uQiwgZWRpdG9yKTtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmlzUmFuZ2UocmFuZ2VBKSAmJiBSYW5nZS5pc1JhbmdlKHJhbmdlQikgJiYgUmFuZ2UuaW5jbHVkZXMocmFuZ2VBLCByYW5nZUIpO1xuICAgICAgfVxuICAgIH0pLCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXaXRoSW5zZXJ0QnJlYWsodHlwZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHsgaW5zZXJ0QnJlYWsgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmluc2VydEJyZWFrID0gKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykpIHtcbiAgICAgICAgICBjb25zdCBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoZWRpdG9yLnNlbGVjdGlvbiksIGlzRW5kQXRTdGFydE9mTm9kZSA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgZW5kLCBlbmQucGF0aCksIGlzRW1wdHlUZXh0QmxvY2sgPSBmb2N1c0Jsb2NrICYmIGlzRXF1YWxUb0VtcHR5RWRpdG9yKFtmb2N1c0Jsb2NrXSwgdHlwZXMpO1xuICAgICAgICAgIGlmIChpc0VuZEF0U3RhcnRPZk5vZGUgJiYgIWlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZUVtcHR5QmxvY2soKSk7XG4gICAgICAgICAgICBjb25zdCBbbmV4dEJsb2NrUGF0aF0gPSBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGFuY2hvcjogeyBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sIG9mZnNldDogMCB9LFxuICAgICAgICAgICAgICBmb2N1czogeyBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sIG9mZnNldDogMCB9XG4gICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnNlcnRCcmVhaygpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhNYXhCbG9ja3MobWF4QmxvY2tzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7IGFwcGx5OiBhcHBseTIgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wZXJhdGlvbikgPT4ge1xuICAgICAgY29uc3Qgcm93cyA9IG1heEJsb2NrcztcbiAgICAgIHJvd3MgPiAwICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPj0gcm93cyAmJiAob3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X25vZGVcIiB8fCBvcGVyYXRpb24udHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIpICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSB8fCBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBQUkVTRVJWRV9LRVlTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoUHJlc2VydmVLZXlzKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUHJlc2VydmluZ0tleXMoZWRpdG9yKTtcbiAgUFJFU0VSVkVfS0VZUy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIFBSRVNFUlZFX0tFWVMuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1ByZXNlcnZpbmdLZXlzKGVkaXRvcikge1xuICByZXR1cm4gUFJFU0VSVkVfS0VZUy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhPYmplY3RLZXlzKHNjaGVtYVR5cGVzLCBrZXlHZW5lcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIFBSRVNFUlZFX0tFWVMuc2V0KGVkaXRvciwgITEpO1xuICAgIGNvbnN0IHsgYXBwbHk6IGFwcGx5Miwgbm9ybWFsaXplTm9kZSB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHdpdGhOZXdLZXkgPSAhaXNQcmVzZXJ2aW5nS2V5cyhlZGl0b3IpIHx8ICEoXCJfa2V5XCIgaW4gb3BlcmF0aW9uLnByb3BlcnRpZXMpO1xuICAgICAgICBvcGVyYXRpb24ucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24ucHJvcGVydGllcyxcbiAgICAgICAgICAuLi53aXRoTmV3S2V5ID8geyBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9IDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHdpdGhOZXdLZXkgPSAhaXNQcmVzZXJ2aW5nS2V5cyhlZGl0b3IpIHx8ICEoXCJfa2V5XCIgaW4gb3BlcmF0aW9uLm5vZGUpO1xuICAgICAgICBFZGl0b3IuaXNFZGl0b3Iob3BlcmF0aW9uLm5vZGUpIHx8IChvcGVyYXRpb24ubm9kZSA9IHtcbiAgICAgICAgICAuLi5vcGVyYXRpb24ubm9kZSxcbiAgICAgICAgICAuLi53aXRoTmV3S2V5ID8geyBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICB9LCBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChlbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBub2RlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICAgIG5vZGUuX2tleSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9LCB7IGF0OiBwYXRoIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgaWYgKCFjaGlsZC5fa2V5KSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9LCB7IGF0OiBjaGlsZFBhdGggfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gaXNIaWdoU3Vycm9nYXRlKGNoYXIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjaGFyQ29kZSA+PSA1NTI5NiAmJiBjaGFyQ29kZSA8PSA1NjMxOTtcbn1cbmZ1bmN0aW9uIGlzTG93U3Vycm9nYXRlKGNoYXIpIHtcbiAgY29uc3QgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjaGFyQ29kZSA+PSA1NjMyMCAmJiBjaGFyQ29kZSA8PSA1NzM0Mztcbn1cbmZ1bmN0aW9uIGNsb25lRGlmZihkaWZmMikge1xuICBjb25zdCBbdHlwZSwgcGF0Y2hdID0gZGlmZjI7XG4gIHJldHVybiBbdHlwZSwgcGF0Y2hdO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uT3ZlcmxhcCh0ZXh0QSwgdGV4dEIpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICB0ZXh0MUxlbmd0aCA+IHRleHQyTGVuZ3RoID8gdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCkgOiB0ZXh0MUxlbmd0aCA8IHRleHQyTGVuZ3RoICYmICh0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MUxlbmd0aCkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gTWF0aC5taW4odGV4dDFMZW5ndGgsIHRleHQyTGVuZ3RoKTtcbiAgaWYgKHRleHQxID09PSB0ZXh0MilcbiAgICByZXR1cm4gdGV4dExlbmd0aDtcbiAgbGV0IGJlc3QgPSAwLCBsZW5ndGggPSAxO1xuICBmb3IgKGxldCBmb3VuZCA9IDA7IGZvdW5kICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBpZiAoZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pLCBmb3VuZCA9PT0gLTEpXG4gICAgICByZXR1cm4gYmVzdDtcbiAgICBsZW5ndGggKz0gZm91bmQsIChmb3VuZCA9PT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dExlbmd0aCAtIGxlbmd0aCkgPT09IHRleHQyLnN1YnN0cmluZygwLCBsZW5ndGgpKSAmJiAoYmVzdCA9IGxlbmd0aCwgbGVuZ3RoKyspO1xuICB9XG4gIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MVswXSAhPT0gdGV4dDJbMF0pXG4gICAgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJTdGFydCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlclN0YXJ0ID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxW3RleHQxLmxlbmd0aCAtIDFdICE9PSB0ZXh0Mlt0ZXh0Mi5sZW5ndGggLSAxXSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlckVuZCA9IDA7XG4gIGZvciAoOyBwb2ludGVyTWluIDwgcG9pbnRlck1pZDsgKVxuICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVyTWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyRW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJFbmQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyRW5kID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWMocmF3RGlmZnMpIHtcbiAgbGV0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksIGhhc0NoYW5nZXMgPSAhMTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIHBvaW50ZXIgPSAwLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMxID0gbGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUID8gbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDogbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGgsIGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICBmb3IgKGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpLCBwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV0sIG92ZXJsYXBMZW5ndGgxID0gZ2V0Q29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKSwgb3ZlcmxhcExlbmd0aDIgPSBnZXRDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgb3ZlcmxhcExlbmd0aDEgPj0gb3ZlcmxhcExlbmd0aDIgPyAob3ZlcmxhcExlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKSwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSksIHBvaW50ZXIrKykgOiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVCwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDIpLCBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgyKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXggPSAvW15hLXpBLVowLTldLywgd2hpdGVzcGFjZVJlZ2V4ID0gL1xccy8sIGxpbmVicmVha1JlZ2V4ID0gL1tcXHJcXG5dLywgYmxhbmtsaW5lRW5kUmVnZXggPSAvXFxuXFxyP1xcbiQvLCBibGFua2xpbmVTdGFydFJlZ2V4ID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhyYXdEaWZmcykge1xuICBjb25zdCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKVxuICAgICAgcmV0dXJuIDY7XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKSwgY2hhcjIgPSB0d28uY2hhckF0KDApLCBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2gobm9uQWxwaGFOdW1lcmljUmVnZXgpLCB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiYgY2hhcjEubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmIGNoYXIyLm1hdGNoKHdoaXRlc3BhY2VSZWdleCksIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJiBjaGFyMS5tYXRjaChsaW5lYnJlYWtSZWdleCksIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJiBjaGFyMi5tYXRjaChsaW5lYnJlYWtSZWdleCksIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmIG9uZS5tYXRjaChibGFua2xpbmVFbmRSZWdleCksIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmIHR3by5tYXRjaChibGFua2xpbmVTdGFydFJlZ2V4KTtcbiAgICByZXR1cm4gYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyID8gNSA6IGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMiA/IDQgOiBub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMiA/IDMgOiB3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMiA/IDIgOiBub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIgPyAxIDogMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV0sIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXSwgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgY29uc3QgY29tbW9uT2Zmc2V0ID0gZ2V0Q29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KSwgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MiwgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIGZvciAoOyBlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKTsgKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKSwgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKSwgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBzY29yZSA+PSBiZXN0U2NvcmUgJiYgKGJlc3RTY29yZSA9IHNjb3JlLCBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxLCBiZXN0RWRpdCA9IGVkaXQsIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTIpO1xuICAgICAgfVxuICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9PSBiZXN0RXF1YWxpdHkxICYmIChiZXN0RXF1YWxpdHkxID8gZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MSA6IChkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBwb2ludGVyLS0pLCBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0LCBiZXN0RXF1YWxpdHkyID8gZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MiA6IChkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBwb2ludGVyLS0pKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGNsZWFudXBNZXJnZShyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKTtcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCIsIGNvbW1vbmxlbmd0aDtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7IClcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXSwgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgY291bnREZWxldGUgKyBjb3VudEluc2VydCA+IDEgPyAoY291bnREZWxldGUgIT09IDAgJiYgY291bnRJbnNlcnQgIT09IDAgJiYgKGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0SW5zZXJ0LCB0ZXh0RGVsZXRlKSwgY29tbW9ubGVuZ3RoICE9PSAwICYmIChwb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IGRpZmZzW3BvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0IC0gMV1bMV0gKz0gdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKSA6IChkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsIHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dEluc2VydC5zdWJzdHJpbmcodGV4dEluc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV0sIHRleHRJbnNlcnQgPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCksIHRleHREZWxldGUgPSB0ZXh0RGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0RGVsZXRlLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkpKSwgcG9pbnRlciAtPSBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0LCBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnREZWxldGUgKyBjb3VudEluc2VydCksIHRleHREZWxldGUubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfREVMRVRFLCB0ZXh0RGVsZXRlXSksIHBvaW50ZXIrKyksIHRleHRJbnNlcnQubGVuZ3RoICYmIChkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgW0RJRkZfSU5TRVJULCB0ZXh0SW5zZXJ0XSksIHBvaW50ZXIrKyksIHBvaW50ZXIrKykgOiBwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKSkgOiBwb2ludGVyKyssIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvblwiKTtcbiAgICB9XG4gIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiICYmIGRpZmZzLnBvcCgpO1xuICBsZXQgaGFzQ2hhbmdlcyA9ICExO1xuICBmb3IgKHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKVxuICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdID8gKGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkgOiBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSAmJiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgKyBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIHRydWVDb3VudCgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKVxuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIHJldHVybiBhcmdzLnJlZHVjZSgobiwgYm9vbCkgPT4gbiArIChib29sID8gMSA6IDApLCAwKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBFZmZpY2llbmN5KHJhd0RpZmZzKSB7XG4gIGxldCBlZGl0Q29zdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogNCwgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIHByZUlucyA9ICExLCBwcmVEZWwgPSAhMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApXG4gICAgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZWRpdENvc3QgJiYgKHBvc3RJbnMgfHwgcG9zdERlbCkgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgcHJlSW5zID0gcG9zdElucywgcHJlRGVsID0gcG9zdERlbCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsKSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSA/IHBvc3REZWwgPSAhMCA6IHBvc3RJbnMgPSAhMCwgbGFzdEVxdWFsaXR5ICYmIChwcmVJbnMgJiYgcHJlRGVsICYmIHBvc3RJbnMgJiYgcG9zdERlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZWRpdENvc3QgLyAyICYmIHRydWVDb3VudChwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbCkgPT09IDMpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwcmVJbnMgJiYgcHJlRGVsID8gKHBvc3RJbnMgPSAhMCwgcG9zdERlbCA9ICEwLCBlcXVhbGl0aWVzTGVuZ3RoID0gMCkgOiAoZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGJpc2VjdCh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aCwgbWF4RCA9IE1hdGguY2VpbCgodGV4dDFMZW5ndGggKyB0ZXh0Mkxlbmd0aCkgLyAyKSwgdk9mZnNldCA9IG1heEQsIHZMZW5ndGggPSAyICogbWF4RCwgdjEgPSBuZXcgQXJyYXkodkxlbmd0aCksIHYyID0gbmV3IEFycmF5KHZMZW5ndGgpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHZMZW5ndGg7IHgrKylcbiAgICB2MVt4XSA9IC0xLCB2Mlt4XSA9IC0xO1xuICB2MVt2T2Zmc2V0ICsgMV0gPSAwLCB2Mlt2T2Zmc2V0ICsgMV0gPSAwO1xuICBjb25zdCBkZWx0YSA9IHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgsIGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDAsIGsxZW5kID0gMCwgazJzdGFydCA9IDAsIGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhEICYmICEoRGF0ZS5ub3coKSA+IGRlYWRsaW5lKTsgZCsrKSB7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgazE7XG4gICAgICBsZXQgeDE7XG4gICAgICBrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFPZmZzZXQgLSAxXSA8IHYxW2sxT2Zmc2V0ICsgMV0gPyB4MSA9IHYxW2sxT2Zmc2V0ICsgMV0gOiB4MSA9IHYxW2sxT2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkxID0geDEgLSBrMTtcbiAgICAgIGZvciAoOyB4MSA8IHRleHQxTGVuZ3RoICYmIHkxIDwgdGV4dDJMZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKTsgKVxuICAgICAgICB4MSsrLCB5MSsrO1xuICAgICAgaWYgKHYxW2sxT2Zmc2V0XSA9IHgxLCB4MSA+IHRleHQxTGVuZ3RoKVxuICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgZWxzZSBpZiAoeTEgPiB0ZXh0Mkxlbmd0aClcbiAgICAgICAgazFzdGFydCArPSAyO1xuICAgICAgZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyT2Zmc2V0ID49IDAgJiYgazJPZmZzZXQgPCB2TGVuZ3RoICYmIHYyW2syT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxTGVuZ3RoIC0gdjJbazJPZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4MilcbiAgICAgICAgICAgIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIGNvbnN0IGsyT2Zmc2V0ID0gdk9mZnNldCArIGsyO1xuICAgICAgbGV0IHgyO1xuICAgICAgazIgPT09IC1kIHx8IGsyICE9PSBkICYmIHYyW2syT2Zmc2V0IC0gMV0gPCB2MltrMk9mZnNldCArIDFdID8geDIgPSB2MltrMk9mZnNldCArIDFdIDogeDIgPSB2MltrMk9mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MiA9IHgyIC0gazI7XG4gICAgICBmb3IgKDsgeDIgPCB0ZXh0MUxlbmd0aCAmJiB5MiA8IHRleHQyTGVuZ3RoICYmIHRleHQxLmNoYXJBdCh0ZXh0MUxlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Mkxlbmd0aCAtIHkyIC0gMSk7IClcbiAgICAgICAgeDIrKywgeTIrKztcbiAgICAgIGlmICh2MltrMk9mZnNldF0gPSB4MiwgeDIgPiB0ZXh0MUxlbmd0aClcbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKHkyID4gdGV4dDJMZW5ndGgpXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKCFmcm9udCkge1xuICAgICAgICBjb25zdCBrMU9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICBpZiAoazFPZmZzZXQgPj0gMCAmJiBrMU9mZnNldCA8IHZMZW5ndGggJiYgdjFbazFPZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgxID0gdjFbazFPZmZzZXRdLCB5MSA9IHZPZmZzZXQgKyB4MSAtIGsxT2Zmc2V0O1xuICAgICAgICAgIGlmICh4MiA9IHRleHQxTGVuZ3RoIC0geDIsIHgxID49IHgyKVxuICAgICAgICAgICAgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufVxuZnVuY3Rpb24gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4LCB5LCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KSwgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpLCB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSksIGRpZmZzID0gZG9EaWZmKHRleHQxYSwgdGV4dDJhLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmVcbiAgfSksIGRpZmZzYiA9IGRvRGlmZih0ZXh0MWIsIHRleHQyYiwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mikge1xuICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogMSkgPD0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbG9uZ1RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydFRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBpZiAobG9uZ1RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydFRleHQubGVuZ3RoICogMiA8IGxvbmdUZXh0Lmxlbmd0aClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaGFsZk1hdGNoMSA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDQpKSwgaGFsZk1hdGNoMiA9IGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgTWF0aC5jZWlsKGxvbmdUZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhhbGZNYXRjaDtcbiAgaWYgKGhhbGZNYXRjaDEgJiYgaGFsZk1hdGNoMilcbiAgICBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxWzRdLmxlbmd0aCA+IGhhbGZNYXRjaDJbNF0ubGVuZ3RoID8gaGFsZk1hdGNoMSA6IGhhbGZNYXRjaDI7XG4gIGVsc2Uge1xuICAgIGlmICghaGFsZk1hdGNoMSAmJiAhaGFsZk1hdGNoMilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGhhbGZNYXRjaDIgPyBoYWxmTWF0Y2gxIHx8IChoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gyKSA6IGhhbGZNYXRjaCA9IGhhbGZNYXRjaDE7XG4gIH1cbiAgaWYgKCFoYWxmTWF0Y2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBoYWxmIG1hdGNoLlwiKTtcbiAgbGV0IHRleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQjtcbiAgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gKHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSkgOiAodGV4dDJBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbMV0sIHRleHQxQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDFCID0gaGFsZk1hdGNoWzNdKTtcbiAgY29uc3QgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdO1xuICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcbn1cbmZ1bmN0aW9uIGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgaSkge1xuICBjb25zdCBzZWVkID0gbG9uZ1RleHQuc2xpY2UoaSwgaSArIE1hdGguZmxvb3IobG9uZ1RleHQubGVuZ3RoIC8gNCkpO1xuICBsZXQgaiA9IC0xLCBiZXN0Q29tbW9uID0gXCJcIiwgYmVzdExvbmdUZXh0QSwgYmVzdExvbmdUZXh0QiwgYmVzdFNob3J0VGV4dEEsIGJlc3RTaG9ydFRleHRCO1xuICBmb3IgKDsgKGogPSBzaG9ydFRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KGxvbmdUZXh0LnNsaWNlKGkpLCBzaG9ydFRleHQuc2xpY2UoaikpLCBzdWZmaXhMZW5ndGggPSBnZXRDb21tb25TdWZmaXgobG9uZ1RleHQuc2xpY2UoMCwgaSksIHNob3J0VGV4dC5zbGljZSgwLCBqKSk7XG4gICAgYmVzdENvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGggJiYgKGJlc3RDb21tb24gPSBzaG9ydFRleHQuc2xpY2UoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydFRleHQuc2xpY2UoaiwgaiArIHByZWZpeExlbmd0aCksIGJlc3RMb25nVGV4dEEgPSBsb25nVGV4dC5zbGljZSgwLCBpIC0gc3VmZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QiA9IGxvbmdUZXh0LnNsaWNlKGkgKyBwcmVmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QSA9IHNob3J0VGV4dC5zbGljZSgwLCBqIC0gc3VmZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEIgPSBzaG9ydFRleHQuc2xpY2UoaiArIHByZWZpeExlbmd0aCkpO1xuICB9XG4gIHJldHVybiBiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ1RleHQubGVuZ3RoID8gW2Jlc3RMb25nVGV4dEEgfHwgXCJcIiwgYmVzdExvbmdUZXh0QiB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QSB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QiB8fCBcIlwiLCBiZXN0Q29tbW9uIHx8IFwiXCJdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjaGFycyA9IGRpZmZzW3hdWzFdLCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKylcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmVzVG9DaGFycyh0ZXh0QSwgdGV4dEIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW10sIGxpbmVIYXNoID0ge307XG4gIGxpbmVBcnJheVswXSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGRpZmZMaW5lc1RvTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCIsIGxpbmVTdGFydCA9IDAsIGxpbmVFbmQgPSAtMSwgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDsgbGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMTsgKSB7XG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKGBcbmAsIGxpbmVTdGFydCksIGxpbmVFbmQgPT09IC0xICYmIChsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkgPyBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKSA6IChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzICYmIChsaW5lID0gdGV4dC5zbGljZShsaW5lU3RhcnQpLCBsaW5lRW5kID0gdGV4dC5sZW5ndGgpLCBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCksIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoLCBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZSksIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH1cbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb011bmdlKHRleHRBKTtcbiAgbWF4TGluZXMgPSA2NTUzNTtcbiAgY29uc3QgY2hhcnMyID0gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0Qik7XG4gIHJldHVybiB7XG4gICAgY2hhcnMxLFxuICAgIGNoYXJzMixcbiAgICBsaW5lQXJyYXlcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvTGluZU1vZGVEaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgYSA9IGxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxLCB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgbGV0IGRpZmZzID0gZG9EaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lOiBvcHRzLmRlYWRsaW5lXG4gIH0pO1xuICBjaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgXCJcIl0pO1xuICBsZXQgcG9pbnRlciA9IDAsIGNvdW50RGVsZXRlID0gMCwgY291bnRJbnNlcnQgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudEluc2VydCsrLCB0ZXh0SW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50RGVsZXRlKyssIHRleHREZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnREZWxldGUgPj0gMSAmJiBjb3VudEluc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0LCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IGFhID0gZG9EaWZmKHRleHREZWxldGUsIHRleHRJbnNlcnQsIHtcbiAgICAgICAgICAgIGNoZWNrTGluZXM6ICExLFxuICAgICAgICAgICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gYWEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYWFbal0pO1xuICAgICAgICAgIHBvaW50ZXIgKz0gYWEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50SW5zZXJ0ID0gMCwgY291bnREZWxldGUgPSAwLCB0ZXh0RGVsZXRlID0gXCJcIiwgdGV4dEluc2VydCA9IFwiXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkaWZmIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnMucG9wKCksIGRpZmZzO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRzKSB7XG4gIGxldCBkaWZmcztcbiAgaWYgKCF0ZXh0MSlcbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcbiAgaWYgKCF0ZXh0MilcbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxLCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpXG4gICAgcmV0dXJuIGRpZmZzID0gW1tESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSwgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dLCB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggJiYgKGRpZmZzWzBdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEUpLCBkaWZmcztcbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbmNvbnN0IERJRkZfREVMRVRFID0gLTEsIERJRkZfSU5TRVJUID0gMSwgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBkaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBpZiAodGV4dEEgPT09IG51bGwgfHwgdGV4dEIgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKGRpZmYpXCIpO1xuICBjb25zdCBkaWZmcyA9IGRvRGlmZih0ZXh0QSwgdGV4dEIsIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzIHx8IHt9KSk7XG4gIHJldHVybiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGRvRGlmZih0ZXh0QSwgdGV4dEIsIG9wdGlvbnMpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpXG4gICAgcmV0dXJuIHRleHQxID8gW1tESUZGX0VRVUFMLCB0ZXh0MV1dIDogW107XG4gIGxldCBjb21tb25sZW5ndGggPSBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcbiAgY29uc3QgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCksIGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgbGV0IGRpZmZzID0gY29tcHV0ZURpZmYodGV4dDEsIHRleHQyLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbW1vbnByZWZpeCAmJiBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKSwgY29tbW9uc3VmZml4ICYmIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pLCBkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVhZExpbmUodGltZW91dCkge1xuICBsZXQgdCA9IDE7XG4gIHJldHVybiB0eXBlb2YgdGltZW91dCA8IFwidVwiICYmICh0ID0gdGltZW91dCA8PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IHRpbWVvdXQpLCBEYXRlLm5vdygpICsgdCAqIDFlMztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsT3B0cyhvcHRzKSB7XG4gIHJldHVybiB7XG4gICAgY2hlY2tMaW5lczogITAsXG4gICAgZGVhZGxpbmU6IGNyZWF0ZURlYWRMaW5lKG9wdHMudGltZW91dCB8fCAxKSxcbiAgICAuLi5vcHRzXG4gIH07XG59XG5mdW5jdGlvbiBjb21iaW5lQ2hhcihkYXRhLCBjaGFyLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRhdGEgKyBjaGFyIDogY2hhciArIGRhdGE7XG59XG5mdW5jdGlvbiBzcGxpdENoYXIoZGF0YSwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBbZGF0YS5zdWJzdHJpbmcoMCwgZGF0YS5sZW5ndGggLSAxKSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdXSA6IFtkYXRhLnN1YnN0cmluZygxKSwgZGF0YVswXV07XG59XG5mdW5jdGlvbiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpLCBqLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRpZmZzW2ldWzFdW2RpZmZzW2ldWzFdLmxlbmd0aCAtIDFdID09PSBkaWZmc1tqXVsxXVtkaWZmc1tqXVsxXS5sZW5ndGggLSAxXSA6IGRpZmZzW2ldWzFdWzBdID09PSBkaWZmc1tqXVsxXVswXTtcbn1cbmZ1bmN0aW9uIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIGRpcikge1xuICBjb25zdCBpbnYgPSBkaXIgPT09IDEgPyAtMSA6IDE7XG4gIGxldCBpbnNlcnRJZHggPSBudWxsLCBkZWxldGVJZHggPSBudWxsLCBqID0gaSArIGRpcjtcbiAgZm9yICg7IGogPj0gMCAmJiBqIDwgZGlmZnMubGVuZ3RoICYmIChpbnNlcnRJZHggPT09IG51bGwgfHwgZGVsZXRlSWR4ID09PSBudWxsKTsgaiArPSBkaXIpIHtcbiAgICBjb25zdCBbb3AsIHRleHQyXSA9IGRpZmZzW2pdO1xuICAgIGlmICh0ZXh0Mi5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChvcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgaW5zZXJ0SWR4ID09PSBudWxsICYmIChpbnNlcnRJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICBkZWxldGVJZHggPT09IG51bGwgJiYgKGRlbGV0ZUlkeCA9IGopO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgaWYgKGluc2VydElkeCA9PT0gbnVsbCAmJiBkZWxldGVJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbcmVzdCwgY2hhcjJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICAgICAgICAgIGRpZmZzW2ldWzFdID0gcmVzdCwgZGlmZnNbal1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tqXVsxXSwgY2hhcjIsIGludik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5zZXJ0SWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpbnNlcnRJZHgsIGRlbGV0ZUlkeCwgZGlyKSkge1xuICAgIGNvbnN0IFtpbnNlcnRUZXh0LCBpbnNlcnRDaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpbnNlcnRJZHhdWzFdLCBpbnYpLCBbZGVsZXRlVGV4dF0gPSBzcGxpdENoYXIoZGlmZnNbZGVsZXRlSWR4XVsxXSwgaW52KTtcbiAgICBkaWZmc1tpbnNlcnRJZHhdWzFdID0gaW5zZXJ0VGV4dCwgZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGRlbGV0ZVRleHQsIGRpZmZzW2ldWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaV1bMV0sIGluc2VydENoYXIsIGRpcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt0ZXh0LCBjaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgZGlmZnNbaV1bMV0gPSB0ZXh0LCBpbnNlcnRJZHggPT09IG51bGwgPyAoZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0lOU0VSVCwgY2hhcl0pLCBkZWxldGVJZHggIT09IG51bGwgJiYgZGVsZXRlSWR4ID49IGogJiYgZGVsZXRlSWR4KyspIDogZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGNoYXIsIGludiksIGRlbGV0ZUlkeCA9PT0gbnVsbCA/IGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9ERUxFVEUsIGNoYXJdKSA6IGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBjaGFyLCBpbnYpO1xufVxuZnVuY3Rpb24gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGRpZmZzW2ldO1xuICAgIGlmIChkaWZmVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGRpZmZUZXh0WzBdLCBsYXN0Q2hhciA9IGRpZmZUZXh0W2RpZmZUZXh0Lmxlbmd0aCAtIDFdO1xuICAgIGlzSGlnaFN1cnJvZ2F0ZShsYXN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgMSksIGlzTG93U3Vycm9nYXRlKGZpcnN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgLTEpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspXG4gICAgZGlmZnNbaV1bMV0ubGVuZ3RoID09PSAwICYmIGRpZmZzLnNwbGljZShpLCAxKTtcbn1cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLyoqXG4gICAqIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxuICAgKi9cbiAgdGhyZXNob2xkOiAwLjUsXG4gIC8qKlxuICAgKiBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cbiAgICogQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXG4gICAqIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxuICAgKi9cbiAgZGlzdGFuY2U6IDFlM1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIC4uLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG59XG5jb25zdCBNQVhfQklUUyQxID0gMzI7XG5mdW5jdGlvbiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUyQxKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci5cIik7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRzKG9wdHMpLCBzID0gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKTtcbiAgZnVuY3Rpb24gZ2V0Qml0YXBTY29yZShlLCB4KSB7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGgsIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xuICAgIHJldHVybiBvcHRpb25zLmRpc3RhbmNlID8gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBvcHRpb25zLmRpc3RhbmNlIDogcHJveGltaXR5ID8gMSA6IGFjY3VyYWN5O1xuICB9XG4gIGxldCBzY29yZVRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkLCBiZXN0TG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGJlc3RMb2MgIT09IC0xICYmIChzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKGdldEJpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKSwgYmVzdExvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpLCBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCkpKTtcbiAgY29uc3QgbWF0Y2htYXNrID0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIDE7XG4gIGJlc3RMb2MgPSAtMTtcbiAgbGV0IGJpbk1pbiwgYmluTWlkLCBiaW5NYXggPSBwYXR0ZXJuLmxlbmd0aCArIHRleHQubGVuZ3RoLCBsYXN0UmQgPSBbXTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgZm9yIChiaW5NaW4gPSAwLCBiaW5NaWQgPSBiaW5NYXg7IGJpbk1pbiA8IGJpbk1pZDsgKVxuICAgICAgZ2V0Qml0YXBTY29yZShkLCBsb2MgKyBiaW5NaWQpIDw9IHNjb3JlVGhyZXNob2xkID8gYmluTWluID0gYmluTWlkIDogYmluTWF4ID0gYmluTWlkLCBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgYmluTWF4ID0gYmluTWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbk1pZCArIDEpO1xuICAgIGNvbnN0IGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbk1pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGgsIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDAgPyByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIDogcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCB8ICgobGFzdFJkW2ogKyAxXSB8IGxhc3RSZFtqXSkgPDwgMSB8IDEpIHwgbGFzdFJkW2ogKyAxXSwgcmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRCaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKVxuICAgICAgICAgIGlmIChzY29yZVRocmVzaG9sZCA9IHNjb3JlLCBiZXN0TG9jID0gaiAtIDEsIGJlc3RMb2MgPiBsb2MpXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0TG9jKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZVRocmVzaG9sZClcbiAgICAgIGJyZWFrO1xuICAgIGxhc3RSZCA9IHJkO1xuICB9XG4gIHJldHVybiBiZXN0TG9jO1xufVxuZnVuY3Rpb24gZ2V0QWxwaGFiZXRGcm9tUGF0dGVybihwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybi5sZW5ndGggLSBpIC0gMTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBtYXRjaCh0ZXh0LCBwYXR0ZXJuLCBzZWFyY2hMb2NhdGlvbikge1xuICBpZiAodGV4dCA9PT0gbnVsbCB8fCBwYXR0ZXJuID09PSBudWxsIHx8IHNlYXJjaExvY2F0aW9uID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChtYXRjaCgpKVwiKTtcbiAgY29uc3QgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VhcmNoTG9jYXRpb24sIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKVxuICAgIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pXG4gICAgICByZXR1cm4gbG9jO1xuICB9IGVsc2UgcmV0dXJuIC0xO1xuICByZXR1cm4gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSwgc3RhcnQyKSB7XG4gIHJldHVybiB7XG4gICAgZGlmZnM6IFtdLFxuICAgIHN0YXJ0MSxcbiAgICBzdGFydDIsXG4gICAgdXRmOFN0YXJ0MTogc3RhcnQxLFxuICAgIHV0ZjhTdGFydDI6IHN0YXJ0MixcbiAgICBsZW5ndGgxOiAwLFxuICAgIGxlbmd0aDI6IDAsXG4gICAgdXRmOExlbmd0aDE6IDAsXG4gICAgdXRmOExlbmd0aDI6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspXG4gICAgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKylcbiAgICBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKHRleHRbeF0gPSBkaWZmc1t4XVsxXSk7XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBjb3VudFV0ZjhCeXRlcyhzdHIpIHtcbiAgbGV0IGJ5dGVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiB7fSwgYnl0ZU9mZnNldCA9IDAsIGlkeCA9IDA7XG4gIGZ1bmN0aW9uIGFkdmFuY2VUbyh0YXJnZXQpIHtcbiAgICBmb3IgKDsgYnl0ZU9mZnNldCA8IHRhcmdldDsgKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBiYXNlLmNvZGVQb2ludEF0KGlkeCk7XG4gICAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgYnl0ZU9mZnNldCArPSB1dGY4bGVuKGNvZGVQb2ludCksIGNvZGVQb2ludCA+IDY1NTM1ID8gaWR4ICs9IDIgOiBpZHggKz0gMTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFsbG93RXhjZWVkaW5nSW5kaWNlcyAmJiBieXRlT2Zmc2V0ICE9PSB0YXJnZXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKVxuICAgIGFkanVzdGVkLnB1c2goe1xuICAgICAgZGlmZnM6IHBhdGNoLmRpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLFxuICAgICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICAgIHN0YXJ0MjogYWR2YW5jZVRvKHBhdGNoLnN0YXJ0MiksXG4gICAgICB1dGY4U3RhcnQxOiBwYXRjaC51dGY4U3RhcnQxLFxuICAgICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICAgIGxlbmd0aDE6IHBhdGNoLmxlbmd0aDEsXG4gICAgICBsZW5ndGgyOiBwYXRjaC5sZW5ndGgyLFxuICAgICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgICAgdXRmOExlbmd0aDI6IHBhdGNoLnV0ZjhMZW5ndGgyXG4gICAgfSk7XG4gIHJldHVybiBhZGp1c3RlZDtcbn1cbmZ1bmN0aW9uIHV0ZjhsZW4oY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPD0gMTI3ID8gMSA6IGNvZGVQb2ludCA8PSAyMDQ3ID8gMiA6IGNvZGVQb2ludCA8PSA2NTUzNSA/IDMgOiA0O1xufVxuY29uc3QgTUFYX0JJVFMgPSAzMiwgREVGQVVMVF9NQVJHSU4gPSA0O1xuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2MpIHtcbiAgbGV0IGNoYXJzMSA9IDAsIGNoYXJzMiA9IDAsIGxhc3RDaGFyczEgPSAwLCBsYXN0Q2hhcnMyID0gMCwgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aCAmJiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmIChjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmIChjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgIShjaGFyczEgPiBsb2MpKTsgeCsrKVxuICAgIGxhc3RDaGFyczEgPSBjaGFyczEsIGxhc3RDaGFyczIgPSBjaGFyczI7XG4gIHJldHVybiBkaWZmcy5sZW5ndGggIT09IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFID8gbGFzdENoYXJzMiA6IGxhc3RDaGFyczIgKyAobG9jIC0gbGFzdENoYXJzMSk7XG59XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMpIHtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9NQVJHSU47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKylcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICBmb3IgKGNvbnN0IHAgb2YgcGF0Y2hlcylcbiAgICBwLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDEgKz0gcGFkZGluZ0xlbmd0aCwgcC51dGY4U3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGxldCBwYXRjaCA9IHBhdGNoZXNbMF0sIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbMF1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKSwgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG4gIHJldHVybiBudWxsUGFkZGluZztcbn1cbmZ1bmN0aW9uIHNwbGl0TWF4KHBhdGNoZXMpIHtcbiAgbGV0IG1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9NQVJHSU47XG4gIGNvbnN0IHBhdGNoU2l6ZSA9IE1BWF9CSVRTO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoU2l6ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRjaGVzIG11c3QgYmUgYW4gYXJyYXkgLSBwYXNzIHRoZSBwYXRjaCB0byBgcGFyc2VQYXRjaCgpYCBmaXJzdFwiKTtcbiAgbGV0IHRleHQgPSBvcmlnaW5hbFRleHQ7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcbiAgY29uc3QgcGFyc2VkID0gYWRqdXN0SW5kaWNpZXNUb1VjczIocGF0Y2hlcywgdGV4dCwge1xuICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogb3B0cy5hbGxvd0V4Y2VlZGluZ0luZGljZXNcbiAgfSksIG1hcmdpbiA9IG9wdHMubWFyZ2luIHx8IERFRkFVTFRfTUFSR0lOLCBkZWxldGVUaHJlc2hvbGQgPSBvcHRzLmRlbGV0ZVRocmVzaG9sZCB8fCAwLjQsIG51bGxQYWRkaW5nID0gYWRkUGFkZGluZyhwYXJzZWQsIG1hcmdpbik7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZywgc3BsaXRNYXgocGFyc2VkLCBtYXJnaW4pO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGFyc2VkLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRMb2MgPSBwYXJzZWRbeF0uc3RhcnQyICsgZGVsdGEsIHRleHQxID0gZGlmZlRleHQxKHBhcnNlZFt4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0TG9jLCBlbmRMb2MgPSAtMTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgPyAoc3RhcnRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgTUFYX0JJVFMpLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jICE9PSAtMSAmJiAoZW5kTG9jID0gbWF0Y2godGV4dCwgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgZXhwZWN0ZWRMb2MgKyB0ZXh0MS5sZW5ndGggLSBNQVhfQklUUyksIChlbmRMb2MgPT09IC0xIHx8IHN0YXJ0TG9jID49IGVuZExvYykgJiYgKHN0YXJ0TG9jID0gLTEpKSkgOiBzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLCBleHBlY3RlZExvYyksIHN0YXJ0TG9jID09PSAtMSlcbiAgICAgIHJlc3VsdHNbeF0gPSAhMSwgZGVsdGEgLT0gcGFyc2VkW3hdLmxlbmd0aDIgLSBwYXJzZWRbeF0ubGVuZ3RoMTtcbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdHNbeF0gPSAhMCwgZGVsdGEgPSBzdGFydExvYyAtIGV4cGVjdGVkTG9jO1xuICAgICAgbGV0IHRleHQyO1xuICAgICAgaWYgKGVuZExvYyA9PT0gLTEgPyB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jLCBzdGFydExvYyArIHRleHQxLmxlbmd0aCkgOiB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jLCBlbmRMb2MgKyBNQVhfQklUUyksIHRleHQxID09PSB0ZXh0MilcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jKSArIGRpZmZUZXh0MihwYXJzZWRbeF0uZGlmZnMpICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBkaWZmcyA9IGRpZmYodGV4dDEsIHRleHQyLCB7XG4gICAgICAgICAgY2hlY2tMaW5lczogITFcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyAmJiBsZXZlbnNodGVpbihkaWZmcykgLyB0ZXh0MS5sZW5ndGggPiBkZWxldGVUaHJlc2hvbGQpXG4gICAgICAgICAgcmVzdWx0c1t4XSA9ICExO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICBsZXQgaW5kZXgxID0gMCwgaW5kZXgyID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhcnNlZFt4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kID0gcGFyc2VkW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgbW9kWzBdICE9PSBESUZGX0VRVUFMICYmIChpbmRleDIgPSB4SW5kZXgoZGlmZnMsIGluZGV4MSkpLCBtb2RbMF0gPT09IERJRkZfSU5TRVJUID8gdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIG1vZFsxXSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgaW5kZXgyKSA6IG1vZFswXSA9PT0gRElGRl9ERUxFVEUgJiYgKHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYyArIGluZGV4MikgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHhJbmRleChkaWZmcywgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpKSwgbW9kWzBdICE9PSBESUZGX0RFTEVURSAmJiAoaW5kZXgxICs9IG1vZFsxXS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpLCBbdGV4dCwgcmVzdWx0c107XG59XG5jb25zdCBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XG5mdW5jdGlvbiBwYXJzZSh0ZXh0bGluZSkge1xuICBpZiAoIXRleHRsaW5lKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF0Y2ggc3RyaW5nOiBcIi5jb25jYXQobGluZXNbdGV4dFBvaW50ZXJdKSk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBlc2NhcGUgaW4gcGFyc2U6IFwiLmNvbmNhdChjdXJyZW50TGluZSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdXRmOERpZmYgPSBjb3VudFV0ZjhCeXRlcyhsaW5lKSAtIGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKHNpZ24gPT09IFwiLVwiKVxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIrXCIpXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSksIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIiBcIilcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicuY29uY2F0KHNpZ24sICdcIiBpbjogJykuY29uY2F0KGxpbmUpKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IGRlYnVnJGggPSBkZWJ1Z1dpdGhOYW1lKFwiYXBwbHlQYXRjaGVzXCIpLCBkZWJ1Z1ZlcmJvc2UkMyA9IGRlYnVnJGguZW5hYmxlZCAmJiAhMDtcbmZ1bmN0aW9uIGNyZWF0ZUFwcGx5UGF0Y2goc2NoZW1hVHlwZXMpIHtcbiAgbGV0IHByZXZpb3VzUGF0Y2g7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IsIHBhdGNoKSB7XG4gICAgbGV0IGNoYW5nZWQgPSAhMTtcbiAgICBkZWJ1Z1ZlcmJvc2UkMyAmJiAoZGVidWckaChgXG5cbk5FVyBQQVRDSCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09YCksIGRlYnVnJGgoSlNPTi5zdHJpbmdpZnkocGF0Y2gsIG51bGwsIDIpKSk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInVuc2V0XCI6XG4gICAgICAgICAgY2hhbmdlZCA9IHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCwgcHJldmlvdXNQYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkaWZmTWF0Y2hQYXRjaFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBkaWZmTWF0Y2hQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkZWJ1ZyRoKFwiVW5oYW5kbGVkIHBhdGNoXCIsIHBhdGNoLnR5cGUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJldmlvdXNQYXRjaCA9IHBhdGNoLCBjaGFuZ2VkO1xuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBjb25zdCB7IGJsb2NrLCBjaGlsZCwgY2hpbGRQYXRoIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIGRlYnVnJGgoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJGgoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBpZiAoIShibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSA0ICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoWzNdID09PSBcInRleHRcIikgfHwgIVRleHQuaXNUZXh0KGNoaWxkKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHBhdGNoZXMgPSBwYXJzZShwYXRjaC52YWx1ZSksIFtuZXdWYWx1ZV0gPSBhcHBseShwYXRjaGVzLCBjaGlsZC50ZXh0LCB7IGFsbG93RXhjZWVkaW5nSW5kaWNlczogITAgfSksIGRpZmYkMSA9IGNsZWFudXBFZmZpY2llbmN5KGRpZmYoY2hpbGQudGV4dCwgbmV3VmFsdWUpLCA1KTtcbiAgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBbb3AsIHRleHRdIG9mIGRpZmYkMSlcbiAgICBvcCA9PT0gRElGRl9JTlNFUlQgPyAoZWRpdG9yLmFwcGx5KHsgdHlwZTogXCJpbnNlcnRfdGV4dFwiLCBwYXRoOiBjaGlsZFBhdGgsIG9mZnNldCwgdGV4dCB9KSwgb2Zmc2V0ICs9IHRleHQubGVuZ3RoKSA6IG9wID09PSBESUZGX0RFTEVURSA/IGVkaXRvci5hcHBseSh7IHR5cGU6IFwicmVtb3ZlX3RleHRcIiwgcGF0aDogY2hpbGRQYXRoLCBvZmZzZXQsIHRleHQgfSkgOiBvcCA9PT0gRElGRl9FUVVBTCAmJiAob2Zmc2V0ICs9IHRleHQubGVuZ3RoKTtcbiAgcmV0dXJuIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIGluc2VydFBhdGNoKGVkaXRvciwgcGF0Y2gsIHNjaGVtYVR5cGVzKSB7XG4gIGNvbnN0IHtcbiAgICBibG9jazogdGFyZ2V0QmxvY2ssXG4gICAgY2hpbGQ6IHRhcmdldENoaWxkLFxuICAgIGJsb2NrUGF0aDogdGFyZ2V0QmxvY2tQYXRoLFxuICAgIGNoaWxkUGF0aDogdGFyZ2V0Q2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghdGFyZ2V0QmxvY2sgfHwgIXRhcmdldEJsb2NrUGF0aClcbiAgICByZXR1cm4gZGVidWckaChcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDEgJiYgcGF0Y2gucGF0aFsxXSAhPT0gXCJjaGlsZHJlblwiKVxuICAgIHJldHVybiBkZWJ1ZyRoKFwiSWdub3JpbmcgcGF0Y2ggdGFyZ2V0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB7IGl0ZW1zOiBpdGVtczIsIHBvc2l0aW9uOiBwb3NpdGlvbjIgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShcbiAgICAgIGl0ZW1zMixcbiAgICAgIHsgc2NoZW1hVHlwZXMgfSxcbiAgICAgIEtFWV9UT19TTEFURV9FTEVNRU5ULmdldChlZGl0b3IpXG4gICAgKSwgdGFyZ2V0QmxvY2tJbmRleCA9IHRhcmdldEJsb2NrUGF0aFswXSwgbm9ybWFsaXplZElkeDIgPSBwb3NpdGlvbjIgPT09IFwiYWZ0ZXJcIiA/IHRhcmdldEJsb2NrSW5kZXggKyAxIDogdGFyZ2V0QmxvY2tJbmRleDtcbiAgICByZXR1cm4gZGVidWckaChgSW5zZXJ0aW5nIGJsb2NrcyBhdCBwYXRoIFske25vcm1hbGl6ZWRJZHgyfV1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2tzVG9JbnNlcnQsIHsgYXQ6IFtub3JtYWxpemVkSWR4Ml0gfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbiAgfVxuICBjb25zdCB7IGl0ZW1zLCBwb3NpdGlvbiB9ID0gcGF0Y2g7XG4gIGlmICghdGFyZ2V0Q2hpbGQgfHwgIXRhcmdldENoaWxkUGF0aClcbiAgICByZXR1cm4gZGVidWckaChcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGNoaWxkcmVuVG9JbnNlcnQgPSB0YXJnZXRCbG9jayAmJiB0b1NsYXRlVmFsdWUoXG4gICAgW3sgLi4udGFyZ2V0QmxvY2ssIGNoaWxkcmVuOiBpdGVtcyB9XSxcbiAgICB7IHNjaGVtYVR5cGVzIH0sXG4gICAgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcilcbiAgKSwgdGFyZ2V0Q2hpbGRJbmRleCA9IHRhcmdldENoaWxkUGF0aFsxXSwgbm9ybWFsaXplZElkeCA9IHBvc2l0aW9uID09PSBcImFmdGVyXCIgPyB0YXJnZXRDaGlsZEluZGV4ICsgMSA6IHRhcmdldENoaWxkSW5kZXgsIGNoaWxkSW5zZXJ0UGF0aCA9IFt0YXJnZXRDaGlsZFBhdGhbMF0sIG5vcm1hbGl6ZWRJZHhdO1xuICByZXR1cm4gZGVidWckaChgSW5zZXJ0aW5nIGNoaWxkcmVuIGF0IHBhdGggJHtjaGlsZEluc2VydFBhdGh9YCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgY2hpbGRyZW5Ub0luc2VydCAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkcmVuVG9JbnNlcnRbMF0pICYmIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZHJlblRvSW5zZXJ0WzBdLmNoaWxkcmVuLCB7IGF0OiBjaGlsZEluc2VydFBhdGggfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgbGV0IHZhbHVlID0gcGF0Y2gudmFsdWU7XG4gIHR5cGVvZiBwYXRjaC5wYXRoWzNdID09IFwic3RyaW5nXCIgJiYgKHZhbHVlID0ge30sIHZhbHVlW3BhdGNoLnBhdGhbM11dID0gcGF0Y2gudmFsdWUpO1xuICBjb25zdCB7IGJsb2NrLCBibG9ja1BhdGgsIGNoaWxkLCBjaGlsZFBhdGggfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCFibG9jaylcbiAgICByZXR1cm4gZGVidWckaChcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGlzVGV4dEJsb2NrID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKTtcbiAgaWYgKGlzVGV4dEJsb2NrICYmIHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGgoXCJJZ25vcmluZyBzZXR0aW5nIHZvaWQgdmFsdWVcIiksICExO1xuICBpZiAoZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBpc1RleHRCbG9jayAmJiBjaGlsZCAmJiBjaGlsZFBhdGgpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQodmFsdWUpICYmIFRleHQuaXNUZXh0KGNoaWxkKSkge1xuICAgICAgY29uc3QgbmV3VGV4dCA9IGNoaWxkLnRleHQ7XG4gICAgICB2YWx1ZS50ZXh0ICE9PSBuZXdUZXh0ICYmIChkZWJ1ZyRoKFwiU2V0dGluZyB0ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZV90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiBuZXdUZXh0XG4gICAgICB9KSwgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgICBwYXRoOiBjaGlsZFBhdGgsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgdGV4dDogdmFsdWUudGV4dFxuICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9IGVsc2VcbiAgICAgIGRlYnVnJGgoXCJTZXR0aW5nIG5vbi10ZXh0IHByb3BlcnR5XCIpLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcInNldF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIG5ld1Byb3BlcnRpZXM6IHZhbHVlXG4gICAgICB9KTtcbiAgICByZXR1cm4gITA7XG4gIH0gZWxzZSBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEgJiYgYmxvY2tQYXRoKSB7XG4gICAgZGVidWckaChcIlNldHRpbmcgYmxvY2sgcHJvcGVydHlcIik7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ubmV4dFJlc3QgfSA9IHZhbHVlLCB7IGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIC4uLnByZXZSZXN0IH0gPSBibG9jayB8fCB7IGNoaWxkcmVuOiB2b2lkIDAgfTtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJzZXRfbm9kZVwiLFxuICAgICAgcGF0aDogYmxvY2tQYXRoLFxuICAgICAgcHJvcGVydGllczogeyAuLi5wcmV2UmVzdCB9LFxuICAgICAgbmV3UHJvcGVydGllczogbmV4dFJlc3RcbiAgICB9KSwgZGVidWckaChcIlNldHRpbmcgY2hpbGRyZW5cIiksIGJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGMsIGNJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGguY29uY2F0KGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgLSBjSW5kZXgpLFxuICAgICAgICBub2RlOiBjXG4gICAgICB9KTtcbiAgICB9KSwgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4uZm9yRWFjaCgoYywgY0luZGV4KSA9PiB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF9ub2RlXCIsXG4gICAgICAgIHBhdGg6IGJsb2NrUGF0aC5jb25jYXQoY0luZGV4KSxcbiAgICAgICAgbm9kZTogY1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sgJiYgXCJ2YWx1ZVwiIGluIGJsb2NrKSB7XG4gICAgY29uc3QgbmV3VmFsID0gYXBwbHlBbGwoW2Jsb2NrLnZhbHVlXSwgW3BhdGNoXSlbMF07XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IC4uLmJsb2NrLCB2YWx1ZTogbmV3VmFsIH0sIHsgYXQ6IGJsb2NrUGF0aCB9KSwgITA7XG4gIH1cbiAgcmV0dXJuIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHVuc2V0UGF0Y2goZWRpdG9yLCBwYXRjaCwgcHJldmlvdXNQYXRjaCkge1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBkZWJ1ZyRoKFwiUmVtb3ZpbmcgZXZlcnl0aGluZ1wiKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpO1xuICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICByZXR1cm4gVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3IuY2hpbGRyZW4uZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IFtpXSB9KTtcbiAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVFbXB0eUJsb2NrKCkpLCBwcmV2aW91c1NlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjogeyBwYXRoOiBbMCwgMF0sIG9mZnNldDogMCB9LFxuICAgICAgZm9jdXM6IHsgcGF0aDogWzAsIDBdLCBvZmZzZXQ6IDAgfVxuICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHsgYmxvY2ssIGJsb2NrUGF0aCwgY2hpbGQsIGNoaWxkUGF0aCB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoIWJsb2NrIHx8ICFibG9ja1BhdGgpXG4gICAgICByZXR1cm4gZGVidWckaChcIkJsb2NrIG5vdCBmb3VuZFwiKSwgITE7XG4gICAgY29uc3QgYmxvY2tJbmRleCA9IGJsb2NrUGF0aFswXTtcbiAgICByZXR1cm4gZGVidWckaChgUmVtb3ZpbmcgYmxvY2sgYXQgcGF0aCBbJHtibG9ja0luZGV4fV1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwgeyBhdDogW2Jsb2NrSW5kZXhdIH0pLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgcmV0dXJuIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgcGF0Y2gucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSAzID8gIWNoaWxkIHx8ICFjaGlsZFBhdGggPyAoZGVidWckaChcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITEpIDogKGRlYnVnJGgoYFVuc2V0dGluZyBjaGlsZCBhdCBwYXRoICR7SlNPTi5zdHJpbmdpZnkoY2hpbGRQYXRoKX1gKSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYmVmb3JlXCIpLCBkZWJ1Z1ZlcmJvc2UkMyAmJiBkZWJ1ZyRoKGBSZW1vdmluZyBjaGlsZCBhdCBwYXRoICR7SlNPTi5zdHJpbmdpZnkoY2hpbGRQYXRoKX1gKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgYXQ6IGNoaWxkUGF0aCB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gaXNLZXllZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gZGVidWdTdGF0ZShlZGl0b3IsIHN0YXRlTmFtZSkge1xuICBkZWJ1Z1ZlcmJvc2UkMyAmJiAoZGVidWckaChgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyRoKGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMF0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzBdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFswXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoYmxvY2tJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHsgYmxvY2ssIHBhdGg6IFtibG9ja0luZGV4XSB9IDoge307XG59XG5mdW5jdGlvbiBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0aCkge1xuICBjb25zdCB7IGJsb2NrLCBwYXRoOiBibG9ja1BhdGggfSA9IGZpbmRCbG9ja0Zyb21QYXRoKGVkaXRvciwgcGF0aCk7XG4gIGlmICghKEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spICYmIHBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIikpXG4gICAgcmV0dXJuIHsgYmxvY2ssIGJsb2NrUGF0aCwgY2hpbGQ6IHZvaWQgMCwgY2hpbGRQYXRoOiB2b2lkIDAgfTtcbiAgbGV0IGNoaWxkSW5kZXggPSAtMTtcbiAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbi5maW5kKChub2RlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpc0tleWVkU2VnbWVudChwYXRoWzJdKSA/IG5vZGUuX2tleSA9PT0gcGF0aFsyXS5fa2V5IDogaW5kZXggPT09IHBhdGhbMl07XG4gICAgcmV0dXJuIGlzTWF0Y2ggJiYgKGNoaWxkSW5kZXggPSBpbmRleCksIGlzTWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gY2hpbGQgPyB7IGJsb2NrLCBjaGlsZCwgYmxvY2tQYXRoLCBjaGlsZFBhdGg6IGJsb2NrUGF0aCA9PSBudWxsID8gdm9pZCAwIDogYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KSB9IDogeyBibG9jaywgYmxvY2tQYXRoLCBjaGlsZDogdm9pZCAwLCBjaGlsZFBhdGg6IHZvaWQgMCB9O1xufVxuZnVuY3Rpb24gd2l0aFJlbW90ZUNoYW5nZXMoZWRpdG9yLCBmbikge1xuICBjb25zdCBwcmV2ID0gaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikgfHwgITE7XG4gIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgITApLCBmbigpLCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikge1xuICByZXR1cm4gSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGlzQ2hhbmdpbmdMb2NhbGx5KGVkaXRvcikge1xuICByZXR1cm4gSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTLmdldChlZGl0b3IpO1xufVxuY29uc3QgUEFUQ0hJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHdpdGhvdXRQYXRjaGluZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1BhdGNoaW5nKGVkaXRvcik7XG4gIFBBVENISU5HLnNldChlZGl0b3IsICExKSwgZm4oKSwgUEFUQ0hJTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1BhdGNoaW5nKGVkaXRvcikge1xuICByZXR1cm4gUEFUQ0hJTkcuZ2V0KGVkaXRvcik7XG59XG5jb25zdCBkZWJ1ZyRnID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoVW5kb1JlZG9cIiksIGRlYnVnVmVyYm9zZSQyID0gZGVidWckZy5lbmFibGVkICYmICExLCBTQVZJTkcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgUkVNT1RFX1BBVENIRVMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgVU5ET19TVEVQX0xJTUlUID0gMWUzLCBpc1NhdmluZyA9IChlZGl0b3IpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBTQVZJTkcuZ2V0KGVkaXRvcik7XG4gIHJldHVybiBzdGF0ZSA9PT0gdm9pZCAwID8gITAgOiBzdGF0ZTtcbn0sIGdldFJlbW90ZVBhdGNoZXMgPSAoZWRpdG9yKSA9PiAoUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgUkVNT1RFX1BBVENIRVMuc2V0KGVkaXRvciwgW10pLCBSRU1PVEVfUEFUQ0hFUy5nZXQoZWRpdG9yKSB8fCBbXSk7XG5mdW5jdGlvbiBjcmVhdGVXaXRoVW5kb1JlZG8ob3B0aW9ucykge1xuICBjb25zdCB7IHJlYWRPbmx5LCBwYXRjaGVzJCwgYmxvY2tTY2hlbWFUeXBlIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKGVkaXRvcikgPT4ge1xuICAgIGxldCBwcmV2aW91c1NuYXBzaG90ID0gZnJvbVNsYXRlVmFsdWUoXG4gICAgICBlZGl0b3IuY2hpbGRyZW4sXG4gICAgICBibG9ja1NjaGVtYVR5cGUubmFtZVxuICAgICk7XG4gICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IGdldFJlbW90ZVBhdGNoZXMoZWRpdG9yKTtcbiAgICBwYXRjaGVzJCAmJiBlZGl0b3Iuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGcoXCJTdWJzY3JpYmluZyB0byBwYXRjaGVzXCIpO1xuICAgICAgY29uc3Qgc3ViID0gcGF0Y2hlcyQuc3Vic2NyaWJlKCh7IHBhdGNoZXMsIHNuYXBzaG90IH0pID0+IHtcbiAgICAgICAgbGV0IHJlc2V0ID0gITE7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc2V0ICYmIHBhdGNoLm9yaWdpbiAhPT0gXCJsb2NhbFwiICYmIHJlbW90ZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWckZyhcIlNvbWVvbmUgZWxzZSBjbGVhcmVkIHRoZSBjb250ZW50LCByZXNldHRpbmcgdW5kby9yZWRvIGhpc3RvcnlcIiksIGVkaXRvci5oaXN0b3J5ID0geyB1bmRvczogW10sIHJlZG9zOiBbXSB9LCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIHJlc2V0ID0gITA7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW90ZVBhdGNoZXMucHVzaCh7IHBhdGNoLCB0aW1lOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgc25hcHNob3QsIHByZXZpb3VzU25hcHNob3QgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcHJldmlvdXNTbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkZWJ1ZyRnKFwiVW5zdWJzY3JpYmluZyB0byBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5oaXN0b3J5ID0geyB1bmRvczogW10sIHJlZG9zOiBbXSB9O1xuICAgIGNvbnN0IHsgYXBwbHk6IGFwcGx5MiB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IG9wZXJhdGlvbnMsIGhpc3RvcnkgfSA9IGVkaXRvciwgeyB1bmRvcyB9ID0gaGlzdG9yeSwgc3RlcCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdLCBsYXN0T3AgPSBzdGVwICYmIHN0ZXAub3BlcmF0aW9ucyAmJiBzdGVwLm9wZXJhdGlvbnNbc3RlcC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdLCBvdmVyd3JpdGUgPSBzaG91bGRPdmVyd3JpdGUob3AsIGxhc3RPcCksIHNhdmUgPSBpc1NhdmluZyhlZGl0b3IpO1xuICAgICAgbGV0IG1lcmdlID0gITA7XG4gICAgICBpZiAoc2F2ZSkge1xuICAgICAgICBpZiAoc3RlcCA/IG9wZXJhdGlvbnMubGVuZ3RoID09PSAwICYmIChtZXJnZSA9IHNob3VsZE1lcmdlKG9wLCBsYXN0T3ApIHx8IG92ZXJ3cml0ZSkgOiBtZXJnZSA9ICExLCBzdGVwICYmIG1lcmdlKVxuICAgICAgICAgIHN0ZXAub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RlcCA9IHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IFsuLi5lZGl0b3Iuc2VsZWN0aW9uID09PSBudWxsID8gW10gOiBbY3JlYXRlU2VsZWN0T3BlcmF0aW9uKGVkaXRvcildLCBvcF0sXG4gICAgICAgICAgICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB1bmRvcy5wdXNoKG5ld1N0ZXApLCBkZWJ1ZyRnKFwiQ3JlYXRlZCBuZXcgdW5kbyBzdGVwXCIsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyB1bmRvcy5sZW5ndGggPiBVTkRPX1NURVBfTElNSVQ7IClcbiAgICAgICAgICB1bmRvcy5zaGlmdCgpO1xuICAgICAgICBzaG91bGRDbGVhcihvcCkgJiYgKGhpc3RvcnkucmVkb3MgPSBbXSk7XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvci51bmRvID0gKCkgPT4ge1xuICAgICAgaWYgKHJlYWRPbmx5KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHVuZG9zIH0gPSBlZGl0b3IuaGlzdG9yeTtcbiAgICAgIGlmICh1bmRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRlYnVnJGcoXCJVbmRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4oXG4gICAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoUHJlc2VydmVLZXlzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKE9wZXJhdGlvbi5pbnZlcnNlKS5yZXZlcnNlKCkuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVidWckZyhcIkNvdWxkIG5vdCBwZXJmb3JtIHVuZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7IHVuZG9zOiBbXSwgcmVkb3M6IFtdIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS51bmRvcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVkaXRvci5yZWRvID0gKCkgPT4ge1xuICAgICAgaWYgKHJlYWRPbmx5KVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHJlZG9zIH0gPSBlZGl0b3IuaGlzdG9yeTtcbiAgICAgIGlmIChyZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSByZWRvc1tyZWRvcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRlYnVnJGcoXCJSZWRvaW5nXCIsIHN0ZXApLCBzdGVwLm9wZXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG90aGVyUGF0Y2hlcyA9IHJlbW90ZVBhdGNoZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnRpbWUgPj0gc3RlcC50aW1lc3RhbXApO1xuICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBzdGVwLm9wZXJhdGlvbnM7XG4gICAgICAgICAgb3RoZXJQYXRjaGVzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IGZsYXR0ZW4oXG4gICAgICAgICAgICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoUHJlc2VydmVLZXlzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVidWckZyhcIkNvdWxkIG5vdCBwZXJmb3JtIHJlZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7IHVuZG9zOiBbXSwgcmVkb3M6IFtdIH0sIFNBVklORy5zZXQoZWRpdG9yLCAhMCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuaGlzdG9yeS51bmRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybU9wZXJhdGlvbihlZGl0b3IsIHBhdGNoLCBvcGVyYXRpb24sIHNuYXBzaG90LCBwcmV2aW91c1NuYXBzaG90KSB7XG4gIGRlYnVnVmVyYm9zZSQyICYmIChkZWJ1ZyRnKGBBZGp1c3RpbmcgJyR7b3BlcmF0aW9uLnR5cGV9JyBvcGVyYXRpb24gcGF0aHMgZm9yICcke3BhdGNoLnR5cGV9JyBwYXRjaGApLCBkZWJ1ZyRnKGBPcGVyYXRpb24gJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24pfWApLCBkZWJ1ZyRnKGBQYXRjaCAke0pTT04uc3RyaW5naWZ5KHBhdGNoKX1gKSk7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24gfTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBpbnNlcnRCbG9ja0luZGV4ID0gKHNuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoXG4gICAgICAoYmxrKSA9PiBpc0VxdWFsKHsgX2tleTogYmxrLl9rZXkgfSwgcGF0Y2gucGF0aFswXSlcbiAgICApO1xuICAgIHJldHVybiBkZWJ1ZyRnKFxuICAgICAgYEFkanVzdGluZyBibG9jayBwYXRoICgrJHtwYXRjaC5pdGVtcy5sZW5ndGh9KSBmb3IgJyR7dHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBhbmQgcGF0Y2ggJyR7cGF0Y2gudHlwZX0nYFxuICAgICksIFthZGp1c3RCbG9ja1BhdGgodHJhbnNmb3JtZWRPcGVyYXRpb24sIHBhdGNoLml0ZW1zLmxlbmd0aCwgaW5zZXJ0QmxvY2tJbmRleCldO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB1bnNldEJsb2NrSW5kZXggPSAocHJldmlvdXNTbmFwc2hvdCB8fCBbXSkuZmluZEluZGV4KFxuICAgICAgKGJsaykgPT4gaXNFcXVhbCh7IF9rZXk6IGJsay5fa2V5IH0sIHBhdGNoLnBhdGhbMF0pXG4gICAgKTtcbiAgICByZXR1cm4gXCJwYXRoXCIgaW4gdHJhbnNmb3JtZWRPcGVyYXRpb24gJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID09PSB1bnNldEJsb2NrSW5kZXggPyAoZGVidWckZyhcIlNraXBwaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgdGFyZ2V0ZWQgcmVtb3ZlZCBibG9ja1wiKSwgW10pIDogKGRlYnVnVmVyYm9zZSQyICYmIChkZWJ1ZyRnKGBTZWxlY3Rpb24gJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX1gKSwgZGVidWckZyhcbiAgICAgIGBBZGp1c3RpbmcgYmxvY2sgcGF0aCAoLTEpIGZvciAnJHt0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIGFuZCBwYXRjaCAnJHtwYXRjaC50eXBlfSdgXG4gICAgKSksIFthZGp1c3RCbG9ja1BhdGgodHJhbnNmb3JtZWRPcGVyYXRpb24sIC0xLCB1bnNldEJsb2NrSW5kZXgpXSk7XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gZGVidWckZyhgQWRqdXN0aW5nIHNlbGVjdGlvbiBmb3IgdW5zZXQgZXZlcnl0aGluZyBwYXRjaCBhbmQgJHtvcGVyYXRpb24udHlwZX0gb3BlcmF0aW9uYCksIFtdO1xuICBpZiAocGF0Y2gudHlwZSA9PT0gXCJkaWZmTWF0Y2hQYXRjaFwiKSB7XG4gICAgY29uc3Qgb3BlcmF0aW9uVGFyZ2V0QmxvY2sgPSBmaW5kT3BlcmF0aW9uVGFyZ2V0QmxvY2soZWRpdG9yLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbik7XG4gICAgcmV0dXJuICFvcGVyYXRpb25UYXJnZXRCbG9jayB8fCAhaXNFcXVhbCh7IF9rZXk6IG9wZXJhdGlvblRhcmdldEJsb2NrLl9rZXkgfSwgcGF0Y2gucGF0aFswXSkgPyBbdHJhbnNmb3JtZWRPcGVyYXRpb25dIDogKHBhcnNlKHBhdGNoLnZhbHVlKS5mb3JFYWNoKChkaWZmUGF0Y2gpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIGxldCBhZGp1c3RPZmZzZXRCeSA9IDAsIGNoYW5nZWRPZmZzZXQgPSBkaWZmUGF0Y2gudXRmOFN0YXJ0MTtcbiAgICAgIGNvbnN0IHsgZGlmZnMgfSA9IGRpZmZQYXRjaDtcbiAgICAgIGlmIChkaWZmcy5mb3JFYWNoKChkaWZmMiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgW2RpZmZUeXBlLCB0ZXh0XSA9IGRpZmYyO1xuICAgICAgICBkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQgPyAoYWRqdXN0T2Zmc2V0QnkgKz0gdGV4dC5sZW5ndGgsIGNoYW5nZWRPZmZzZXQgKz0gdGV4dC5sZW5ndGgpIDogZGlmZlR5cGUgPT09IERJRkZfREVMRVRFID8gKGFkanVzdE9mZnNldEJ5IC09IHRleHQubGVuZ3RoLCBjaGFuZ2VkT2Zmc2V0IC09IHRleHQubGVuZ3RoKSA6IGRpZmZUeXBlID09PSBESUZGX0VRVUFMICYmIChkaWZmcy5zbGljZShpbmRleCkuZXZlcnkoKFtkVHlwZV0pID0+IGRUeXBlID09PSBESUZGX0VRVUFMKSB8fCAoY2hhbmdlZE9mZnNldCArPSB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgfSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDwgdHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInJlbW92ZV90ZXh0XCIgJiYgY2hhbmdlZE9mZnNldCA8PSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgLSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50ZXh0Lmxlbmd0aCAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEZvY3VzID0gKF9hID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcykgIT0gbnVsbCAmJiBfYS5mb2N1cyA/IHsgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5mb2N1cyB9IDogdm9pZCAwLCBjdXJyZW50QW5jaG9yID0gKF9iID0gdHJhbnNmb3JtZWRPcGVyYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMpICE9IG51bGwgJiYgX2IuYW5jaG9yID8geyAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvciB9IDogdm9pZCAwLCBuZXdGb2N1cyA9IChfYyA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9jLmZvY3VzID8geyAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmZvY3VzIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IChfZCA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9kLmFuY2hvciA/IHsgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5hbmNob3IgfSA6IHZvaWQgMDtcbiAgICAgICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICAgICAgcG9pbnQgJiYgY2hhbmdlZE9mZnNldCA8IHBvaW50Lm9mZnNldCAmJiAocG9pbnQub2Zmc2V0ICs9IGFkanVzdE9mZnNldEJ5KTtcbiAgICAgICAgfSksIGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgIGZvY3VzOiBjdXJyZW50Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgICAgIH0pLCBuZXdGb2N1cyAmJiBuZXdBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IG5ld0ZvY3VzLFxuICAgICAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KSwgW3RyYW5zZm9ybWVkT3BlcmF0aW9uXSk7XG4gIH1cbiAgcmV0dXJuIFt0cmFuc2Zvcm1lZE9wZXJhdGlvbl07XG59XG5mdW5jdGlvbiBhZGp1c3RCbG9ja1BhdGgob3BlcmF0aW9uLCBsZXZlbCwgYmxvY2tJbmRleCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0geyAuLi5vcGVyYXRpb24gfTtcbiAgaWYgKGJsb2NrSW5kZXggPj0gMCAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlICE9PSBcInNldF9zZWxlY3Rpb25cIiAmJiBBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGgpICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gPj0gYmxvY2tJbmRleCArIGxldmVsICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCA+IC0xKSB7XG4gICAgY29uc3QgbmV3UGF0aCA9IFt0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdICsgbGV2ZWwsIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGguc2xpY2UoMSldO1xuICAgIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGggPSBuZXdQYXRoO1xuICB9XG4gIGlmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IChfYSA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMpICE9IG51bGwgJiYgX2EuZm9jdXMgPyB7IC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuZm9jdXMgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IChfYiA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9iLmFuY2hvciA/IHsgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcy5hbmNob3IgfSA6IHZvaWQgMCwgbmV3Rm9jdXMgPSAoX2MgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogdHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcykgIT0gbnVsbCAmJiBfYy5mb2N1cyA/IHsgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1cyB9IDogdm9pZCAwLCBuZXdBbmNob3IgPSAoX2QgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogdHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcykgIT0gbnVsbCAmJiBfZC5hbmNob3IgPyB7IC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuYW5jaG9yIH0gOiB2b2lkIDA7XG4gICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwb2ludCAmJiBwb2ludC5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiBwb2ludC5wYXRoWzBdICsgbGV2ZWwgPiAtMSAmJiAocG9pbnQucGF0aCA9IFtwb2ludC5wYXRoWzBdICsgbGV2ZWwsIC4uLnBvaW50LnBhdGguc2xpY2UoMSldKTtcbiAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmNvbnN0IHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiAhIShvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpICYmIG9wLnRleHQgIT09IFwiIFwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSwgc2hvdWxkT3ZlcndyaXRlID0gKG9wLCBwcmV2KSA9PiAhIShwcmV2ICYmIG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIHByZXYudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpLCBzaG91bGRDbGVhciA9IChvcCkgPT4gb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCI7XG5mdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzU2F2aW5nKGVkaXRvcik7XG4gIFNBVklORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldF9zZWxlY3Rpb25cIixcbiAgICBwcm9wZXJ0aWVzOiB7IC4uLmVkaXRvci5zZWxlY3Rpb24gfSxcbiAgICBuZXdQcm9wZXJ0aWVzOiB7IC4uLmVkaXRvci5zZWxlY3Rpb24gfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gIGxldCBibG9jaztcbiAgcmV0dXJuIG9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBlZGl0b3Iuc2VsZWN0aW9uID8gYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSA6IFwicGF0aFwiIGluIG9wZXJhdGlvbiAmJiAoYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSwgYmxvY2s7XG59XG5jb25zdCBkZWJ1ZyRmID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgY2hhbmdlJCxcbiAgcGF0Y2hlcyQsXG4gIHBhdGNoRnVuY3Rpb25zLFxuICByZWFkT25seSxcbiAgc2NoZW1hVHlwZXNcbn0pIHtcbiAgbGV0IHByZXZpb3VzQ2hpbGRyZW47XG4gIGNvbnN0IGFwcGx5UGF0Y2ggPSBjcmVhdGVBcHBseVBhdGNoKHNjaGVtYVR5cGVzKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuc2V0KGVkaXRvciwgITEpLCBQQVRDSElORy5zZXQoZWRpdG9yLCAhMCksIHByZXZpb3VzQ2hpbGRyZW4gPSBbLi4uZWRpdG9yLmNoaWxkcmVuXTtcbiAgICBjb25zdCB7IGFwcGx5OiBhcHBseTIgfSA9IGVkaXRvcjtcbiAgICBsZXQgYnVmZmVyZWRQYXRjaGVzID0gW107XG4gICAgY29uc3QgaGFuZGxlQnVmZmVyZWRSZW1vdGVQYXRjaGVzID0gKCkgPT4ge1xuICAgICAgaWYgKGJ1ZmZlcmVkUGF0Y2hlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXM7XG4gICAgICBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICAgIGxldCBjaGFuZ2VkID0gITE7XG4gICAgICB3aXRoUmVtb3RlQ2hhbmdlcyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICB3aXRob3V0UGF0Y2hpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoUHJlc2VydmVLZXlzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRlYnVnJGYuZW5hYmxlZCAmJiBkZWJ1ZyRmKGBIYW5kbGluZyByZW1vdGUgcGF0Y2ggJHtKU09OLnN0cmluZ2lmeShwYXRjaCl9YCksIGNoYW5nZWQgPSBhcHBseVBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgY2hhbmdlZCAmJiAoZWRpdG9yLm5vcm1hbGl6ZSgpLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9KTtcbiAgICB9LCBoYW5kbGVQYXRjaGVzID0gKHsgcGF0Y2hlcyB9KSA9PiB7XG4gICAgICBjb25zdCByZW1vdGVQYXRjaGVzID0gcGF0Y2hlcy5maWx0ZXIoKHApID0+IHAub3JpZ2luICE9PSBcImxvY2FsXCIpO1xuICAgICAgcmVtb3RlUGF0Y2hlcy5sZW5ndGggIT09IDAgJiYgKGJ1ZmZlcmVkUGF0Y2hlcyA9IGJ1ZmZlcmVkUGF0Y2hlcy5jb25jYXQocmVtb3RlUGF0Y2hlcyksIGhhbmRsZUJ1ZmZlcmVkUmVtb3RlUGF0Y2hlcygpKTtcbiAgICB9O1xuICAgIHJldHVybiBwYXRjaGVzJCAmJiBlZGl0b3Iuc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGYoXCJTdWJzY3JpYmluZyB0byBwYXRjaGVzJFwiKTtcbiAgICAgIGNvbnN0IHN1YiA9IHBhdGNoZXMkLnN1YnNjcmliZShoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGYoXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoZXMkXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChyZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGFwcGx5MihvcGVyYXRpb24pLCBlZGl0b3I7XG4gICAgICBsZXQgcGF0Y2hlcyA9IFtdO1xuICAgICAgcHJldmlvdXNDaGlsZHJlbiA9IGVkaXRvci5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IGVkaXRvcldhc0VtcHR5ID0gaXNFcXVhbFRvRW1wdHlFZGl0b3IocHJldmlvdXNDaGlsZHJlbiwgc2NoZW1hVHlwZXMpO1xuICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICBjb25zdCBlZGl0b3JJc0VtcHR5ID0gaXNFcXVhbFRvRW1wdHlFZGl0b3IoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcyk7XG4gICAgICBpZiAoIWlzUGF0Y2hpbmcoZWRpdG9yKSlcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIHN3aXRjaCAoZWRpdG9yV2FzRW1wdHkgJiYgIWVkaXRvcklzRW1wdHkgJiYgb3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIHBhdGNoZXMucHVzaChpbnNlcnQocHJldmlvdXNDaGlsZHJlbiwgXCJiZWZvcmVcIiwgWzBdKSksIG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbXG4gICAgICAgICAgICAuLi5wYXRjaGVzLFxuICAgICAgICAgICAgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0VGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKVxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfdGV4dFwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbXG4gICAgICAgICAgICAuLi5wYXRjaGVzLFxuICAgICAgICAgICAgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlVGV4dFBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKVxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbXG4gICAgICAgICAgICAuLi5wYXRjaGVzLFxuICAgICAgICAgICAgLi4ucGF0Y2hGdW5jdGlvbnMucmVtb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKVxuICAgICAgICAgIF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzcGxpdF9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFtcbiAgICAgICAgICAgIC4uLnBhdGNoZXMsXG4gICAgICAgICAgICAuLi5wYXRjaEZ1bmN0aW9ucy5zcGxpdE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbilcbiAgICAgICAgICBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5zZXJ0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gW1xuICAgICAgICAgICAgLi4ucGF0Y2hlcyxcbiAgICAgICAgICAgIC4uLnBhdGNoRnVuY3Rpb25zLmluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbilcbiAgICAgICAgICBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gW1xuICAgICAgICAgICAgLi4ucGF0Y2hlcyxcbiAgICAgICAgICAgIC4uLnBhdGNoRnVuY3Rpb25zLnNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbilcbiAgICAgICAgICBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVyZ2Vfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbXG4gICAgICAgICAgICAuLi5wYXRjaGVzLFxuICAgICAgICAgICAgLi4ucGF0Y2hGdW5jdGlvbnMubWVyZ2VOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXG4gICAgICAgICAgXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1vdmVfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbXG4gICAgICAgICAgICAuLi5wYXRjaGVzLFxuICAgICAgICAgICAgLi4ucGF0Y2hGdW5jdGlvbnMubW92ZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbilcbiAgICAgICAgICBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFlZGl0b3JXYXNFbXB0eSAmJiBlZGl0b3JJc0VtcHR5ICYmIFtcIm1lcmdlX25vZGVcIiwgXCJzZXRfbm9kZVwiLCBcInJlbW92ZV90ZXh0XCIsIFwicmVtb3ZlX25vZGVcIl0uaW5jbHVkZXMob3BlcmF0aW9uLnR5cGUpICYmIChwYXRjaGVzID0gWy4uLnBhdGNoZXMsIHVuc2V0KFtdKV0sIGNoYW5nZSQubmV4dCh7XG4gICAgICAgIHR5cGU6IFwidW5zZXRcIixcbiAgICAgICAgcHJldmlvdXNWYWx1ZTogZnJvbVNsYXRlVmFsdWUoXG4gICAgICAgICAgcHJldmlvdXNDaGlsZHJlbixcbiAgICAgICAgICBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLFxuICAgICAgICAgIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpXG4gICAgICAgIClcbiAgICAgIH0pKSwgZWRpdG9yV2FzRW1wdHkgJiYgcGF0Y2hlcy5sZW5ndGggPiAwICYmIChwYXRjaGVzID0gW3NldElmTWlzc2luZyhbXSwgW10pLCAuLi5wYXRjaGVzXSksIHBhdGNoZXMubGVuZ3RoID4gMCAmJiBwYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgIGNoYW5nZSQubmV4dCh7XG4gICAgICAgICAgdHlwZTogXCJwYXRjaFwiLFxuICAgICAgICAgIHBhdGNoOiB7IC4uLnBhdGNoLCBvcmlnaW46IFwibG9jYWxcIiB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGVkaXRvcjtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRlID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGxhY2Vob2xkZXJCbG9ja1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKCkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgeyBhcHBseTogYXBwbHkyIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcCkgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicmVtb3ZlX25vZGVcIikge1xuICAgICAgICBjb25zdCBub2RlID0gb3Aubm9kZTtcbiAgICAgICAgaWYgKG9wLnBhdGhbMF0gPT09IDAgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFBhdGggPSBQYXRoLm5leHQob3AucGF0aCk7XG4gICAgICAgICAgZWRpdG9yLmNoaWxkcmVuW25leHRQYXRoWzBdXSB8fCAoZGVidWckZShcIkFkZGluZyBwbGFjZWhvbGRlciBibG9ja1wiKSwgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlRW1wdHlCbG9jaygpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGx5MihvcCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckZCA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGVcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSh0eXBlcykge1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB0eXBlcy5zdHlsZXNbMF0udmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7IG5vcm1hbGl6ZU5vZGUgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAobm9kZUVudHJ5KSA9PiB7XG4gICAgICBub3JtYWxpemVOb2RlKG5vZGVFbnRyeSk7XG4gICAgICBjb25zdCBbLCBwYXRoXSA9IG5vZGVFbnRyeTtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2YgZWRpdG9yLm9wZXJhdGlvbnMpXG4gICAgICAgIGlmIChvcC50eXBlID09PSBcInNwbGl0X25vZGVcIiAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBlZGl0b3IuaXNUZXh0QmxvY2sob3AucHJvcGVydGllcykgJiYgb3AucHJvcGVydGllcy5zdHlsZSAhPT0gZGVmYXVsdFN0eWxlICYmIG9wLnBhdGhbMF0gPT09IHBhdGhbMF0gJiYgIVBhdGguZXF1YWxzKHBhdGgsIG9wLnBhdGgpKSB7XG4gICAgICAgICAgY29uc3QgW2NoaWxkXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgW29wLnBhdGhbMF0gKyAxLCAwXSk7XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KGNoaWxkKSAmJiBjaGlsZC50ZXh0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyRkKGBOb3JtYWxpemluZyBzcGxpdCBub2RlIHRvICR7ZGVmYXVsdFN0eWxlfSBzdHlsZWAsIG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgc3R5bGU6IGRlZmF1bHRTdHlsZSB9LCB7IGF0OiBbb3AucGF0aFswXSArIDFdLCB2b2lkczogITEgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBlZGl0b3IucHRlSGFzQmxvY2tTdHlsZSA9IChzdHlsZSkgPT4gZWRpdG9yLnNlbGVjdGlvbiA/IFtcbiAgICAgIC4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIG5vZGUuc3R5bGUgPT09IHN0eWxlXG4gICAgICB9KVxuICAgIF0ubGVuZ3RoID4gMCA6ICExLCBlZGl0b3IucHRlVG9nZ2xlQmxvY2tTdHlsZSA9IChibG9ja1N0eWxlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIChbXG4gICAgICAgIC4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgICB9KVxuICAgICAgXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmIG5vZGUuc3R5bGUgPT09IGJsb2NrU3R5bGUgPyAoZGVidWckZChgVW5zZXR0aW5nIGJsb2NrIHN0eWxlICcke2Jsb2NrU3R5bGV9J2ApLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyAuLi5ub2RlLCBzdHlsZTogZGVmYXVsdFN0eWxlIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSkgOiAoYmxvY2tTdHlsZSA/IGRlYnVnJGQoYFNldHRpbmcgc3R5bGUgJyR7YmxvY2tTdHlsZX0nYCkgOiBkZWJ1ZyRkKFwiU2V0dGluZyBkZWZhdWx0IHN0eWxlXCIsIGRlZmF1bHRTdHlsZSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBzdHlsZTogYmxvY2tTdHlsZSB8fCBkZWZhdWx0U3R5bGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgYXQ6IHBhdGggfVxuICAgICAgICApKTtcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckYyA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dExpc3RzXCIpLCBNQVhfTElTVF9MRVZFTCA9IDEwO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dExpc3RzKHR5cGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZVRvZ2dsZUxpc3RJdGVtID0gKGxpc3RJdGVtU3R5bGUpID0+IHtcbiAgICAgIGVkaXRvci5wdGVIYXNMaXN0U3R5bGUobGlzdEl0ZW1TdHlsZSkgPyAoZGVidWckYyhgUmVtb3ZlIGxpc3QgaXRlbSAnJHtsaXN0SXRlbVN0eWxlfSdgKSwgZWRpdG9yLnB0ZVVuc2V0TGlzdEl0ZW0obGlzdEl0ZW1TdHlsZSkpIDogKGRlYnVnJGMoYEFkZCBsaXN0IGl0ZW0gJyR7bGlzdEl0ZW1TdHlsZX0nYCksIGVkaXRvci5wdGVTZXRMaXN0SXRlbShsaXN0SXRlbVN0eWxlKSk7XG4gICAgfSwgZWRpdG9yLnB0ZVVuc2V0TGlzdEl0ZW0gPSAobGlzdEl0ZW1TdHlsZSkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiBbXG4gICAgICAgIC4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZVxuICAgICAgICB9KVxuICAgICAgXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSkge1xuICAgICAgICAgIGNvbnN0IHsgbGlzdEl0ZW0sIGxldmVsLCAuLi5yZXN0IH0gPSBub2RlLCBuZXdOb2RlID0ge1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGxpc3RJdGVtOiB2b2lkIDAsXG4gICAgICAgICAgICBsZXZlbDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJ1ZyRjKGBVbnNldHRpbmcgbGlzdCAnJHtsaXN0SXRlbVN0eWxlfSdgKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIG5ld05vZGUsIHsgYXQ6IHBhdGggfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5wdGVTZXRMaXN0SXRlbSA9IChsaXN0SXRlbVN0eWxlKSA9PiB7XG4gICAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIFtcbiAgICAgICAgLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICAgIH0pXG4gICAgICBdLmZvckVhY2goKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgICAgICBkZWJ1ZyRjKGBTZXR0aW5nIGxpc3QgJyR7bGlzdEl0ZW1TdHlsZX0nYCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgICAgIGxpc3RJdGVtOiBsaXN0SXRlbVN0eWxlIHx8IHR5cGVzLmxpc3RzWzBdICYmIHR5cGVzLmxpc3RzWzBdLnZhbHVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IGF0OiBwYXRoIH1cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5wdGVFbmRMaXN0ID0gKCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFtcbiAgICAgICAgLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBlZGl0b3IuaXNMaXN0QmxvY2sobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgJiYgbm9kZS5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiXG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA9PT0gMCA/ICExIDogKHNlbGVjdGVkQmxvY2tzLmZvckVhY2goKFtub2RlLCBwYXRoXSkgPT4ge1xuICAgICAgICBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIChkZWJ1ZyRjKFwiVW5zZXQgbGlzdFwiKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgIGxldmVsOiB2b2lkIDAsXG4gICAgICAgICAgICBsaXN0SXRlbTogdm9pZCAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IGF0OiBwYXRoIH1cbiAgICAgICAgKSk7XG4gICAgICB9KSwgITApO1xuICAgIH0sIGVkaXRvci5wdGVJbmNyZW1lbnRCbG9ja0xldmVscyA9IChyZXZlcnNlKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gW1xuICAgICAgICAuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiAhIWVkaXRvci5pc0xpc3RCbG9jayhub2RlKVxuICAgICAgICB9KVxuICAgICAgXTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPT09IDAgPyAhMSA6IChzZWxlY3RlZEJsb2Nrcy5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgaWYgKGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSkge1xuICAgICAgICAgIGxldCBsZXZlbCA9IG5vZGUubGV2ZWwgfHwgMTtcbiAgICAgICAgICByZXZlcnNlID8gKGxldmVsLS0sIGRlYnVnJGMoXCJEZWNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpIDogKGxldmVsKyssIGRlYnVnJGMoXCJJbmNyZW1lbnRpbmcgbGlzdCBsZXZlbFwiLCBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgbGV2ZWwpKSkpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgeyBsZXZlbDogTWF0aC5taW4oTUFYX0xJU1RfTEVWRUwsIE1hdGgubWF4KDEsIGxldmVsKSkgfSxcbiAgICAgICAgICAgIHsgYXQ6IHBhdGggfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pLCAhMCk7XG4gICAgfSwgZWRpdG9yLnB0ZUhhc0xpc3RTdHlsZSA9IChsaXN0U3R5bGUpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbXG4gICAgICAgIC4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgICB9KVxuICAgICAgXTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEJsb2Nrcy5sZW5ndGggPiAwID8gc2VsZWN0ZWRCbG9ja3MuZXZlcnkoXG4gICAgICAgIChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0U3R5bGVcbiAgICAgICkgOiAhMTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRiID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCh0eXBlcywgY2hhbmdlJCkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgeyBhcHBseTogYXBwbHkyLCBub3JtYWxpemVOb2RlIH0gPSBlZGl0b3IsIGRlY29yYXRvcnMgPSB0eXBlcy5kZWNvcmF0b3JzLm1hcCgodCkgPT4gdC52YWx1ZSksIGZvcmNlTmV3U2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnNlbGVjdGlvbiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7IC4uLmVkaXRvci5zZWxlY3Rpb24gfSksIGVkaXRvci5zZWxlY3Rpb24gPSB7IC4uLmVkaXRvci5zZWxlY3Rpb24gfSk7XG4gICAgICBjb25zdCBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZShlZGl0b3IuY2hpbGRyZW4sIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKTtcbiAgICAgIGNoYW5nZSQubmV4dCh7IHR5cGU6IFwic2VsZWN0aW9uXCIsIHNlbGVjdGlvbjogcHRSYW5nZSB9KTtcbiAgICB9O1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KSwgZWRpdG9yLm9wZXJhdGlvbnMuc29tZShcbiAgICAgICAgKG9wKSA9PiBbXG4gICAgICAgICAgXCJpbnNlcnRfbm9kZVwiLFxuICAgICAgICAgIFwiaW5zZXJ0X3RleHRcIixcbiAgICAgICAgICBcIm1lcmdlX25vZGVcIixcbiAgICAgICAgICBcInJlbW92ZV9ub2RlXCIsXG4gICAgICAgICAgXCJyZW1vdmVfdGV4dFwiLFxuICAgICAgICAgIFwic2V0X25vZGVcIlxuICAgICAgICBdLmluY2x1ZGVzKG9wLnR5cGUpXG4gICAgICApICYmIG1lcmdlU3BhbnMoZWRpdG9yKTtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IG5vZGVFbnRyeSwgaXNTcGFuID0gVGV4dC5pc1RleHQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lLCBpc1RleHRCbG9jayA9IGVkaXRvci5pc1RleHRCbG9jayhub2RlKTtcbiAgICAgIGlmIChpc1NwYW4gfHwgaXNUZXh0QmxvY2spIHtcbiAgICAgICAgaWYgKGlzU3BhbiAmJiAhQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiAoZGVidWckYihcIkFkZGluZyAubWFya3MgdG8gc3BhbiBub2RlXCIpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyBtYXJrczogW10gfSwgeyBhdDogcGF0aCB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpLCBpc1NwYW4gJiYgKG5vZGUubWFya3MgfHwgW10pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBzcGFuTWFya3MgPSBub2RlLm1hcmtzIHx8IEVNUFRZX01BUktTJDEsIGFubm90YXRpb25NYXJrcyA9IHNwYW5NYXJrcy5maWx0ZXIoXG4gICAgICAgICAgICAobWFyaykgPT4gIXR5cGVzLmRlY29yYXRvcnMubWFwKChkZWMpID0+IGRlYy52YWx1ZSkuaW5jbHVkZXMobWFyaylcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9uTWFya3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5wYXJlbnQocGF0aCkpLCBvcnBoYW5lZE1hcmtzID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBhbm5vdGF0aW9uTWFya3MuZmlsdGVyKFxuICAgICAgICAgICAgICAobWFyaykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoX2EgPSBibG9jay5tYXJrRGVmcykgIT0gbnVsbCAmJiBfYS5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkgfHwgW107XG4gICAgICAgICAgICBvcnBoYW5lZE1hcmtzLmxlbmd0aCA+IDAgJiYgKGRlYnVnJGIoXCJSZW1vdmluZyBvcnBoYW5lZCAubWFya3MgZnJvbSBzcGFuIG5vZGVcIiksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgeyBtYXJrczogc3Bhbk1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkTWFya3MuaW5jbHVkZXMobWFyaykpIH0sXG4gICAgICAgICAgICAgIHsgYXQ6IHBhdGggfVxuICAgICAgICAgICAgKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIGVkaXRvci5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUgJiYgQXJyYXkuaXNBcnJheShvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzKSAmJiBvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgb3AucGF0aFswXSAtIDEgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgW3RhcmdldEJsb2NrLCB0YXJnZXRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgW29wLnBhdGhbMF0gLSAxXSk7XG4gICAgICAgICAgICBpZiAoZGVidWckYihcIkNvcHlpbmcgbWFya0RlZnMgb3ZlciB0byBtZXJnZWQgYmxvY2tcIiwgb3ApLCBlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZERlZnMgPSBBcnJheS5pc0FycmF5KHRhcmdldEJsb2NrLm1hcmtEZWZzKSAmJiB0YXJnZXRCbG9jay5tYXJrRGVmcyB8fCBbXSwgbmV3TWFya0RlZnMgPSB1bmlxKFsuLi5vbGREZWZzLCAuLi5vcC5wcm9wZXJ0aWVzLm1hcmtEZWZzXSk7XG4gICAgICAgICAgICAgIGlzRXF1YWwobmV3TWFya0RlZnMsIHRhcmdldEJsb2NrLm1hcmtEZWZzKSB8fCAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgbWFya0RlZnM6IG5ld01hcmtEZWZzIH0sIHsgYXQ6IHRhcmdldFBhdGgsIHZvaWRzOiAhMSB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIgJiYgb3AucGF0aC5sZW5ndGggPT09IDEgJiYgRWxlbWVudCQxLmlzRWxlbWVudFByb3BzKG9wLnByb3BlcnRpZXMpICYmIG9wLnByb3BlcnRpZXMuX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWUgJiYgXCJtYXJrRGVmc1wiIGluIG9wLnByb3BlcnRpZXMgJiYgQXJyYXkuaXNBcnJheShvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzKSAmJiBvcC5wcm9wZXJ0aWVzLm1hcmtEZWZzLmxlbmd0aCA+IDAgJiYgb3AucGF0aFswXSArIDEgPCBlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBbdGFyZ2V0QmxvY2ssIHRhcmdldFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDFdKTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyRiKFwiQ29weWluZyBtYXJrRGVmcyBvdmVyIHRvIHNwbGl0IGJsb2NrXCIsIG9wKSwgZWRpdG9yLmlzVGV4dEJsb2NrKHRhcmdldEJsb2NrKSkge1xuICAgICAgICAgICAgICBjb25zdCBvbGREZWZzID0gQXJyYXkuaXNBcnJheSh0YXJnZXRCbG9jay5tYXJrRGVmcykgJiYgdGFyZ2V0QmxvY2subWFya0RlZnMgfHwgW107XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHsgbWFya0RlZnM6IHVuaXEoWy4uLm9sZERlZnMsIC4uLm9wLnByb3BlcnRpZXMubWFya0RlZnNdKSB9LFxuICAgICAgICAgICAgICAgIHsgYXQ6IHRhcmdldFBhdGgsIHZvaWRzOiAhMSB9XG4gICAgICAgICAgICAgICksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIgJiYgb3AucGF0aC5sZW5ndGggPT09IDIgJiYgb3AucHJvcGVydGllcy5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIFwibWFya3NcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkob3AucHJvcGVydGllcy5tYXJrcykgJiYgb3AucHJvcGVydGllcy5tYXJrcy5sZW5ndGggPiAwICYmIG9wLnBhdGhbMF0gKyAxIDwgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICAgIFRleHQuaXNUZXh0KGNoaWxkKSAmJiBjaGlsZC50ZXh0ID09PSBcIlwiICYmIEFycmF5LmlzQXJyYXkoY2hpbGQubWFya3MpICYmIGNoaWxkLm1hcmtzLmxlbmd0aCA+IDAgJiYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IG1hcmtzOiBbXSB9LCB7IGF0OiBjaGlsZFBhdGgsIHZvaWRzOiAhMSB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gXCJzcGxpdF9ub2RlXCIgJiYgb3AucGF0aC5sZW5ndGggPT09IDEgJiYgb3AucHJvcGVydGllcy5fdHlwZSA9PT0gdHlwZXMuYmxvY2submFtZSAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KG9wLnByb3BlcnRpZXMubWFya0RlZnMpICYmIG9wLnByb3BlcnRpZXMubWFya0RlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXV0pO1xuICAgICAgICAgICAgZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgYmxvY2subWFya0RlZnMgJiYgYmxvY2subWFya0RlZnMubGVuZ3RoID4gMCAmJiBUZXh0LmlzVGV4dChibG9jay5jaGlsZHJlblswXSkgJiYgYmxvY2suY2hpbGRyZW5bMF0udGV4dCA9PT0gXCJcIiAmJiAoIWJsb2NrLmNoaWxkcmVuWzBdLm1hcmtzIHx8IGJsb2NrLmNoaWxkcmVuWzBdLm1hcmtzLmxlbmd0aCA9PT0gMCkgJiYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IG1hcmtEZWZzOiBbXSB9LCB7IGF0OiBibG9ja1BhdGggfSksIGVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTcGFuICYmIEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgKCFub2RlLm1hcmtzIHx8IG5vZGUubWFya3MubGVuZ3RoID4gMCAmJiBub2RlLnRleHQgPT09IFwiXCIpICYmIChUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyBtYXJrczogW10gfSwgeyBhdDogcGF0aCwgdm9pZHM6ICExIH0pLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmICFlZGl0b3Iub3BlcmF0aW9ucy5zb21lKFxuICAgICAgICAob3ApID0+IG9wLnR5cGUgPT09IFwibWVyZ2Vfbm9kZVwiICYmIFwibWFya0RlZnNcIiBpbiBvcC5wcm9wZXJ0aWVzICYmIG9wLnBhdGgubGVuZ3RoID09PSAxXG4gICAgICApKSB7XG4gICAgICAgIGNvbnN0IG5ld01hcmtEZWZzID0gKG5vZGUubWFya0RlZnMgfHwgW10pLmZpbHRlcigoZGVmKSA9PiBub2RlLmNoaWxkcmVuLmZpbmQoKGNoaWxkKSA9PiBUZXh0LmlzVGV4dChjaGlsZCkgJiYgQXJyYXkuaXNBcnJheShjaGlsZC5tYXJrcykgJiYgY2hpbGQubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpKSk7XG4gICAgICAgIG5vZGUubWFya0RlZnMgJiYgIWlzRXF1YWwobmV3TWFya0RlZnMsIG5vZGUubWFya0RlZnMpICYmIChkZWJ1ZyRiKFwiUmVtb3ZpbmcgbWFya0RlZiBub3QgaW4gdXNlXCIpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgYXQ6IHBhdGggfVxuICAgICAgICApLCBlZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfSwgZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIikge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgKF9iID0gKF9hID0gRWRpdG9yLm1hcmtzKGVkaXRvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrcykgIT0gbnVsbCAmJiBfYi5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkpIHtcbiAgICAgICAgICBjb25zdCBbbm9kZV0gPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgICBhdDogc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgICBtYXRjaDogKG4pID0+IG4uX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClbMF0gfHwgW3ZvaWQgMF07XG4gICAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIG5vZGUudGV4dC5sZW5ndGggPT09IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgJiYgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGFwcGx5MihvcCksIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICAgICAgICBhdDogeyAuLi5zZWxlY3Rpb24uZm9jdXMsIG9mZnNldDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldCB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzV2l0aG91dEFubm90YXRpb25NYXJrcyA9ICh7XG4gICAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgICAgICB9Lm1hcmtzIHx8IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICB7IG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uTWFya3MgfSxcbiAgICAgICAgICAgICAgeyBhdDogUGF0aC5uZXh0KHNlbGVjdGlvbi5mb2N1cy5wYXRoKSB9XG4gICAgICAgICAgICApLCBkZWJ1ZyRiKFwiSW5zZXJ0aW5nIHRleHQgYXQgZW5kIG9mIGFubm90YXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvci5hZGRNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7IG1hdGNoOiBUZXh0LmlzVGV4dCwgc3BsaXQ6ICEwIH0pO1xuICAgICAgICAgIGNvbnN0IHNwbGl0VGV4dE5vZGVzID0gW1xuICAgICAgICAgICAgLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwgeyBhdDogZWRpdG9yLnNlbGVjdGlvbiwgbWF0Y2g6IFRleHQuaXNUZXh0IH0pXG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoc3BsaXRUZXh0Tm9kZXMuZXZlcnkoKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBub2RlWzBdLm1hcmtzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5jbHVkZXMobWFyayk7XG4gICAgICAgICAgfSkpXG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yLnJlbW92ZU1hcmsobWFyayksIGVkaXRvcjtcbiAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgc3BsaXRUZXh0Tm9kZXMuZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gW1xuICAgICAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAoZU1hcmspID0+IGVNYXJrICE9PSBtYXJrXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBtYXJrXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHsgbWFya3MgfSxcbiAgICAgICAgICAgICAgICB7IGF0OiBwYXRoLCBtYXRjaDogVGV4dC5pc1RleHQsIHNwbGl0OiAhMCwgaGFuZ2luZzogITAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSksIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzID0ge1xuICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgICB9Lm1hcmtzIHx8IFtdLCBtYXJrcyA9IHtcbiAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LFxuICAgICAgICAgICAgbWFya3M6IFsuLi5leGlzdGluZ01hcmtzLCBtYXJrXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGVkaXRvci5tYXJrcyA9IG1hcmtzLCBmb3JjZU5ld1NlbGVjdGlvbigpLCBlZGl0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCksIGZvcmNlTmV3U2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sIGVkaXRvci5yZW1vdmVNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpXG4gICAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwgeyBtYXRjaDogVGV4dC5pc1RleHQsIHNwbGl0OiAhMCB9KSwgZWRpdG9yLnNlbGVjdGlvbiAmJiBbXG4gICAgICAgICAgICAgIC4uLkVkaXRvci5ub2RlcyhlZGl0b3IsIHsgYXQ6IGVkaXRvci5zZWxlY3Rpb24sIG1hdGNoOiBUZXh0LmlzVGV4dCB9KVxuICAgICAgICAgICAgXS5mb3JFYWNoKChbbm9kZSwgcGF0aF0pID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bcGF0aFswXV07XG4gICAgICAgICAgICAgIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spICYmIGJsb2NrLmNoaWxkcmVuLmluY2x1ZGVzKG5vZGUpICYmIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiAoQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSA/IG5vZGUubWFya3MgOiBbXSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAoZU1hcmspID0+IGVNYXJrICE9PSBtYXJrXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGF0OiBwYXRoIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLCBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgICAgIH0ubWFya3MgfHwgW10sIG1hcmtzID0ge1xuICAgICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyaylcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBlZGl0b3IubWFya3MgPSB7IG1hcmtzOiBtYXJrcy5tYXJrcywgX3R5cGU6IFwic3BhblwiIH0sIGZvcmNlTmV3U2VsZWN0aW9uKCksIGVkaXRvcjtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKSwgZm9yY2VOZXdTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfSwgZWRpdG9yLnB0ZUlzTWFya0FjdGl2ZSA9IChtYXJrKSA9PiB7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBBcnJheS5mcm9tKFxuICAgICAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7IG1hdGNoOiBUZXh0LmlzVGV4dCwgYXQ6IGVkaXRvci5zZWxlY3Rpb24gfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSA/IHNlbGVjdGVkTm9kZXMuZXZlcnkoKG4pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBbbm9kZV0gPSBuO1xuICAgICAgICByZXR1cm4gKF9hID0gbm9kZS5tYXJrcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKG1hcmspO1xuICAgICAgfSkgOiAoe1xuICAgICAgICAuLi5FZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fVxuICAgICAgfS5tYXJrcyB8fCBbXSkuaW5jbHVkZXMobWFyayk7XG4gICAgfSwgZWRpdG9yLnB0ZVRvZ2dsZU1hcmsgPSAobWFyaykgPT4ge1xuICAgICAgZWRpdG9yLnB0ZUlzTWFya0FjdGl2ZShtYXJrKSA/IChkZWJ1ZyRiKGBSZW1vdmUgbWFyayAnJHttYXJrfSdgKSwgRWRpdG9yLnJlbW92ZU1hcmsoZWRpdG9yLCBtYXJrKSkgOiAoZGVidWckYihgQWRkIG1hcmsgJyR7bWFya30nYCksIEVkaXRvci5hZGRNYXJrKGVkaXRvciwgbWFyaywgITApKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG4gIGZ1bmN0aW9uIG1lcmdlU3BhbnMoZWRpdG9yKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcbiAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgZm9yIChjb25zdCBbbm9kZSwgcGF0aF0gb2YgQXJyYXkuZnJvbShcbiAgICAgICAgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBbc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdXSwgW3NlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSlcbiAgICAgICAgfSlcbiAgICAgICkucmV2ZXJzZSgpKSB7XG4gICAgICAgIGNvbnN0IFtwYXJlbnRdID0gcGF0aC5sZW5ndGggPiAxID8gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLnBhcmVudChwYXRoKSkgOiBbdm9pZCAwXSwgbmV4dFBhdGggPSBbcGF0aFswXSwgcGF0aFsxXSArIDFdO1xuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKHBhcmVudCkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHBhcmVudC5jaGlsZHJlbltuZXh0UGF0aFsxXV07XG4gICAgICAgICAgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQobmV4dE5vZGUpICYmIGlzRXF1YWwobmV4dE5vZGUubWFya3MsIG5vZGUubWFya3MpICYmIChkZWJ1ZyRiKFwiTWVyZ2luZyBzcGFuc1wiKSwgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwgeyBhdDogbmV4dFBhdGgsIHZvaWRzOiAhMCB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cbn1cbmNvbnN0IGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zXCIpLCBkZWJ1Z1ZlcmJvc2UkMSA9IGRlYnVnJGEuZW5hYmxlZCAmJiAhMTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGNoYW5nZSQsIHR5cGVzKSB7XG4gIGxldCBwcmV2U2VsZWN0aW9uID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IGVtaXRQb3J0YWJsZVRleHRTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgICBpZiAocHJldlNlbGVjdGlvbiAhPT0gZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBsZXQgcHRSYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLmdldChlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmcpXG4gICAgICAgICAgICBwdFJhbmdlID0gZXhpc3Rpbmc7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVkaXRvci5jaGlsZHJlbjtcbiAgICAgICAgICAgIHB0UmFuZ2UgPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0Uuc2V0KGVkaXRvci5zZWxlY3Rpb24sIHB0UmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z1ZlcmJvc2UkMSAmJiBkZWJ1ZyRhKFxuICAgICAgICAgIGBFbWl0dGluZyBzZWxlY3Rpb24gJHtKU09OLnN0cmluZ2lmeShwdFJhbmdlIHx8IG51bGwpfSAoJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgICApfSlgXG4gICAgICAgICksIHB0UmFuZ2UgPyBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcInNlbGVjdGlvblwiLCBzZWxlY3Rpb246IHB0UmFuZ2UgfSkgOiBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcInNlbGVjdGlvblwiLCBzZWxlY3Rpb246IG51bGwgfSk7XG4gICAgICB9XG4gICAgICBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB9LCB7IG9uQ2hhbmdlIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0NoYW5nZXMgPSBlZGl0b3Iub3BlcmF0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgb25DaGFuZ2UoKSwgaGFzQ2hhbmdlcyAmJiBlbWl0UG9ydGFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckOSA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFNjaGVtYVR5cGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFNjaGVtYVR5cGVzKHtcbiAgc2NoZW1hVHlwZXMsXG4gIGtleUdlbmVyYXRvclxufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgZWRpdG9yLmlzVGV4dEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1RleHRTcGFuID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dFNwYW4odmFsdWUpICYmIHZhbHVlLl90eXBlID09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgZWRpdG9yLmlzTGlzdEJsb2NrID0gKHZhbHVlKSA9PiBpc1BvcnRhYmxlVGV4dExpc3RCbG9jayh2YWx1ZSkgJiYgdmFsdWUuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIGVkaXRvci5pc1ZvaWQgPSAoZWxlbWVudCkgPT4gc2NoZW1hVHlwZXMuYmxvY2submFtZSAhPT0gZWxlbWVudC5fdHlwZSAmJiAoc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgfHwgc2NoZW1hVHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpKSwgZWRpdG9yLmlzSW5saW5lID0gKGVsZW1lbnQpID0+IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSAmJiBcIl9faW5saW5lXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50Ll9faW5saW5lID09PSAhMDtcbiAgICBjb25zdCB7IG5vcm1hbGl6ZU5vZGUgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKG5vZGUuX3R5cGUgPT09IHZvaWQgMCAmJiBwYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBkZWJ1ZyQ5KFwiU2V0dGluZyBzcGFuIHR5cGUgb24gdGV4dCBub2RlIHdpdGhvdXQgYSB0eXBlXCIpO1xuICAgICAgICBjb25zdCBzcGFuID0gbm9kZSwga2V5ID0gc3Bhbi5fa2V5IHx8IGtleUdlbmVyYXRvcigpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgeyAuLi5zcGFuLCBfdHlwZTogc2NoZW1hVHlwZXMuc3Bhbi5uYW1lLCBfa2V5OiBrZXkgfSwgeyBhdDogcGF0aCB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLl9rZXkgPT09IHZvaWQgMCAmJiAocGF0aC5sZW5ndGggPT09IDEgfHwgcGF0aC5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgIGRlYnVnJDkoXCJTZXR0aW5nIG1pc3Npbmcga2V5IG9uIGNoaWxkIG5vZGUgd2l0aG91dCBhIGtleVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7IF9rZXk6IGtleSB9LCB7IGF0OiBwYXRoIH0pO1xuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckOCA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFV0aWxzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFV0aWxzKHsgc2NoZW1hVHlwZXMsIGtleUdlbmVyYXRvciwgcG9ydGFibGVUZXh0RWRpdG9yIH0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlRXhwYW5kVG9Xb3JkID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvcjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBbdGV4dE5vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMsIHsgZGVwdGg6IDIgfSk7XG4gICAgICAgIGlmICghdGV4dE5vZGUgfHwgIVRleHQuaXNUZXh0KHRleHROb2RlKSB8fCB0ZXh0Tm9kZS50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnJDgoXCJwdGVFeHBhbmRUb1dvcmQ6IENhbid0IGV4cGFuZCB0byB3b3JkIGhlcmVcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZm9jdXMgfSA9IHNlbGVjdGlvbiwgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQsIGNoYXJzQmVmb3JlID0gdGV4dE5vZGUudGV4dC5zbGljZSgwLCBmb2N1c09mZnNldCksIGNoYXJzQWZ0ZXIgPSB0ZXh0Tm9kZS50ZXh0LnNsaWNlKGZvY3VzT2Zmc2V0LCAtMSksIGlzRW1wdHkgPSAoc3RyKSA9PiBzdHIubWF0Y2goL1xccy9nKSwgd2hpdGVTcGFjZUJlZm9yZUluZGV4ID0gY2hhcnNCZWZvcmUuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmZpbmRJbmRleCgoc3RyKSA9PiBpc0VtcHR5KHN0cikpLCBuZXdTdGFydE9mZnNldCA9IHdoaXRlU3BhY2VCZWZvcmVJbmRleCA+IC0xID8gY2hhcnNCZWZvcmUubGVuZ3RoIC0gd2hpdGVTcGFjZUJlZm9yZUluZGV4IDogMCwgd2hpdGVTcGFjZUFmdGVySW5kZXggPSBjaGFyc0FmdGVyLnNwbGl0KFwiXCIpLmZpbmRJbmRleCgob2JqKSA9PiBpc0VtcHR5KG9iaikpLCBuZXdFbmRPZmZzZXQgPSBjaGFyc0JlZm9yZS5sZW5ndGggKyAod2hpdGVTcGFjZUFmdGVySW5kZXggPiAtMSA/IHdoaXRlU3BhY2VBZnRlckluZGV4IDogY2hhcnNBZnRlci5sZW5ndGggKyAxKTtcbiAgICAgICAgaWYgKCEobmV3U3RhcnRPZmZzZXQgPT09IG5ld0VuZE9mZnNldCB8fCBpc05hTihuZXdTdGFydE9mZnNldCkgfHwgaXNOYU4obmV3RW5kT2Zmc2V0KSkpIHtcbiAgICAgICAgICBkZWJ1ZyQ4KFwicHRlRXhwYW5kVG9Xb3JkOiBFeHBhbmRpbmcgdG8gZm9jdXNlZCB3b3JkXCIpLCBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogeyAuLi5zZWxlY3Rpb24uYW5jaG9yLCBvZmZzZXQ6IG5ld1N0YXJ0T2Zmc2V0IH0sXG4gICAgICAgICAgICBmb2N1czogeyAuLi5zZWxlY3Rpb24uZm9jdXMsIG9mZnNldDogbmV3RW5kT2Zmc2V0IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWckOChcInB0ZUV4cGFuZFRvV29yZDogQ2FuJ3QgZXhwYW5kIHRvIHdvcmQgaGVyZVwiKTtcbiAgICAgIH1cbiAgICB9LCBlZGl0b3IucHRlQ3JlYXRlRW1wdHlCbG9jayA9ICgpID0+IHRvU2xhdGVWYWx1ZShcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIF90eXBlOiBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIHN0eWxlOiBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUgfHwgXCJub3JtYWxcIixcbiAgICAgICAgICBtYXJrRGVmczogW10sXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcG9ydGFibGVUZXh0RWRpdG9yXG4gICAgKVswXSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckNyA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aEhvdEtleXNcIiksIERFRkFVTFRfSE9US0VZUyA9IHtcbiAgbWFya3M6IHtcbiAgICBcIm1vZCtiXCI6IFwic3Ryb25nXCIsXG4gICAgXCJtb2QraVwiOiBcImVtXCIsXG4gICAgXCJtb2QrdVwiOiBcInVuZGVybGluZVwiLFxuICAgIFwibW9kKydcIjogXCJjb2RlXCJcbiAgfSxcbiAgY3VzdG9tOiB7fVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhIb3RrZXlzKHR5cGVzLCBwb3J0YWJsZVRleHRFZGl0b3IsIGhvdGtleXNGcm9tT3B0aW9ucykge1xuICBjb25zdCByZXNlcnZlZEhvdGtleXMgPSBbXCJlbnRlclwiLCBcInRhYlwiLCBcInNoaWZ0XCIsIFwiZGVsZXRlXCIsIFwiZW5kXCJdLCBhY3RpdmVIb3RrZXlzID0gaG90a2V5c0Zyb21PcHRpb25zIHx8IERFRkFVTFRfSE9US0VZUztcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucHRlV2l0aEhvdEtleXMgPSAoZXZlbnQpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgIE9iamVjdC5rZXlzKGFjdGl2ZUhvdGtleXMpLmZvckVhY2goKGNhdCkgPT4ge1xuICAgICAgICBpZiAoY2F0ID09PSBcIm1hcmtzXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVNYXJrID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVNYXJrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyayA9IHBvc3NpYmxlTWFya1tob3RrZXldO1xuICAgICAgICAgICAgICAgIGRlYnVnJDcoYEhvdEtleSAke2hvdGtleX0gdG8gdG9nZ2xlICR7bWFya31gKSwgZWRpdG9yLnB0ZVRvZ2dsZU1hcmsobWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChjYXQgPT09IFwiY3VzdG9tXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDb21tYW5kID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHBvc3NpYmxlQ29tbWFuZFtob3RrZXldO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQoZXZlbnQsIHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzRW50ZXIgPSBpc0hvdGtleShcImVudGVyXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNUYWIgPSBpc0hvdGtleShcInRhYlwiLCBldmVudC5uYXRpdmVFdmVudCksIGlzU2hpZnRFbnRlciA9IGlzSG90a2V5KFwic2hpZnQrZW50ZXJcIiwgZXZlbnQubmF0aXZlRXZlbnQpLCBpc1NoaWZ0VGFiID0gaXNIb3RrZXkoXCJzaGlmdCt0YWJcIiwgZXZlbnQubmF0aXZlRXZlbnQpLCBpc0JhY2tzcGFjZSA9IGlzSG90a2V5KFwiYmFja3NwYWNlXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNEZWxldGUgPSBpc0hvdGtleShcImRlbGV0ZVwiLCBldmVudC5uYXRpdmVFdmVudCksIGlzQXJyb3dEb3duID0gaXNIb3RrZXkoXCJkb3duXCIsIGV2ZW50Lm5hdGl2ZUV2ZW50KSwgaXNBcnJvd1VwID0gaXNIb3RrZXkoXCJ1cFwiLCBldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICBpZiAoaXNBcnJvd0Rvd24gJiYgZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBmb2N1c0Jsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGZvY3VzQmxvY2sgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGZvY3VzQmxvY2spKSB7XG4gICAgICAgICAgY29uc3QgbmV4dFBhdGggPSBQYXRoLm5leHQoZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgICBpZiAoIU5vZGUuaGFzKGVkaXRvciwgbmV4dFBhdGgpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZUVtcHR5QmxvY2soKSwgeyBhdDogbmV4dFBhdGggfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQXJyb3dVcCAmJiBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RCbG9jayA9IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSA9PT0gMCwgZm9jdXNCbG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChpc0ZpcnN0QmxvY2sgJiYgZm9jdXNCbG9jayAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgZm9jdXNCbG9jaykpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZUVtcHR5QmxvY2soKSwgeyBhdDogWzBdIH0pLCBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHsgcGF0aDogWzAsIDBdLCBvZmZzZXQ6IDAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQmFja3NwYWNlICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdID09PSAwICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpLCBuZXh0UGF0aCA9IFBhdGgubmV4dChlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpLCBuZXh0QmxvY2sgPSBOb2RlLmhhcyhlZGl0b3IsIG5leHRQYXRoKSwgaXNUZXh0QmxvY2sgPSBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhmb2N1c0Jsb2NrKSwgaXNFbXB0eUZvY3VzQmxvY2sgPSBpc1RleHRCbG9jayAmJiBmb2N1c0Jsb2NrLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiAoKF9iID0gKF9hID0gZm9jdXNCbG9jay5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IudGV4dCkgPT09IFwiXCI7XG4gICAgICAgIGlmIChuZXh0QmxvY2sgJiYgaXNUZXh0QmxvY2sgJiYgaXNFbXB0eUZvY3VzQmxvY2spIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHsgbWF0Y2g6IChuKSA9PiBuID09PSBmb2N1c0Jsb2NrIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0JhY2tzcGFjZSAmJiBlZGl0b3Iuc2VsZWN0aW9uICYmIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSA+IDAgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSksIHByZXZCbG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIHByZXZQYXRoKSwgZm9jdXNCbG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChwcmV2QmxvY2sgJiYgZm9jdXNCbG9jayAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgcHJldkJsb2NrKSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGRlYnVnJDcoXCJQcmV2ZW50aW5nIGRlbGV0aW5nIHZvaWQgYmxvY2sgYWJvdmVcIiksIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGNvbnN0IGlzVGV4dEJsb2NrID0gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jayksIGlzRW1wdHlGb2N1c0Jsb2NrID0gaXNUZXh0QmxvY2sgJiYgZm9jdXNCbG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgKChfZCA9IChfYyA9IGZvY3VzQmxvY2suY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRleHQpID09PSBcIlwiO1xuICAgICAgICAgIGlmICghaXNUZXh0QmxvY2sgfHwgaXNFbXB0eUZvY3VzQmxvY2spIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IG1hdGNoOiAobikgPT4gbiA9PT0gZm9jdXNCbG9jayB9KSwgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwcmV2UGF0aCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUZXh0QmxvY2sgJiYgIWlzRW1wdHlGb2N1c0Jsb2NrKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHByZXZQYXRoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVsZXRlICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IDAgJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgJiYgZWRpdG9yLmNoaWxkcmVuW2VkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSArIDFdKSB7XG4gICAgICAgIGNvbnN0IG5leHRCbG9jayA9IE5vZGUuZGVzY2VuZGFudChcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgUGF0aC5uZXh0KGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSlcbiAgICAgICAgKSwgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gICAgICAgIGlmIChuZXh0QmxvY2sgJiYgZm9jdXNCbG9jayAmJiAhRWRpdG9yLmlzVm9pZChlZGl0b3IsIGZvY3VzQmxvY2spICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuZXh0QmxvY2spKSB7XG4gICAgICAgICAgZGVidWckNyhcIlByZXZlbnRpbmcgZGVsZXRpbmcgdm9pZCBibG9jayBiZWxvd1wiKSwgZXZlbnQucHJldmVudERlZmF1bHQoKSwgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IG1hdGNoOiAobikgPT4gbiA9PT0gZm9jdXNCbG9jayB9KSwgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChpc1RhYiB8fCBpc1NoaWZ0VGFiKSAmJiBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IFtmb2N1c0NoaWxkXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cywgeyBkZXB0aDogMiB9KSwgW2ZvY3VzQmxvY2tdID0gaXNQb3J0YWJsZVRleHRTcGFuKGZvY3VzQ2hpbGQpID8gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLCB7IGRlcHRoOiAxIH0pIDogW10sIGhhc0Fubm90YXRpb25Gb2N1cyA9IGZvY3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jaykgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGZvY3VzQ2hpbGQpICYmIChmb2N1c0NoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoXG4gICAgICAgICAgKG0pID0+IChmb2N1c0Jsb2NrLm1hcmtEZWZzIHx8IFtdKS5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmluY2x1ZGVzKG0pXG4gICAgICAgICkubGVuZ3RoID4gMCwgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKGVkaXRvci5zZWxlY3Rpb24pLCBhdFN0YXJ0T2ZOb2RlID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBzdGFydCwgc3RhcnQucGF0aCk7XG4gICAgICAgIGZvY3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGZvY3VzQ2hpbGQpICYmICghaGFzQW5ub3RhdGlvbkZvY3VzIHx8IGF0U3RhcnRPZk5vZGUpICYmIGVkaXRvci5wdGVJbmNyZW1lbnRCbG9ja0xldmVscyhpc1NoaWZ0VGFiKSAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW50ZXIgJiYgIWlzU2hpZnRFbnRlciAmJiBlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzQmxvY2tQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLCBmb2N1c0Jsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgICBpZiAoZWRpdG9yLmlzTGlzdEJsb2NrKGZvY3VzQmxvY2spKSB7XG4gICAgICAgICAgZWRpdG9yLnB0ZUVuZExpc3QoKSAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKGZvY3VzQmxvY2spICYmIGZvY3VzQmxvY2suc3R5bGUgJiYgZm9jdXNCbG9jay5zdHlsZSAhPT0gdHlwZXMuc3R5bGVzWzBdLnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBlbmQsIGVuZC5wYXRoKSkge1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlRW1wdHlCbG9jaygpKSwgZXZlbnQucHJldmVudERlZmF1bHQoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1c0Jsb2NrICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBmb2N1c0Jsb2NrKSkge1xuICAgICAgICAgIEVkaXRvci5pbnNlcnROb2RlKGVkaXRvciwgZWRpdG9yLnB0ZUNyZWF0ZUVtcHR5QmxvY2soKSksIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBlZGl0b3IuaW5zZXJ0QnJlYWsoKSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaGlmdEVudGVyKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGVkaXRvci5pbnNlcnRUZXh0KGBcbmApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNIb3RrZXkoXCJtb2QrelwiLCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKSwgZWRpdG9yLnVuZG8oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKGlzSG90a2V5KFwibW9kK3lcIiwgZXZlbnQubmF0aXZlRXZlbnQpIHx8IGlzSG90a2V5KFwibW9kK3NoaWZ0K3pcIiwgZXZlbnQubmF0aXZlRXZlbnQpKSAmJiAoZXZlbnQucHJldmVudERlZmF1bHQoKSwgZWRpdG9yLnJlZG8oKSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSwgdHlwZXMsIGtleUdlbmVyYXRvcikge1xuICBsZXQgcmVzb2x1dGlvbiA9IG51bGwsIHZhbGlkID0gITA7XG4gIGNvbnN0IHZhbGlkQ2hpbGRUeXBlcyA9IFt0eXBlcy5zcGFuLm5hbWUsIC4uLnR5cGVzLmlubGluZU9iamVjdHMubWFwKCh0KSA9PiB0Lm5hbWUpXSwgdmFsaWRCbG9ja1R5cGVzID0gW3R5cGVzLmJsb2NrLm5hbWUsIC4uLnR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHsgdmFsaWQ6ICEwLCByZXNvbHV0aW9uOiBudWxsLCB2YWx1ZSB9IDogIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCA/IHtcbiAgICB2YWxpZDogITEsXG4gICAgcmVzb2x1dGlvbjoge1xuICAgICAgcGF0Y2hlczogW3Vuc2V0KFtdKV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJFZGl0b3IgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBQb3J0YWJsZSBUZXh0IGJsb2Nrcywgb3IgdW5kZWZpbmVkLlwiLFxuICAgICAgYWN0aW9uOiBcIlVuc2V0IHRoZSB2YWx1ZVwiLFxuICAgICAgaXRlbTogdmFsdWUsXG4gICAgICBpMThuOiB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmRlc2NyaXB0aW9uXCIsXG4gICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1hcnJheS5hY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVcbiAgfSA6ICh2YWx1ZS5zb21lKChibGssIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGJsaykpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFtpbmRleF0pXSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7U3RyaW5nKGJsayl9YCxcbiAgICAgICAgYWN0aW9uOiBcIlVuc2V0IGludmFsaWQgaXRlbVwiLFxuICAgICAgICBpdGVtOiBibGssXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tb2JqZWN0LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczogeyBpbmRleCB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl9rZXkgfHwgdHlwZW9mIGJsay5fa2V5ICE9IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3NldCh7IC4uLmJsaywgX2tleToga2V5R2VuZXJhdG9yKCkgfSwgW2luZGV4XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGF0IGluZGV4ICR7aW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleS5gLFxuICAgICAgICBhY3Rpb246IFwiU2V0IHRoZSBibG9jayB3aXRoIGEgcmFuZG9tIF9rZXkgdmFsdWVcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmcta2V5LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczogeyBpbmRleCB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl90eXBlIHx8ICF2YWxpZEJsb2NrVHlwZXMuaW5jbHVkZXMoYmxrLl90eXBlKSkge1xuICAgICAgaWYgKGJsay5fdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja1R5cGVOYW1lID0gdHlwZXMuYmxvY2submFtZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7IC4uLmJsaywgX3R5cGU6IGN1cnJlbnRCbG9ja1R5cGVOYW1lIH0sIFt7IF9rZXk6IGJsay5fa2V5IH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCB0eXBlIG5hbWUgJyR7YmxrLl90eXBlfScuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke2N1cnJlbnRCbG9ja1R5cGVOYW1lfSdgLFxuICAgICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke2N1cnJlbnRCbG9ja1R5cGVOYW1lfSdgLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmluY29ycmVjdC1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbmNvcnJlY3QtYmxvY2stdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5LCBleHBlY3RlZFR5cGVOYW1lOiBjdXJyZW50QmxvY2tUeXBlTmFtZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhYmxrLl90eXBlICYmIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKHsgLi4uYmxrLCBfdHlwZTogdHlwZXMuYmxvY2submFtZSB9KSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHsgLi4uYmxrLCBfdHlwZTogdHlwZXMuYmxvY2submFtZSB9LCBbeyBfa2V5OiBibGsuX2tleSB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWUuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5LCBleHBlY3RlZFR5cGVOYW1lOiB0eXBlcy5ibG9jay5uYW1lIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogYmxrLl90eXBlID8gKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbeyBfa2V5OiBibGsuX2tleSB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIF90eXBlICcke2Jsay5fdHlwZX0nYCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7IGtleTogYmxrLl9rZXksIHR5cGVOYW1lOiBibGsuX3R5cGUgfVxuICAgICAgICB9XG4gICAgICB9LCAhMCkgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7IF9rZXk6IGJsay5fa2V5IH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhbiBfdHlwZSBwcm9wZXJ0eWAsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5IH1cbiAgICAgICAgfVxuICAgICAgfSwgITApO1xuICAgIH1cbiAgICBpZiAoYmxrLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibGs7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuICYmICFBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoeyBjaGlsZHJlbjogW10gfSwgW3sgX2tleTogdGV4dEJsb2NrLl9rZXkgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFRleHQgYmxvY2sgd2l0aCBfa2V5ICcke3RleHRCbG9jay5fa2V5fScgaGFzIGEgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnY2hpbGRyZW4nLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlc2V0IHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVwiLFxuICAgICAgICAgIGl0ZW06IHRleHRCbG9jayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7IGtleTogdGV4dEJsb2NrLl9rZXkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuID09PSB2b2lkIDAgfHwgQXJyYXkuaXNBcnJheSh0ZXh0QmxvY2suY2hpbGRyZW4pICYmIHRleHRCbG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgbmV3U3BhbiA9IHtcbiAgICAgICAgICBfdHlwZTogdHlwZXMuc3Bhbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgbWFya3M6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIGF1dG9SZXNvbHZlOiAhMCxcbiAgICAgICAgICBwYXRjaGVzOiBbXG4gICAgICAgICAgICBzZXRJZk1pc3NpbmcoW10sIFt7IF9rZXk6IGJsay5fa2V5IH0sIFwiY2hpbGRyZW5cIl0pLFxuICAgICAgICAgICAgaW5zZXJ0KFtuZXdTcGFuXSwgXCJhZnRlclwiLCBbeyBfa2V5OiBibGsuX2tleSB9LCBcImNoaWxkcmVuXCIsIDBdKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZHJlbiBmb3IgdGV4dCBibG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBpcyBlbXB0eS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJJbnNlcnQgYW4gZW1wdHkgdGV4dFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmVtcHR5LWNoaWxkcmVuLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgaWYgKGJsay5tYXJrRGVmcyAmJiAhQXJyYXkuaXNBcnJheShibGsubWFya0RlZnMpKVxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbc2V0KHsgLi4udGV4dEJsb2NrLCBtYXJrRGVmczogRU1QVFlfTUFSS0RFRlMgfSwgW3sgX2tleTogdGV4dEJsb2NrLl9rZXkgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJCbG9jayBoYXMgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnbWFya0RlZnMnLlwiLFxuICAgICAgICAgIGFjdGlvbjogXCJBZGQgZW1wdHkgbWFya0RlZnMgYXJyYXlcIixcbiAgICAgICAgICBpdGVtOiB0ZXh0QmxvY2ssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLW9yLWludmFsaWQtbWFya2RlZnMuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1tYXJrZGVmcy5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IHRleHRCbG9jay5fa2V5IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgY29uc3QgYWxsVXNlZE1hcmtzID0gdW5pcShcbiAgICAgICAgZmxhdHRlbihcbiAgICAgICAgICB0ZXh0QmxvY2suY2hpbGRyZW4uZmlsdGVyKChjbGQpID0+IGNsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lKS5tYXAoKGNsZCkgPT4gY2xkLm1hcmtzIHx8IFtdKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxrLm1hcmtEZWZzKSAmJiBibGsubWFya0RlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB1bnVzZWRNYXJrRGVmcyA9IHVuaXEoXG4gICAgICAgICAgYmxrLm1hcmtEZWZzLm1hcCgoZGVmKSA9PiBkZWYuX2tleSkuZmlsdGVyKChrZXkpID0+ICFhbGxVc2VkTWFya3MuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHVudXNlZE1hcmtEZWZzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiB1bnVzZWRNYXJrRGVmcy5tYXAoXG4gICAgICAgICAgICAgIChtYXJrRGVmS2V5KSA9PiB1bnNldChbeyBfa2V5OiBibGsuX2tleSB9LCBcIm1hcmtEZWZzXCIsIHsgX2tleTogbWFya0RlZktleSB9XSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGNvbnRhaW5zIG9ycGhhbmVkIGRhdGEgKHVudXNlZCBtYXJrIGRlZmluaXRpb25zKTogJHt1bnVzZWRNYXJrRGVmcy5qb2luKFxuICAgICAgICAgICAgICBcIiwgXCJcbiAgICAgICAgICAgICl9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHVudXNlZCBtYXJrIGRlZmluaXRpb24gaXRlbVwiLFxuICAgICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrLWRlZnMuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5LCB1bnVzZWRNYXJrRGVmczogdW51c2VkTWFya0RlZnMubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ycGhhbmVkTWFya3MgPSBhbGxVc2VkTWFya3MuZmlsdGVyKFxuICAgICAgICAobWFyaykgPT4gIXR5cGVzLmRlY29yYXRvcnMubWFwKChkZWMpID0+IGRlYy52YWx1ZSkuaW5jbHVkZXMobWFyaylcbiAgICAgICkuZmlsdGVyKFxuICAgICAgICAobWFyaykgPT4gdGV4dEJsb2NrLm1hcmtEZWZzID09PSB2b2lkIDAgfHwgIXRleHRCbG9jay5tYXJrRGVmcy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKVxuICAgICAgKTtcbiAgICAgIGlmIChvcnBoYW5lZE1hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbkNoaWxkcmVuID0gdGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcihcbiAgICAgICAgICAoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSAmJiBBcnJheS5pc0FycmF5KGNsZC5tYXJrcykgJiYgY2xkLm1hcmtzLnNvbWUoKG1hcmspID0+IG9ycGhhbmVkTWFya3MuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzcGFuQ2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBvcnBoYW5lZCA9IG9ycGhhbmVkTWFya3Muam9pbihcIiwgXCIpO1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogc3BhbkNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHNldChcbiAgICAgICAgICAgICAgKGNoaWxkLm1hcmtzIHx8IFtdKS5maWx0ZXIoKGNNcmspID0+ICFvcnBoYW5lZE1hcmtzLmluY2x1ZGVzKGNNcmspKSxcbiAgICAgICAgICAgICAgW3sgX2tleTogYmxrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IGNoaWxkLl9rZXkgfSwgXCJtYXJrc1wiXVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGNvbnRhaW5zIG1hcmtzICgke29ycGhhbmVkfSkgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBjb250ZW50IG1vZGVsLmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIGludmFsaWQgbWFya3NcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5vcnBoYW5lZC1tYXJrcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7IGtleTogYmxrLl9rZXksIG9ycGhhbmVkTWFya3M6IG9ycGhhbmVkTWFya3MubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGV4dEJsb2NrLmNoaWxkcmVuLnNvbWUoKGNoaWxkLCBjSW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KGNoaWxkKSlcbiAgICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbeyBfa2V5OiBibGsuX2tleSB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJyR7Y0luZGV4fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm9uLW9iamVjdC1jaGlsZC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHsga2V5OiBibGsuX2tleSwgaW5kZXg6IGNJbmRleCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgITA7XG4gICAgICAgIGlmICghY2hpbGQuX2tleSB8fCB0eXBlb2YgY2hpbGQuX2tleSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB7IC4uLmNoaWxkLCBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9O1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgYXV0b1Jlc29sdmU6ICEwLFxuICAgICAgICAgICAgcGF0Y2hlczogW3NldChuZXdDaGlsZCwgW3sgX2tleTogYmxrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCBjSW5kZXhdKV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIGF0IGluZGV4ICR7Y0luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkgaW4gYmxvY2sgd2l0aCBfa2V5ICR7YmxrLl9rZXl9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiU2V0IGEgbmV3IHJhbmRvbSBfa2V5IG9uIHRoZSBvYmplY3RcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7IGtleTogYmxrLl9rZXksIGluZGV4OiBjSW5kZXggfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZC5fdHlwZSA/IHZhbGlkQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC5fdHlwZSkgPyBjaGlsZC5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lICYmIHR5cGVvZiBjaGlsZC50ZXh0ICE9IFwic3RyaW5nXCIgPyAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbXG4gICAgICAgICAgICBzZXQoeyAuLi5jaGlsZCwgdGV4dDogXCJcIiB9LCBbeyBfa2V5OiBibGsuX2tleSB9LCBcImNoaWxkcmVuXCIsIHsgX2tleTogY2hpbGQuX2tleSB9XSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGhhcyBtaXNzaW5nIG9yIGludmFsaWQgdGV4dCBwcm9wZXJ0eSFgLFxuICAgICAgICAgIGFjdGlvbjogXCJXcml0ZSBhbiBlbXB0eSB0ZXh0IHByb3BlcnR5IHRvIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW52YWxpZC1zcGFuLXRleHQuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHsga2V5OiBibGsuX2tleSwgY2hpbGRLZXk6IGNoaWxkLl9rZXkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITApIDogITEgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3sgX2tleTogYmxrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IGNoaWxkLl9rZXkgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBoYXMgaW52YWxpZCAnX3R5cGUnIHByb3BlcnR5ICgke2NoaWxkLl90eXBlfSkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLmRpc2FsbG93ZWQtY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5LCBjaGlsZEtleTogY2hpbGQuX2tleSwgY2hpbGRUeXBlOiBjaGlsZC5fdHlwZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCkgOiAocmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3sgX2tleTogYmxrLl9rZXkgfSwgXCJjaGlsZHJlblwiLCB7IF9rZXk6IGNoaWxkLl9rZXkgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIHdpdGggX2tleSAnJHtjaGlsZC5fa2V5fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBtaXNzaW5nICdfdHlwZScgcHJvcGVydHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQtdHlwZS5hY3Rpb25cIixcbiAgICAgICAgICAgIHZhbHVlczogeyBrZXk6IGJsay5fa2V5LCBjaGlsZEtleTogY2hpbGQuX2tleSB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCk7XG4gICAgICB9KSAmJiAodmFsaWQgPSAhMSk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSkgJiYgKHZhbGlkID0gITEpLCB7IHZhbGlkLCByZXNvbHV0aW9uLCB2YWx1ZSB9KTtcbn1cbmNvbnN0IGRlYnVnJDYgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhJbnNlcnREYXRhXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aEluc2VydERhdGEoY2hhbmdlJCwgc2NoZW1hVHlwZXMsIGtleUdlbmVyYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgYmxvY2tUeXBlTmFtZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIHNwYW5UeXBlTmFtZSA9IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gc2NoZW1hVHlwZXMuYmxvY2sub3B0aW9ucy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUsIHRvUGxhaW5UZXh0ID0gKGJsb2NrcykgPT4gYmxvY2tzLm1hcCgoYmxvY2spID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spID8gYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSA/IGNoaWxkLnRleHQgOiBgWyR7KChfYTIgPSBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY2hpbGQuX3R5cGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRpdGxlKSB8fCBcIk9iamVjdFwifV1gO1xuICAgICAgfSkuam9pbihcIlwiKSA6IGBbJHsoKF9hID0gc2NoZW1hVHlwZXMuYmxvY2tPYmplY3RzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gYmxvY2suX3R5cGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGl0bGUpIHx8IFwiT2JqZWN0XCJ9XWA7XG4gICAgfSkuam9pbihgXG5cbmApO1xuICAgIHJldHVybiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhID0gKGRhdGEsIG9yaWdpbkV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yO1xuICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbiksIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwgeyBhdDogc3RhcnQucGF0aCB9KSwgZW5kVm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwgeyBhdDogZW5kLnBhdGggfSk7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgbGV0IGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgY29uc3QgW3ZvaWROb2RlXSA9IGVuZFZvaWQsIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCksIGRvbU5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCB2b2lkTm9kZSk7XG4gICAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSksIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiKSkuZm9yRWFjaCgoencpID0+IHtcbiAgICAgICAgY29uc3QgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKFwiZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXCIpID09PSBcIm5cIjtcbiAgICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyBgXG5gIDogXCJcIjtcbiAgICAgIH0pLCBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5mb3JFYWNoKChlbG0pID0+IHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtaW5saW5lXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1sZWFmXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1ub2RlXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1zcGFjZXJcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLXN0cmluZ1wiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtemVyby13aWR0aFwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZWxtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgZWxtLmhhc0F0dHJpYnV0ZShrZXkpICYmIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKSwgZGl2LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIiksIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgY29uc3QgYXNIVE1MID0gZGl2LmlubmVySFRNTDtcbiAgICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBlZGl0b3IuZ2V0RnJhZ21lbnQoKSwgcG9ydGFibGVUZXh0ID0gZnJvbVNsYXRlVmFsdWUoZnJhZ21lbnQsIGJsb2NrVHlwZU5hbWUpLCBhc0pTT04gPSBKU09OLnN0cmluZ2lmeShwb3J0YWJsZVRleHQpLCBhc1BsYWluVGV4dCA9IHRvUGxhaW5UZXh0KHBvcnRhYmxlVGV4dCk7XG4gICAgICBkYXRhLmNsZWFyRGF0YSgpLCBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGFzSFRNTCksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIiwgYXNKU09OKSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsIGFzSlNPTiksIGRlYnVnJDYoXCJ0ZXh0XCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0LWV2ZW50LW9yaWdpblwiLCBvcmlnaW5FdmVudCB8fCBcImV4dGVybmFsXCIpLCBkZWJ1ZyQ2KFwiU2V0IGZyYWdtZW50IGRhdGFcIiwgYXNKU09OLCBhc0hUTUwpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRQb3J0YWJsZVRleHREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHBUZXh0ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIpLCBvcmlnaW4gPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHQtZXZlbnQtb3JpZ2luXCIpO1xuICAgICAgaWYgKGRlYnVnJDYoYEluc2VydGluZyBwb3J0YWJsZSB0ZXh0IGZyb20gJHtvcmlnaW59IGV2ZW50YCwgcFRleHQpLCBwVGV4dCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHBUZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHNsYXRlVmFsdWUgPSBfcmVnZW5lcmF0ZUtleXMoXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB0b1NsYXRlVmFsdWUocGFyc2VkLCB7IHNjaGVtYVR5cGVzIH0pLFxuICAgICAgICAgICAga2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgc3BhblR5cGVOYW1lLFxuICAgICAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgICAgICApLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZShwYXJzZWQsIHNjaGVtYVR5cGVzLCBrZXlHZW5lcmF0b3IpO1xuICAgICAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCAmJiAhKChfYSA9IHZhbGlkYXRpb24ucmVzb2x1dGlvbikgIT0gbnVsbCAmJiBfYS5hdXRvUmVzb2x2ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBgJHsoX2IgPSB2YWxpZGF0aW9uLnJlc29sdXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5kZXNjcmlwdGlvbn1gO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZSQubmV4dCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgbGV2ZWw6IFwid2FybmluZ1wiLFxuICAgICAgICAgICAgICBuYW1lOiBcInBhc3RlRXJyb3JcIixcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgIGRhdGE6IHZhbGlkYXRpb25cbiAgICAgICAgICAgIH0pLCBkZWJ1ZyQ2KFwiSW52YWxpZCBpbnNlcnQgcmVzdWx0XCIsIHZhbGlkYXRpb24pLCAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIHNsYXRlVmFsdWUsIHNjaGVtYVR5cGVzKSwgITA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0VGV4dE9ySFRNTERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZGVidWckNihcIk5vIHNlbGVjdGlvbiwgbm90IGluc2VydGluZ1wiKSwgITE7XG4gICAgICBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcImxvYWRpbmdcIiwgaXNMb2FkaW5nOiAhMCB9KTtcbiAgICAgIGNvbnN0IGh0bWwgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHRleHQgPSBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgaWYgKGh0bWwgfHwgdGV4dCkge1xuICAgICAgICBkZWJ1ZyQ2KFwiSW5zZXJ0aW5nIGRhdGFcIiwgZGF0YSk7XG4gICAgICAgIGxldCBwb3J0YWJsZVRleHQsIGZyYWdtZW50LCBpbnNlcnRlZFR5cGU7XG4gICAgICAgIGlmIChodG1sKSB7XG4gICAgICAgICAgaWYgKHBvcnRhYmxlVGV4dCA9IGh0bWxUb0Jsb2NrcyhodG1sLCBzY2hlbWFUeXBlcy5wb3J0YWJsZVRleHQsIHtcbiAgICAgICAgICAgIHVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZTogd2hpdGVzcGFjZU9uUGFzdGVNb2RlXG4gICAgICAgICAgfSkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHsgYmxvY2tUeXBlTmFtZSB9KSksIGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwgeyBzY2hlbWFUeXBlcyB9KSwgaW5zZXJ0ZWRUeXBlID0gXCJIVE1MXCIsIHBvcnRhYmxlVGV4dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dFRvSHRtbCA9IGA8aHRtbD48Ym9keT4ke2VzY2FwZUh0bWwodGV4dCkuc3BsaXQoL1xcbnsyLH0vKS5tYXAoXG4gICAgICAgICAgICAobGluZSkgPT4gbGluZSA/IGA8cD4ke2xpbmUucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIFwiPGJyLz5cIil9PC9wPmAgOiBcIjxwPjwvcD5cIlxuICAgICAgICAgICkuam9pbihcIlwiKX08L2JvZHk+PC9odG1sPmA7XG4gICAgICAgICAgcG9ydGFibGVUZXh0ID0gaHRtbFRvQmxvY2tzKHRleHRUb0h0bWwsIHNjaGVtYVR5cGVzLnBvcnRhYmxlVGV4dCkubWFwKFxuICAgICAgICAgICAgKGJsb2NrKSA9PiBub3JtYWxpemVCbG9jayhibG9jaywgeyBibG9ja1R5cGVOYW1lIH0pXG4gICAgICAgICAgKSwgZnJhZ21lbnQgPSB0b1NsYXRlVmFsdWUocG9ydGFibGVUZXh0LCB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICAgIH0pLCBpbnNlcnRlZFR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZShwb3J0YWJsZVRleHQsIHNjaGVtYVR5cGVzLCBrZXlHZW5lcmF0b3IpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gYENvdWxkIG5vdCB2YWxpZGF0ZSB0aGUgcmVzdWx0aW5nIHBvcnRhYmxlIHRleHQgdG8gaW5zZXJ0LlxuJHsoX2EgPSB2YWxpZGF0aW9uLnJlc29sdXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZXNjcmlwdGlvbn1cblRyeSB0byBpbnNlcnQgYXMgcGxhaW4gdGV4dCAoc2hpZnQtcGFzdGUpIGluc3RlYWQuYDtcbiAgICAgICAgICByZXR1cm4gY2hhbmdlJC5uZXh0KHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGxldmVsOiBcIndhcm5pbmdcIixcbiAgICAgICAgICAgIG5hbWU6IFwicGFzdGVFcnJvclwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sXG4gICAgICAgICAgICBkYXRhOiB2YWxpZGF0aW9uXG4gICAgICAgICAgfSksIGRlYnVnJDYoXCJJbnZhbGlkIGluc2VydCByZXN1bHRcIiwgdmFsaWRhdGlvbiksICExO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWJ1ZyQ2KGBJbnNlcnRpbmcgJHtpbnNlcnRlZFR5cGV9IGZyYWdtZW50IGF0ICR7SlNPTi5zdHJpbmdpZnkoZWRpdG9yLnNlbGVjdGlvbil9YCksIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcyksIGNoYW5nZSQubmV4dCh7IHR5cGU6IFwibG9hZGluZ1wiLCBpc0xvYWRpbmc6ICExIH0pLCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcImxvYWRpbmdcIiwgaXNMb2FkaW5nOiAhMSB9KSwgITE7XG4gICAgfSwgZWRpdG9yLmluc2VydERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgZWRpdG9yLmluc2VydFBvcnRhYmxlVGV4dERhdGEoZGF0YSkgfHwgZWRpdG9yLmluc2VydFRleHRPckhUTUxEYXRhKGRhdGEpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZW50aXR5TWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIixcbiAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiLFxuICBcIj1cIjogXCImI3gzRDtcIlxufTtcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRlS2V5cyhlZGl0b3IsIGZyYWdtZW50LCBrZXlHZW5lcmF0b3IsIHNwYW5UeXBlTmFtZSwgZWRpdG9yVHlwZXMpIHtcbiAgcmV0dXJuIGZyYWdtZW50Lm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IG5ld05vZGUgPSB7IC4uLm5vZGUgfTtcbiAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5ld05vZGUpKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGVkaXRvclR5cGVzLmFubm90YXRpb25zLm1hcCgodCkgPT4gdC5uYW1lKTtcbiAgICAgIGlmIChhbm5vdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgeyBtYXJrRGVmcywgLi4uTmV3Tm9kZU5vRGVmcyB9ID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIHsgLi4uTmV3Tm9kZU5vRGVmcywgX2tleToga2V5R2VuZXJhdG9yKCkgfTtcbiAgICAgIH1cbiAgICAgIGlmICgobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkuc29tZSgoZGVmKSA9PiAhYW5ub3RhdGlvbnMuaW5jbHVkZXMoZGVmLl90eXBlKSkpIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZEFubm90YXRpb25zID0gKG5ld05vZGUubWFya0RlZnMgfHwgW10pLmZpbHRlcigoZGVmKSA9PiBhbm5vdGF0aW9ucy5pbmNsdWRlcyhkZWYuX3R5cGUpKTtcbiAgICAgICAgcmV0dXJuIHsgLi4ubmV3Tm9kZSwgbWFya0RlZnM6IGFsbG93ZWRBbm5vdGF0aW9ucywgX2tleToga2V5R2VuZXJhdG9yKCkgfTtcbiAgICAgIH1cbiAgICAgIG5ld05vZGUubWFya0RlZnMgPSAobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkubWFwKChkZWYpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkS2V5ID0gZGVmLl9rZXksIG5ld0tleSA9IGtleUdlbmVyYXRvcigpO1xuICAgICAgICByZXR1cm4gbmV3Tm9kZS5jaGlsZHJlbiA9IG5ld05vZGUuY2hpbGRyZW4ubWFwKFxuICAgICAgICAgIChjaGlsZCkgPT4gY2hpbGQuX3R5cGUgPT09IHNwYW5UeXBlTmFtZSAmJiBlZGl0b3IuaXNUZXh0U3BhbihjaGlsZCkgPyB7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIG1hcmtzOiBjaGlsZC5tYXJrcyAmJiBjaGlsZC5tYXJrcy5pbmNsdWRlcyhvbGRLZXkpID8gKFxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LW5lc3RlZC1jYWxsYmFja3NcbiAgICAgICAgICAgICAgWy4uLmNoaWxkLm1hcmtzXS5maWx0ZXIoKG1hcmspID0+IG1hcmsgIT09IG9sZEtleSkuY29uY2F0KG5ld0tleSlcbiAgICAgICAgICAgICkgOiBjaGlsZC5tYXJrc1xuICAgICAgICAgIH0gOiBjaGlsZFxuICAgICAgICApLCB7IC4uLmRlZiwgX2tleTogbmV3S2V5IH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVdpdGhOZXdLZXlzID0geyAuLi5uZXdOb2RlLCBfa2V5OiBrZXlHZW5lcmF0b3IoKSB9O1xuICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZVdpdGhOZXdLZXlzKSAmJiAobm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuID0gbm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgfSkpKSwgbm9kZVdpdGhOZXdLZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcykge1xuICBlZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2ZvY3VzQmxvY2ssIGZvY3VzUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHsgZGVwdGg6IDEgfSk7XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhmb2N1c0Jsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2soZnJhZ21lbnRbMF0pKSB7XG4gICAgICBjb25zdCB7IG1hcmtEZWZzIH0gPSBmb2N1c0Jsb2NrO1xuICAgICAgZGVidWckNihcIk1peGluZyBtYXJrRGVmcyBvZiBmb2N1c0Jsb2NrIGFuZCBmcmFnbWVudHNbMF0gYmxvY2tcIiwgbWFya0RlZnMsIGZyYWdtZW50WzBdLm1hcmtEZWZzKSwgaXNFcXVhbChtYXJrRGVmcywgZnJhZ21lbnRbMF0ubWFya0RlZnMpIHx8IFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtEZWZzOiB1bmlxKFsuLi5mcmFnbWVudFswXS5tYXJrRGVmcyB8fCBbXSwgLi4ubWFya0RlZnMgfHwgW11dKVxuICAgICAgICB9LFxuICAgICAgICB7IGF0OiBmb2N1c1BhdGgsIG1vZGU6IFwibG93ZXN0XCIsIHZvaWRzOiAhMSB9XG4gICAgICApO1xuICAgIH1cbiAgICBpc0VxdWFsVG9FbXB0eUVkaXRvcihlZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSA/IChUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7IGF0OiBbMCwgMF0gfSksIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBbMF0gfSkpIDogZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50KTtcbiAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xufVxuY29uc3Qgb3JpZ2luYWxGbk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB3aXRoUGx1Z2lucyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZSA9IGVkaXRvciwgeyBrZXlHZW5lcmF0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgcGF0Y2hlcyQsIHJlYWRPbmx5LCBtYXhCbG9ja3MgfSA9IG9wdGlvbnMsIHsgc2NoZW1hVHlwZXMsIGNoYW5nZSQgfSA9IHBvcnRhYmxlVGV4dEVkaXRvcjtcbiAgZS5zdWJzY3JpcHRpb25zID0gW10sIGUuZGVzdHJveSA/IGUuZGVzdHJveSgpIDogb3JpZ2luYWxGbk1hcC5zZXQoZSwge1xuICAgIGFwcGx5OiBlLmFwcGx5LFxuICAgIG9uQ2hhbmdlOiBlLm9uQ2hhbmdlLFxuICAgIG5vcm1hbGl6ZU5vZGU6IGUubm9ybWFsaXplTm9kZVxuICB9KTtcbiAgY29uc3Qgb3BlcmF0aW9uVG9QYXRjaGVzID0gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHNjaGVtYVR5cGVzKSwgd2l0aE9iamVjdEtleXMgPSBjcmVhdGVXaXRoT2JqZWN0S2V5cyhzY2hlbWFUeXBlcywga2V5R2VuZXJhdG9yKSwgd2l0aFNjaGVtYVR5cGVzID0gY3JlYXRlV2l0aFNjaGVtYVR5cGVzKHsgc2NoZW1hVHlwZXMsIGtleUdlbmVyYXRvciB9KSwgd2l0aEVkaXRhYmxlQVBJID0gY3JlYXRlV2l0aEVkaXRhYmxlQVBJKHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIGtleUdlbmVyYXRvciksIHdpdGhQYXRjaGVzID0gY3JlYXRlV2l0aFBhdGNoZXMoe1xuICAgIGNoYW5nZSQsXG4gICAga2V5R2VuZXJhdG9yLFxuICAgIHBhdGNoZXMkLFxuICAgIHBhdGNoRnVuY3Rpb25zOiBvcGVyYXRpb25Ub1BhdGNoZXMsXG4gICAgcmVhZE9ubHksXG4gICAgc2NoZW1hVHlwZXNcbiAgfSksIHdpdGhNYXhCbG9ja3MgPSBjcmVhdGVXaXRoTWF4QmxvY2tzKG1heEJsb2NrcyB8fCAtMSksIHdpdGhQb3J0YWJsZVRleHRMaXN0cyA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRMaXN0cyhzY2hlbWFUeXBlcyksIHdpdGhVbmRvUmVkbyA9IGNyZWF0ZVdpdGhVbmRvUmVkbyh7XG4gICAgcmVhZE9ubHksXG4gICAgcGF0Y2hlcyQsXG4gICAgYmxvY2tTY2hlbWFUeXBlOiBzY2hlbWFUeXBlcy5ibG9ja1xuICB9KSwgd2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoc2NoZW1hVHlwZXMsIGNoYW5nZSQpLCB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKHNjaGVtYVR5cGVzKSwgd2l0aFBsYWNlaG9sZGVyQmxvY2sgPSBjcmVhdGVXaXRoUGxhY2Vob2xkZXJCbG9jaygpLCB3aXRoSW5zZXJ0QnJlYWsgPSBjcmVhdGVXaXRoSW5zZXJ0QnJlYWsoc2NoZW1hVHlwZXMpLCB3aXRoVXRpbHMgPSBjcmVhdGVXaXRoVXRpbHMoeyBrZXlHZW5lcmF0b3IsIHNjaGVtYVR5cGVzLCBwb3J0YWJsZVRleHRFZGl0b3IgfSksIHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMoY2hhbmdlJCwgc2NoZW1hVHlwZXMpO1xuICByZXR1cm4gZS5kZXN0cm95ID0gKCkgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsRnVuY3Rpb25zID0gb3JpZ2luYWxGbk1hcC5nZXQoZSk7XG4gICAgaWYgKCFvcmlnaW5hbEZ1bmN0aW9ucylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHByaXN0aW5lIHZlcnNpb25zIG9mIGVkaXRvciBmdW5jdGlvbnNcIik7XG4gICAgZS5hcHBseSA9IG9yaWdpbmFsRnVuY3Rpb25zLmFwcGx5LCBlLmhpc3RvcnkgPSB7IHVuZG9zOiBbXSwgcmVkb3M6IFtdIH0sIGUubm9ybWFsaXplTm9kZSA9IG9yaWdpbmFsRnVuY3Rpb25zLm5vcm1hbGl6ZU5vZGUsIGUub25DaGFuZ2UgPSBvcmlnaW5hbEZ1bmN0aW9ucy5vbkNoYW5nZTtcbiAgfSwgcmVhZE9ubHkgPyB7XG4gICAgZWRpdG9yOiB3aXRoU2NoZW1hVHlwZXMoXG4gICAgICB3aXRoT2JqZWN0S2V5cyhcbiAgICAgICAgd2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChcbiAgICAgICAgICB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZShcbiAgICAgICAgICAgIHdpdGhVdGlscyhcbiAgICAgICAgICAgICAgd2l0aFBsYWNlaG9sZGVyQmxvY2soXG4gICAgICAgICAgICAgICAgd2l0aFBvcnRhYmxlVGV4dExpc3RzKFxuICAgICAgICAgICAgICAgICAgd2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMod2l0aEVkaXRhYmxlQVBJKHdpdGhJbnNlcnRCcmVhayhlKSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICBzdWJzY3JpYmU6ICgpID0+IG5vb3BcbiAgfSA6IHtcbiAgICBlZGl0b3I6IHdpdGhTY2hlbWFUeXBlcyhcbiAgICAgIHdpdGhPYmplY3RLZXlzKFxuICAgICAgICB3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsKFxuICAgICAgICAgIHdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKFxuICAgICAgICAgICAgd2l0aFBvcnRhYmxlVGV4dExpc3RzKFxuICAgICAgICAgICAgICB3aXRoUGxhY2Vob2xkZXJCbG9jayhcbiAgICAgICAgICAgICAgICB3aXRoVXRpbHMoXG4gICAgICAgICAgICAgICAgICB3aXRoTWF4QmxvY2tzKFxuICAgICAgICAgICAgICAgICAgICB3aXRoVW5kb1JlZG8oXG4gICAgICAgICAgICAgICAgICAgICAgd2l0aFBhdGNoZXMod2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMod2l0aEVkaXRhYmxlQVBJKHdpdGhJbnNlcnRCcmVhayhlKSkpKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSxcbiAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcyA9IFtdO1xuICAgICAgcmV0dXJuIGVkaXRvci5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmliZUZuKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlcy5wdXNoKHN1YnNjcmliZUZuKCkpO1xuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmVzLmZvckVhY2goKHVuc3Vic2NyaWJlRm4pID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZUZuKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59LCBkZWJ1ZyQ1ID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3I6U2xhdGVDb250YWluZXJcIik7XG5mdW5jdGlvbiBTbGF0ZUNvbnRhaW5lcihwcm9wcykge1xuICBjb25zdCB7IHBhdGNoZXMkLCBwb3J0YWJsZVRleHRFZGl0b3IsIHJlYWRPbmx5LCBtYXhCbG9ja3MsIGtleUdlbmVyYXRvciB9ID0gcHJvcHMsIFtbc2xhdGVFZGl0b3IsIHN1YnNjcmliZV1dID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgIGRlYnVnJDUoXCJDcmVhdGluZyBuZXcgU2xhdGUgZWRpdG9yIGluc3RhbmNlXCIpO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBzdWJzY3JpYmU6IF9zdWIgfSA9IHdpdGhQbHVnaW5zKHdpdGhSZWFjdChjcmVhdGVFZGl0b3IoKSksIHtcbiAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgIG1heEJsb2NrcyxcbiAgICAgIHBhdGNoZXMkLFxuICAgICAgcG9ydGFibGVUZXh0RWRpdG9yLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KTtcbiAgICByZXR1cm4gS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGVkaXRvciwge30pLCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5zZXQoZWRpdG9yLCB7fSksIFtlZGl0b3IsIF9zdWJdO1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmliZSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtzdWJzY3JpYmVdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkZWJ1ZyQ1KFwiUmUtaW5pdGlhbGl6aW5nIHBsdWdpbiBjaGFpblwiKSwgd2l0aFBsdWdpbnMoc2xhdGVFZGl0b3IsIHtcbiAgICAgIGtleUdlbmVyYXRvcixcbiAgICAgIG1heEJsb2NrcyxcbiAgICAgIHBhdGNoZXMkLFxuICAgICAgcG9ydGFibGVUZXh0RWRpdG9yLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KTtcbiAgfSwgW2tleUdlbmVyYXRvciwgcG9ydGFibGVUZXh0RWRpdG9yLCBtYXhCbG9ja3MsIHJlYWRPbmx5LCBwYXRjaGVzJCwgc2xhdGVFZGl0b3JdKTtcbiAgY29uc3QgaW5pdGlhbFZhbHVlID0gdXNlTWVtbygoKSA9PiBbc2xhdGVFZGl0b3IucHRlQ3JlYXRlRW1wdHlCbG9jaygpXSwgW3NsYXRlRWRpdG9yXSk7XG4gIHJldHVybiB1c2VFZmZlY3QoKCkgPT4gKCkgPT4ge1xuICAgIGRlYnVnJDUoXCJEZXN0cm95aW5nIFNsYXRlIGVkaXRvclwiKSwgc2xhdGVFZGl0b3IuZGVzdHJveSgpO1xuICB9LCBbc2xhdGVFZGl0b3JdKSwgLyogQF9fUFVSRV9fICovIGpzeChTbGF0ZSwgeyBlZGl0b3I6IHNsYXRlRWRpdG9yLCBpbml0aWFsVmFsdWUsIGNoaWxkcmVuOiBwcm9wcy5jaGlsZHJlbiB9KTtcbn1cbmNvbnN0IGRlZmF1bHRLZXlHZW5lcmF0b3IgPSAoKSA9PiByYW5kb21LZXkoMTIpLCBQb3J0YWJsZVRleHRFZGl0b3JLZXlHZW5lcmF0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dChkZWZhdWx0S2V5R2VuZXJhdG9yKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yS2V5R2VuZXJhdG9yID0gKCkgPT4ge1xuICBjb25zdCBrZXlHZW5lcmF0b3IgPSB1c2VDb250ZXh0KFBvcnRhYmxlVGV4dEVkaXRvcktleUdlbmVyYXRvckNvbnRleHQpO1xuICBpZiAoa2V5R2VuZXJhdG9yID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYHVzZVBvcnRhYmxlVGV4dEVkaXRvcktleUdlbmVyYXRvcmAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8UG9ydGFibGVUZXh0RWRpdG9yPiBjb21wb25lbnQncyBjb250ZXh0LlwiXG4gICAgKTtcbiAgcmV0dXJuIGtleUdlbmVyYXRvcjtcbn0sIFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpLCB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb24gPSAoKSA9PiB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHVzZUNvbnRleHQoUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uQ29udGV4dCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCJcbiAgICApO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufSwgUG9ydGFibGVUZXh0RWRpdG9yVmFsdWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdm9pZCAwXG4pLCBQb3J0YWJsZVRleHRFZGl0b3JSZWFkT25seUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCExKSwgdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlTdGF0dXMgPSAoKSA9PiB7XG4gIGNvbnN0IHJlYWRPbmx5ID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JSZWFkT25seUNvbnRleHQpO1xuICBpZiAocmVhZE9ubHkgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFBvcnRhYmxlVGV4dEVkaXRvcj4gY29tcG9uZW50J3MgY29udGV4dC5cIlxuICAgICk7XG4gIHJldHVybiByZWFkT25seTtcbn0sIGRlYnVnJDQgPSBkZWJ1Z1dpdGhOYW1lKFwiaG9vazp1c2VTeW5jVmFsdWVcIiksIENVUlJFTlRfVkFMVUUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHVzZVN5bmNWYWx1ZShwcm9wcykge1xuICBjb25zdCB7IHBvcnRhYmxlVGV4dEVkaXRvciwgcmVhZE9ubHksIGtleUdlbmVyYXRvciB9ID0gcHJvcHMsIHsgY2hhbmdlJCwgc2NoZW1hVHlwZXMgfSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgcHJldmlvdXNWYWx1ZSA9IHVzZVJlZigpLCBzbGF0ZUVkaXRvciA9IHVzZVNsYXRlKCksIHVwZGF0ZVZhbHVlRnVuY3Rpb25SZWYgPSB1c2VSZWYoKSwgdXBkYXRlRnJvbUN1cnJlbnRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBDVVJSRU5UX1ZBTFVFLmdldChwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgIGlmIChwcmV2aW91c1ZhbHVlLmN1cnJlbnQgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgZGVidWckNChcIlZhbHVlIGlzIHRoZSBzYW1lIG9iamVjdCBhcyBwcmV2aW91cywgbm90IG5lZWQgdG8gc3luY1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdXBkYXRlVmFsdWVGdW5jdGlvblJlZi5jdXJyZW50ICYmIGN1cnJlbnRWYWx1ZSAmJiAoZGVidWckNChcIlVwZGF0aW5nIHRoZSB2YWx1ZSBkZWJvdW5jZWRcIiksIHVwZGF0ZVZhbHVlRnVuY3Rpb25SZWYuY3VycmVudChjdXJyZW50VmFsdWUpKTtcbiAgfSwgW3BvcnRhYmxlVGV4dEVkaXRvcl0pLCB1cGRhdGVWYWx1ZURlYm91bmNlZCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gZGVib3VuY2UodXBkYXRlRnJvbUN1cnJlbnRWYWx1ZSwgMWUzLCB7IHRyYWlsaW5nOiAhMCwgbGVhZGluZzogITEgfSksXG4gICAgW3VwZGF0ZUZyb21DdXJyZW50VmFsdWVdXG4gICk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuICAgICAgQ1VSUkVOVF9WQUxVRS5zZXQocG9ydGFibGVUZXh0RWRpdG9yLCB2YWx1ZSk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMgPSBpc0NoYW5naW5nTG9jYWxseShzbGF0ZUVkaXRvciksIGlzUHJvY2Vzc2luZ1JlbW90ZUNoYW5nZXMgPSBpc0NoYW5naW5nUmVtb3RlbHkoc2xhdGVFZGl0b3IpO1xuICAgICAgaWYgKCFyZWFkT25seSkge1xuICAgICAgICBpZiAoaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgZGVidWckNChcIkhhcyBsb2NhbCBjaGFuZ2VzLCBub3Qgc3luY2luZyB2YWx1ZSByaWdodCBub3dcIiksIHVwZGF0ZVZhbHVlRGVib3VuY2VkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb2Nlc3NpbmdSZW1vdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgZGVidWckNChcIkhhcyByZW1vdGUgY2hhbmdlcywgbm90IHN5bmNpbmcgdmFsdWUgcmlnaHQgbm93XCIpLCB1cGRhdGVWYWx1ZURlYm91bmNlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGlzQ2hhbmdlZCA9ICExLCBpc1ZhbGlkID0gITA7XG4gICAgICBjb25zdCBoYWRTZWxlY3Rpb24gPSAhIXNsYXRlRWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgIGlmICgoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkgJiYgKGRlYnVnJDQoXCJWYWx1ZSBpcyBlbXB0eVwiKSwgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICB3aXRob3V0U2F2aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBoYWRTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvcik7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogW2NoaWxkcmVuTGVuZ3RoIC0gMSAtIGluZGV4XVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVFbXB0eUJsb2NrKCksIHsgYXQ6IFswXSB9KSwgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBbMCwgMF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBpc0NoYW5nZWQgPSAhMCksIHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc2xhdGVWYWx1ZUZyb21Qcm9wcyA9IHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgd2l0aG91dFBhdGNoaW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNsYXRlVmFsdWVGcm9tUHJvcHMubGVuZ3RoIDwgY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbkxlbmd0aCAtIDE7IGkgPiBzbGF0ZVZhbHVlRnJvbVByb3BzLmxlbmd0aCAtIDE7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICAgIGF0OiBbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpc0NoYW5nZWQgPSAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2xhdGVWYWx1ZUZyb21Qcm9wcy5mb3JFYWNoKChjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQmxvY2sgPSBzbGF0ZUVkaXRvci5jaGlsZHJlbltjdXJyZW50QmxvY2tJbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAob2xkQmxvY2sgJiYgIWlzRXF1YWwoY3VycmVudEJsb2NrLCBvbGRCbG9jaykgJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uVmFsdWUgPSBbdmFsdWVbY3VycmVudEJsb2NrSW5kZXhdXSwgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUodmFsaWRhdGlvblZhbHVlLCBzY2hlbWFUeXBlcywga2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgIXZhbGlkYXRpb24udmFsaWQgJiYgKF9hID0gdmFsaWRhdGlvbi5yZXNvbHV0aW9uKSAhPSBudWxsICYmIF9hLmF1dG9SZXNvbHZlICYmICgoX2IgPSB2YWxpZGF0aW9uLnJlc29sdXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5wYXRjaGVzLmxlbmd0aCkgPiAwICYmICFyZWFkT25seSAmJiBwcmV2aW91c1ZhbHVlLmN1cnJlbnQgJiYgcHJldmlvdXNWYWx1ZS5jdXJyZW50ICE9PSB2YWx1ZSAmJiAoY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgIGAke3ZhbGlkYXRpb24ucmVzb2x1dGlvbi5hY3Rpb259IGZvciBibG9jayB3aXRoIF9rZXkgJyR7dmFsaWRhdGlvblZhbHVlWzBdLl9rZXl9Jy4gJHsoX2MgPSB2YWxpZGF0aW9uLnJlc29sdXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYy5kZXNjcmlwdGlvbn1gXG4gICAgICAgICAgICAgICAgICAgICksIHZhbGlkYXRpb24ucmVzb2x1dGlvbi5wYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJwYXRjaFwiLCBwYXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLCB2YWxpZGF0aW9uLnZhbGlkIHx8IChfZCA9IHZhbGlkYXRpb24ucmVzb2x1dGlvbikgIT0gbnVsbCAmJiBfZC5hdXRvUmVzb2x2ZSA/IChvbGRCbG9jay5fa2V5ID09PSBjdXJyZW50QmxvY2suX2tleSA/IChkZWJ1ZyQ0LmVuYWJsZWQgJiYgZGVidWckNChcIlVwZGF0aW5nIGJsb2NrXCIsIG9sZEJsb2NrLCBjdXJyZW50QmxvY2spLCBfdXBkYXRlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgb2xkQmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSkgOiAoZGVidWckNC5lbmFibGVkICYmIGRlYnVnJDQoXCJSZXBsYWNpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF9yZXBsYWNlQmxvY2soc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSwgaXNDaGFuZ2VkID0gITApIDogKGNoYW5nZSQubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uLnJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSksIGlzVmFsaWQgPSAhMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIW9sZEJsb2NrICYmIGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblZhbHVlID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZSwgc2NoZW1hVHlwZXMsIGtleUdlbmVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnJDQuZW5hYmxlZCAmJiBkZWJ1ZyQ0KFxuICAgICAgICAgICAgICAgICAgICAgIFwiVmFsaWRhdGluZyBhbmQgaW5zZXJ0aW5nIG5ldyBibG9jayBpbiB0aGUgZW5kIG9mIHRoZSB2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1xuICAgICAgICAgICAgICAgICAgICApLCB2YWxpZGF0aW9uLnZhbGlkIHx8IChfZSA9IHZhbGlkYXRpb24ucmVzb2x1dGlvbikgIT0gbnVsbCAmJiBfZS5hdXRvUmVzb2x2ZSA/IHdpdGhQcmVzZXJ2ZUtleXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pIDogKGRlYnVnJDQoXCJJbnZhbGlkXCIsIHZhbGlkYXRpb24pLCBjaGFuZ2UkLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogdmFsaWRhdGlvbi5yZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pLCBpc1ZhbGlkID0gITEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBkZWJ1ZyQ0KFwiSW52YWxpZCB2YWx1ZSwgcmV0dXJuaW5nXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgIGRlYnVnJDQoXCJTZXJ2ZXIgdmFsdWUgY2hhbmdlZCwgc3luY2luZyBlZGl0b3JcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpLCBjaGFuZ2UkLm5leHQoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkVmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IG51bGwsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYWRTZWxlY3Rpb24gJiYgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhbmNob3I6IHsgcGF0aDogWzAsIDBdLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgICBmb2N1czogeyBwYXRoOiBbMCwgMF0sIG9mZnNldDogMCB9XG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJ2YWx1ZVwiLCB2YWx1ZSB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBkZWJ1ZyQ0KFwiU2VydmVyIHZhbHVlIGFuZCBlZGl0b3IgdmFsdWUgaXMgZXF1YWwsIG5vIG5lZWQgdG8gc3luYy5cIik7XG4gICAgICBwcmV2aW91c1ZhbHVlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGVWYWx1ZUZ1bmN0aW9uUmVmLmN1cnJlbnQgPSB1cGRhdGVGdW5jdGlvbiwgdXBkYXRlRnVuY3Rpb247XG4gIH0sIFtcbiAgICBjaGFuZ2UkLFxuICAgIGtleUdlbmVyYXRvcixcbiAgICBwb3J0YWJsZVRleHRFZGl0b3IsXG4gICAgcmVhZE9ubHksXG4gICAgc2NoZW1hVHlwZXMsXG4gICAgc2xhdGVFZGl0b3IsXG4gICAgdXBkYXRlVmFsdWVEZWJvdW5jZWRcbiAgXSk7XG59XG5mdW5jdGlvbiBfcmVwbGFjZUJsb2NrKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24sIHNlbGVjdGlvbkZvY3VzT25CbG9jayA9IGN1cnJlbnRTZWxlY3Rpb24gJiYgY3VycmVudFNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdID09PSBjdXJyZW50QmxvY2tJbmRleDtcbiAgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuZGVzZWxlY3Qoc2xhdGVFZGl0b3IpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7IGF0OiBbY3VycmVudEJsb2NrSW5kZXhdIH0pLCB3aXRoUHJlc2VydmVLZXlzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCB7IGF0OiBbY3VycmVudEJsb2NrSW5kZXhdIH0pO1xuICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBjdXJyZW50U2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgaWYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhjdXJyZW50QmxvY2spICYmIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggPSBvbGRCbG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggJiYgQXJyYXkuZnJvbShBcnJheShvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCkpLmZvckVhY2goXG4gICAgICAoXywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRJbmRleCA9IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXg7XG4gICAgICAgIGNoaWxkSW5kZXggPiAwICYmIChkZWJ1ZyQ0KFwiUmVtb3ZpbmcgY2hpbGRcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjaGlsZEluZGV4XVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgKSwgY3VycmVudEJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnRCbG9ja0NoaWxkLCBjdXJyZW50QmxvY2tDaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRCbG9ja0NoaWxkID0gb2xkQmxvY2suY2hpbGRyZW5bY3VycmVudEJsb2NrQ2hpbGRJbmRleF0sIGlzQ2hpbGRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBpc1RleHRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQudGV4dCwgb2xkQmxvY2tDaGlsZCA9PSBudWxsID8gdm9pZCAwIDogb2xkQmxvY2tDaGlsZC50ZXh0KSwgcGF0aCA9IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF07XG4gICAgICBpZiAoaXNDaGlsZENoYW5nZWQpXG4gICAgICAgIGlmIChjdXJyZW50QmxvY2tDaGlsZC5fa2V5ID09PSAob2xkQmxvY2tDaGlsZCA9PSBudWxsID8gdm9pZCAwIDogb2xkQmxvY2tDaGlsZC5fa2V5KSkge1xuICAgICAgICAgIGRlYnVnJDQoXCJVcGRhdGluZyBjaGFuZ2VkIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNTcGFuTm9kZSA9IFRleHQuaXNUZXh0KGN1cnJlbnRCbG9ja0NoaWxkKSAmJiBjdXJyZW50QmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgVGV4dC5pc1RleHQob2xkQmxvY2tDaGlsZCkgJiYgb2xkQmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCI7XG4gICAgICAgICAgaXNTcGFuTm9kZSAmJiBpc1RleHRDaGFuZ2VkID8gKFRyYW5zZm9ybXMuZGVsZXRlKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogeyBmb2N1czogeyBwYXRoLCBvZmZzZXQ6IDAgfSwgYW5jaG9yOiB7IHBhdGgsIG9mZnNldDogb2xkQmxvY2tDaGlsZC50ZXh0Lmxlbmd0aCB9IH1cbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IGlzU3Bhbk5vZGUgfHwgKGRlYnVnJDQoXCJVcGRhdGluZyBjaGFuZ2VkIGlubGluZSBvYmplY3QgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICB7IF9rZXk6IFZPSURfQ0hJTERfS0VZIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMF0sXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfVxuICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Ugb2xkQmxvY2tDaGlsZCA/IChkZWJ1ZyQ0KFwiUmVwbGFjaW5nIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCB3aXRoUHJlc2VydmVLZXlzKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IG9sZEJsb2NrQ2hpbGQgfHwgKGRlYnVnJDQoXCJJbnNlcnRpbmcgbmV3IGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkKSwgd2l0aFByZXNlcnZlS2V5cyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4LCBjdXJyZW50QmxvY2tDaGlsZEluZGV4XVxuICAgICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGRlYnVnJDMgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTeW5jaHJvbml6ZXJcIiksIGRlYnVnVmVyYm9zZSA9IGRlYnVnJDMuZW5hYmxlZCAmJiAhMSwgRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgPyA1MDAgOiAxZTM7XG5mdW5jdGlvbiBTeW5jaHJvbml6ZXIocHJvcHMpIHtcbiAgY29uc3QgeyBjaGFuZ2UkLCBwb3J0YWJsZVRleHRFZGl0b3IsIG9uQ2hhbmdlLCBrZXlHZW5lcmF0b3IsIHJlYWRPbmx5LCB2YWx1ZSB9ID0gcHJvcHMsIFtzZWxlY3Rpb24sIHNldFNlbGVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKSwgcGVuZGluZ1BhdGNoZXMgPSB1c2VSZWYoW10pLCBzeW5jVmFsdWUgPSB1c2VTeW5jVmFsdWUoe1xuICAgIGtleUdlbmVyYXRvcixcbiAgICBvbkNoYW5nZSxcbiAgICBwb3J0YWJsZVRleHRFZGl0b3IsXG4gICAgcmVhZE9ubHlcbiAgfSksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGUoKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMuc2V0KHNsYXRlRWRpdG9yLCAhMSk7XG4gIH0sIFtzbGF0ZUVkaXRvcl0pO1xuICBjb25zdCBvbkZsdXNoUGVuZGluZ1BhdGNoZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgZGVidWckMyhcIkZsdXNoaW5nIHBlbmRpbmcgcGF0Y2hlc1wiKSwgZGVidWdWZXJib3NlICYmIGRlYnVnJDMoYFBhdGNoZXM6XG4ke0pTT04uc3RyaW5naWZ5KHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQsIG51bGwsIDIpfWApO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0VmFsdWUocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIGNoYW5nZSQubmV4dCh7IHR5cGU6IFwibXV0YXRpb25cIiwgcGF0Y2hlczogcGVuZGluZ1BhdGNoZXMuY3VycmVudCwgc25hcHNob3QgfSksIHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQgPSBbXTtcbiAgICB9XG4gICAgSVNfUFJPQ0VTU0lOR19MT0NBTF9DSEFOR0VTLnNldChzbGF0ZUVkaXRvciwgITEpO1xuICB9LCBbc2xhdGVFZGl0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgY2hhbmdlJF0pLCBvbkZsdXNoUGVuZGluZ1BhdGNoZXNUaHJvdHRsZWQgPSB1c2VNZW1vKCgpID0+IHRocm90dGxlKFxuICAgICgpID0+IHtcbiAgICAgIGlmIChFZGl0b3IuaXNOb3JtYWxpemluZyhzbGF0ZUVkaXRvcikpIHtcbiAgICAgICAgb25GbHVzaFBlbmRpbmdQYXRjaGVzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9uRmx1c2hQZW5kaW5nUGF0Y2hlc1Rocm90dGxlZCgpO1xuICAgIH0sXG4gICAgRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVMsXG4gICAge1xuICAgICAgbGVhZGluZzogITEsXG4gICAgICB0cmFpbGluZzogITBcbiAgICB9XG4gICksIFtvbkZsdXNoUGVuZGluZ1BhdGNoZXMsIHNsYXRlRWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiB7XG4gICAgb25GbHVzaFBlbmRpbmdQYXRjaGVzKCk7XG4gIH0sIFtvbkZsdXNoUGVuZGluZ1BhdGNoZXNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkZWJ1ZyQzKFwiU3Vic2NyaWJpbmcgdG8gZWRpdG9yIGNoYW5nZXMkXCIpO1xuICAgIGNvbnN0IHN1YiA9IGNoYW5nZSQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XG4gICAgICBzd2l0Y2ggKG5leHQudHlwZSkge1xuICAgICAgICBjYXNlIFwicGF0Y2hcIjpcbiAgICAgICAgICBJU19QUk9DRVNTSU5HX0xPQ0FMX0NIQU5HRVMuc2V0KHNsYXRlRWRpdG9yLCAhMCksIHBlbmRpbmdQYXRjaGVzLmN1cnJlbnQucHVzaChuZXh0LnBhdGNoKSwgb25GbHVzaFBlbmRpbmdQYXRjaGVzVGhyb3R0bGVkKCksIG9uQ2hhbmdlKG5leHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2VsZWN0aW9uXCI6XG4gICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnVmVyYm9zZSAmJiBkZWJ1ZyQzKFwiU2V0dGluZyBzZWxlY3Rpb25cIiksIHNldFNlbGVjdGlvbihuZXh0LnNlbGVjdGlvbik7XG4gICAgICAgICAgfSksIG9uQ2hhbmdlKG5leHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG9uQ2hhbmdlKG5leHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWJ1ZyQzKFwiVW5zdWJzY3JpYmluZyB0byBjaGFuZ2VzJFwiKSwgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2NoYW5nZSQsIG9uQ2hhbmdlLCBvbkZsdXNoUGVuZGluZ1BhdGNoZXNUaHJvdHRsZWQsIHNsYXRlRWRpdG9yXSk7XG4gIGNvbnN0IGhhbmRsZU9ubGluZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBkZWJ1ZyQzKFwiRWRpdG9yIGlzIG9ubGluZSwgc3luY2luZyBmcm9tIHByb3BzLnZhbHVlXCIpLCBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcImNvbm5lY3Rpb25cIiwgdmFsdWU6IFwib25saW5lXCIgfSksIHN5bmNWYWx1ZSh2YWx1ZSk7XG4gIH0sIFtjaGFuZ2UkLCBzeW5jVmFsdWUsIHZhbHVlXSksIGhhbmRsZU9mZmxpbmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZGVidWckMyhcIkVkaXRvciBpcyBvZmZsaW5lXCIpLCBjaGFuZ2UkLm5leHQoeyB0eXBlOiBcImNvbm5lY3Rpb25cIiwgdmFsdWU6IFwib2ZmbGluZVwiIH0pO1xuICB9LCBbY2hhbmdlJF0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKHBvcnRhYmxlVGV4dEVkaXRvci5wcm9wcy5wYXRjaGVzJCAmJiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlT25saW5lKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUpKSwgKCkgPT4ge1xuICAgIHBvcnRhYmxlVGV4dEVkaXRvci5wcm9wcy5wYXRjaGVzJCAmJiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvbmxpbmVcIiwgaGFuZGxlT25saW5lKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUpKTtcbiAgfSkpO1xuICBjb25zdCBpc0luaXRpYWxWYWx1ZUZyb21Qcm9wcyA9IHVzZVJlZighMCk7XG4gIHJldHVybiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRlYnVnJDMoXCJWYWx1ZSBmcm9tIHByb3BzIGNoYW5nZWQsIHN5bmNpbmcgbmV3IHZhbHVlXCIpLCBzeW5jVmFsdWUodmFsdWUpLCBpc0luaXRpYWxWYWx1ZUZyb21Qcm9wcy5jdXJyZW50ICYmIChjaGFuZ2UkLm5leHQoeyB0eXBlOiBcImxvYWRpbmdcIiwgaXNMb2FkaW5nOiAhMSB9KSwgY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJyZWFkeVwiIH0pLCBpc0luaXRpYWxWYWx1ZUZyb21Qcm9wcy5jdXJyZW50ID0gITEpO1xuICB9LCBbY2hhbmdlJCwgc3luY1ZhbHVlLCB2YWx1ZV0pLCAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvcktleUdlbmVyYXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGtleUdlbmVyYXRvciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcG9ydGFibGVUZXh0RWRpdG9yLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JWYWx1ZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclJlYWRPbmx5Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcmVhZE9ubHksIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlbGVjdGlvbiwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pIH0pIH0pIH0pIH0pO1xufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5jb25zdCBkZWJ1ZyQyID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudDpQb3J0YWJsZVRleHRFZGl0b3JcIik7XG5jbGFzcyBQb3J0YWJsZVRleHRFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGlmIChzdXBlcihwcm9wcyksIF9fcHVibGljRmllbGQodGhpcywgXCJjaGFuZ2UkXCIsIG5ldyBTdWJqZWN0KCkpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2NoZW1hVHlwZXNcIiksIF9fcHVibGljRmllbGQodGhpcywgXCJlZGl0YWJsZVwiKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEVkaXRhYmxlXCIsIChlZGl0YWJsZSkgPT4ge1xuICAgICAgdGhpcy5lZGl0YWJsZSA9IHsgLi4udGhpcy5lZGl0YWJsZSwgLi4uZWRpdGFibGUgfTtcbiAgICB9KSwgIXByb3BzLnNjaGVtYVR5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvcnRhYmxlVGV4dEVkaXRvcjogbWlzc2luZyBcInR5cGVcIiBwcm9wZXJ0eScpO1xuICAgIHByb3BzLmluY29taW5nUGF0Y2hlcyQgJiYgY29uc29sZS53YXJuKFwiVGhlIHByb3AgJ2luY29taW5nUGF0Y2hlcyQnIGlzIGRlcHJlY2F0ZWQgYW5kIHJlbmFtZWQgdG8gJ3BhdGNoZXMkJ1wiKSwgdGhpcy5jaGFuZ2UkLm5leHQoeyB0eXBlOiBcImxvYWRpbmdcIiwgaXNMb2FkaW5nOiAhMCB9KSwgdGhpcy5zY2hlbWFUeXBlcyA9IGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKFxuICAgICAgcHJvcHMuc2NoZW1hVHlwZS5oYXNPd25Qcm9wZXJ0eShcImpzb25UeXBlXCIpID8gcHJvcHMuc2NoZW1hVHlwZSA6IGNvbXBpbGVUeXBlKHByb3BzLnNjaGVtYVR5cGUpXG4gICAgKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdGhpcy5wcm9wcy5zY2hlbWFUeXBlICE9PSBwcmV2UHJvcHMuc2NoZW1hVHlwZSAmJiAodGhpcy5zY2hlbWFUeXBlcyA9IGdldFBvcnRhYmxlVGV4dE1lbWJlclNjaGVtYVR5cGVzKFxuICAgICAgdGhpcy5wcm9wcy5zY2hlbWFUeXBlLmhhc093blByb3BlcnR5KFwianNvblR5cGVcIikgPyB0aGlzLnByb3BzLnNjaGVtYVR5cGUgOiBjb21waWxlVHlwZSh0aGlzLnByb3BzLnNjaGVtYVR5cGUpXG4gICAgKSksIHRoaXMucHJvcHMuZWRpdG9yUmVmICE9PSBwcmV2UHJvcHMuZWRpdG9yUmVmICYmIHRoaXMucHJvcHMuZWRpdG9yUmVmICYmICh0aGlzLnByb3BzLmVkaXRvclJlZi5jdXJyZW50ID0gdGhpcyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIHZhbHVlLCBjaGlsZHJlbiwgcGF0Y2hlcyQsIGluY29taW5nUGF0Y2hlcyQgfSA9IHRoaXMucHJvcHMsIHsgY2hhbmdlJCB9ID0gdGhpcywgX3BhdGNoZXMkID0gaW5jb21pbmdQYXRjaGVzJCB8fCBwYXRjaGVzJCwgbWF4QmxvY2tzID0gdHlwZW9mIHRoaXMucHJvcHMubWF4QmxvY2tzID4gXCJ1XCIgPyB2b2lkIDAgOiBwYXJzZUludCh0aGlzLnByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMCkgfHwgdm9pZCAwLCByZWFkT25seSA9ICEhdGhpcy5wcm9wcy5yZWFkT25seSwga2V5R2VuZXJhdG9yID0gdGhpcy5wcm9wcy5rZXlHZW5lcmF0b3IgfHwgZGVmYXVsdEtleUdlbmVyYXRvcjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFNsYXRlQ29udGFpbmVyLFxuICAgICAge1xuICAgICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICAgIG1heEJsb2NrcyxcbiAgICAgICAgcGF0Y2hlcyQ6IF9wYXRjaGVzJCxcbiAgICAgICAgcG9ydGFibGVUZXh0RWRpdG9yOiB0aGlzLFxuICAgICAgICByZWFkT25seSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU3luY2hyb25pemVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoYW5nZSQsXG4gICAgICAgICAgICBrZXlHZW5lcmF0b3IsXG4gICAgICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgICAgIHBvcnRhYmxlVGV4dEVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgIHJlYWRPbmx5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbl9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImFjdGl2ZUFubm90YXRpb25zXCIsIChlZGl0b3IpID0+IGVkaXRvciAmJiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuYWN0aXZlQW5ub3RhdGlvbnMoKSA6IFtdKSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiaXNBbm5vdGF0aW9uQWN0aXZlXCIsIChlZGl0b3IsIGFubm90YXRpb25UeXBlKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmlzQW5ub3RhdGlvbkFjdGl2ZShhbm5vdGF0aW9uVHlwZSkgOiAhMSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImFkZEFubm90YXRpb25cIiwgKGVkaXRvciwgdHlwZSwgdmFsdWUpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkQW5ub3RhdGlvbih0eXBlLCB2YWx1ZSk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiYmx1clwiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgZGVidWckMihcIkhvc3QgYmx1cnJlZFwiKSwgKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsIHx8IF9hLmJsdXIoKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJkZWxldGVcIiwgKGVkaXRvciwgc2VsZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImZpbmRET01Ob2RlXCIsIChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluZERPTU5vZGUoZWxlbWVudCk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiZmluZEJ5UGF0aFwiLCAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kQnlQYXRoKHBhdGgpKSB8fCBbXTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJmb2N1c1wiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgZGVidWckMihcIkhvc3QgcmVxdWVzdGluZyBmb2N1c1wiKSwgKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsIHx8IF9hLmZvY3VzKCk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiZm9jdXNCbG9ja1wiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzQmxvY2soKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJmb2N1c0NoaWxkXCIsIChlZGl0b3IpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXNDaGlsZCgpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImdldFNlbGVjdGlvblwiLCAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGUgPyBlZGl0b3IuZWRpdGFibGUuZ2V0U2VsZWN0aW9uKCkgOiBudWxsKSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiZ2V0VmFsdWVcIiwgKGVkaXRvcikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRWYWx1ZSgpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImhhc0Jsb2NrU3R5bGVcIiwgKGVkaXRvciwgYmxvY2tTdHlsZSkgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oYXNCbG9ja1N0eWxlKGJsb2NrU3R5bGUpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImhhc0xpc3RTdHlsZVwiLCAoZWRpdG9yLCBsaXN0U3R5bGUpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGFzTGlzdFN0eWxlKGxpc3RTdHlsZSk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiaXNDb2xsYXBzZWRTZWxlY3Rpb25cIiwgKGVkaXRvcikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pc0NvbGxhcHNlZFNlbGVjdGlvbigpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImlzRXhwYW5kZWRTZWxlY3Rpb25cIiwgKGVkaXRvcikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5pc0V4cGFuZGVkU2VsZWN0aW9uKCk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiaXNNYXJrQWN0aXZlXCIsIChlZGl0b3IsIG1hcmspID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNNYXJrQWN0aXZlKG1hcmspO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImluc2VydENoaWxkXCIsIChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIGRlYnVnJDIoXCJIb3N0IGluc2VydGluZyBjaGlsZFwiKSwgKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaW5zZXJ0Q2hpbGQodHlwZSwgdmFsdWUpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImluc2VydEJsb2NrXCIsIChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluc2VydEJsb2NrKHR5cGUsIHZhbHVlKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJpbnNlcnRCcmVha1wiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluc2VydEJyZWFrKCk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwiaXNWb2lkXCIsIChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNWb2lkKGVsZW1lbnQpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImlzT2JqZWN0UGF0aFwiLCAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIGlmICghcGF0aCB8fCAhQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuICExO1xuICBjb25zdCBpc0NoaWxkT2JqZWN0RWRpdFBhdGggPSBwYXRoLmxlbmd0aCA+IDMgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiO1xuICByZXR1cm4gcGF0aC5sZW5ndGggPiAxICYmIHBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIiB8fCBpc0NoaWxkT2JqZWN0RWRpdFBhdGg7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwibWFya3NcIiwgKGVkaXRvcikgPT4ge1xuICB2YXIgX2E7XG4gIHJldHVybiAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXJrcygpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcInNlbGVjdFwiLCAoZWRpdG9yLCBzZWxlY3Rpb24pID0+IHtcbiAgdmFyIF9hO1xuICBkZWJ1ZyQyKFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgfHwgX2Euc2VsZWN0KHNlbGVjdGlvbik7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwicmVtb3ZlQW5ub3RhdGlvblwiLCAoZWRpdG9yLCB0eXBlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUFubm90YXRpb24odHlwZSk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwidG9nZ2xlQmxvY2tTdHlsZVwiLCAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIGRlYnVnJDIoXCJIb3N0IGlzIHRvZ2dsaW5nIGJsb2NrIHN0eWxlXCIpLCAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b2dnbGVCbG9ja1N0eWxlKGJsb2NrU3R5bGUpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcInRvZ2dsZUxpc3RcIiwgKGVkaXRvciwgbGlzdFN0eWxlKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvZ2dsZUxpc3QobGlzdFN0eWxlKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJ0b2dnbGVNYXJrXCIsIChlZGl0b3IsIG1hcmspID0+IHtcbiAgdmFyIF9hO1xuICBkZWJ1ZyQyKFwiSG9zdCB0b2dnbGluZyBtYXJrXCIsIG1hcmspLCAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgfHwgX2EudG9nZ2xlTWFyayhtYXJrKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJnZXRGcmFnbWVudFwiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIGRlYnVnJDIoXCJIb3N0IGdldHRpbmcgZnJhZ21lbnRcIiksIChfYSA9IGVkaXRvci5lZGl0YWJsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEZyYWdtZW50KCk7XG59KSwgX19wdWJsaWNGaWVsZChQb3J0YWJsZVRleHRFZGl0b3IsIFwidW5kb1wiLCAoZWRpdG9yKSA9PiB7XG4gIHZhciBfYTtcbiAgZGVidWckMihcIkhvc3QgdW5kb2luZ1wiKSwgKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsIHx8IF9hLnVuZG8oKTtcbn0pLCBfX3B1YmxpY0ZpZWxkKFBvcnRhYmxlVGV4dEVkaXRvciwgXCJyZWRvXCIsIChlZGl0b3IpID0+IHtcbiAgdmFyIF9hO1xuICBkZWJ1ZyQyKFwiSG9zdCByZWRvaW5nXCIpLCAoX2EgPSBlZGl0b3IuZWRpdGFibGUpID09IG51bGwgfHwgX2EucmVkbygpO1xufSksIF9fcHVibGljRmllbGQoUG9ydGFibGVUZXh0RWRpdG9yLCBcImlzU2VsZWN0aW9uc092ZXJsYXBwaW5nXCIsIChlZGl0b3IsIHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gKF9hID0gZWRpdG9yLmVkaXRhYmxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmcoc2VsZWN0aW9uQSwgc2VsZWN0aW9uQik7XG59KTtcbmNvbnN0IGRlYnVnJDEgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50czpMZWFmXCIpLCBFTVBUWV9NQVJLUyA9IFtdLCBMZWFmID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgYXR0cmlidXRlcywgY2hpbGRyZW4sIGxlYWYsIHNjaGVtYVR5cGVzLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJBbm5vdGF0aW9uIH0gPSBwcm9wcywgc3BhblJlZiA9IHVzZVJlZihudWxsKSwgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIGJsb2NrU2VsZWN0ZWQgPSB1c2VTZWxlY3RlZCgpLCBbZm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VTdGF0ZSghMSksIFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUoITEpLCBibG9jayA9IGNoaWxkcmVuLnByb3BzLnBhcmVudCwgcGF0aCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gYmxvY2sgPyBbeyBfa2V5OiBibG9jayA9PSBudWxsID8gdm9pZCAwIDogYmxvY2suX2tleSB9LCBcImNoaWxkcmVuXCIsIHsgX2tleTogbGVhZi5fa2V5IH1dIDogW10sXG4gICAgW2Jsb2NrLCBsZWFmLl9rZXldXG4gICksIGRlY29yYXRvclZhbHVlcyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gc2NoZW1hVHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLnZhbHVlKSxcbiAgICBbc2NoZW1hVHlwZXMuZGVjb3JhdG9yc11cbiAgKSwgbWFya3MgPSB1c2VNZW1vKFxuICAgICgpID0+IHVuaXEoKGxlYWYubWFya3MgfHwgRU1QVFlfTUFSS1MpLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmspKSksXG4gICAgW2RlY29yYXRvclZhbHVlcywgbGVhZi5tYXJrc11cbiAgKSwgYW5ub3RhdGlvbk1hcmtzID0gQXJyYXkuaXNBcnJheShsZWFmLm1hcmtzKSA/IGxlYWYubWFya3MgOiBFTVBUWV9NQVJLUywgYW5ub3RhdGlvbnMgPSB1c2VNZW1vKFxuICAgICgpID0+IGFubm90YXRpb25NYXJrcy5tYXAoXG4gICAgICAobWFyaykgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAhZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmspICYmICgoX2EgPSBibG9jayA9PSBudWxsID8gdm9pZCAwIDogYmxvY2subWFya0RlZnMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrKSk7XG4gICAgICB9XG4gICAgKS5maWx0ZXIoQm9vbGVhbiksXG4gICAgW2Fubm90YXRpb25NYXJrcywgYmxvY2ssIGRlY29yYXRvclZhbHVlc11cbiAgKSwgc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cyA9IGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgYmxvY2tTZWxlY3RlZDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpIHtcbiAgICAgIHNldEZvY3VzZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWwgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgc2VsICYmIGlzRXF1YWwoc2VsLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCEwKTtcbiAgICB9KTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvcl0pO1xuICBjb25zdCBzZXRTZWxlY3RlZEZyb21SYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgZGVidWckMShcIlNldHRpbmcgc2VsZWN0aW9uIGFuZCBmb2N1cyBmcm9tIHJhbmdlXCIpO1xuICAgIGNvbnN0IHdpblNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXdpblNlbGVjdGlvbikge1xuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2luU2VsZWN0aW9uICYmIHdpblNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW5TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIHNwYW5SZWYuY3VycmVudCAmJiByYW5nZS5pbnRlcnNlY3RzTm9kZShzcGFuUmVmLmN1cnJlbnQpID8gc2V0U2VsZWN0ZWQoITApIDogc2V0U2VsZWN0ZWQoITEpO1xuICAgIH0gZWxzZVxuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICB9LCBbc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1c10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzdWIgPSBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgIHNldEZvY3VzZWQoITEpLCBzZXRTZWxlY3RlZCghMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0LnR5cGUgPT09IFwiZm9jdXNcIikge1xuICAgICAgICBjb25zdCBzZWwgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICAgIHNlbCAmJiBpc0VxdWFsKHNlbC5mb2N1cy5wYXRoLCBwYXRoKSAmJiBQb3J0YWJsZVRleHRFZGl0b3IuaXNDb2xsYXBzZWRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKSAmJiBzZXRGb2N1c2VkKCEwKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV4dC50eXBlID09PSBcInNlbGVjdGlvblwiICYmIChuZXh0LnNlbGVjdGlvbiAmJiBpc0VxdWFsKG5leHQuc2VsZWN0aW9uLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpID8gc2V0Rm9jdXNlZCghMCkgOiBzZXRGb2N1c2VkKCExKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtwYXRoLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNldFNlbGVjdGVkRnJvbVJhbmdlLCBzaG91bGRUcmFja1NlbGVjdGlvbkFuZEZvY3VzXSksIHVzZUVmZmVjdCgoKSA9PiBzZXRTZWxlY3RlZEZyb21SYW5nZSgpLCBbc2V0U2VsZWN0ZWRGcm9tUmFuZ2VdKTtcbiAgY29uc3QgY29udGVudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCByZXR1cm5lZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKFRleHQuaXNUZXh0KGxlYWYpICYmIGxlYWYuX3R5cGUgPT09IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSAmJiAobWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGVzLmRlY29yYXRvcnMuZmluZCgoZGVjKSA9PiBkZWMudmFsdWUgPT09IG1hcmspO1xuICAgICAgaWYgKHNjaGVtYVR5cGUgJiYgcmVuZGVyRGVjb3JhdG9yKSB7XG4gICAgICAgIGNvbnN0IF9wcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbixcbiAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgc2NoZW1hVHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBtYXJrXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInR5cGVcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IHJlbmRlckRlY29yYXRvcihfcHJvcHMpO1xuICAgICAgfVxuICAgIH0pLCBibG9jayAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwICYmIGFubm90YXRpb25zLmZvckVhY2goKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlcy5hbm5vdGF0aW9ucy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGFubm90YXRpb24uX3R5cGUpO1xuICAgICAgaWYgKHNjaGVtYVR5cGUpXG4gICAgICAgIGlmIChyZW5kZXJBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgX3Byb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICBzY2hlbWFUeXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogYW5ub3RhdGlvblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogcmVuZGVyQW5ub3RhdGlvbihfcHJvcHMpIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuIH0pIH0pO1xuICAgIH0pLCBibG9jayAmJiByZW5kZXJDaGlsZCkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW4uZmluZCgoX2NoaWxkKSA9PiBfY2hpbGQuX2tleSA9PT0gbGVhZi5fa2V5KTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAge1xuICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbiB9KSxcbiAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IHNjaGVtYVR5cGVzLnNwYW4sXG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHZhbHVlOiBjaGlsZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ0eXBlXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZXMuc3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSByZW5kZXJDaGlsZChfcHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuZWRDaGlsZHJlbjtcbiAgfSwgW1xuICAgIGFubm90YXRpb25zLFxuICAgIGJsb2NrLFxuICAgIGNoaWxkcmVuLFxuICAgIGZvY3VzZWQsXG4gICAgbGVhZixcbiAgICBtYXJrcyxcbiAgICBwYXRoLFxuICAgIHJlbmRlckFubm90YXRpb24sXG4gICAgcmVuZGVyQ2hpbGQsXG4gICAgcmVuZGVyRGVjb3JhdG9yLFxuICAgIHNjaGVtYVR5cGVzLmFubm90YXRpb25zLFxuICAgIHNjaGVtYVR5cGVzLmRlY29yYXRvcnMsXG4gICAgc2NoZW1hVHlwZXMuc3BhbixcbiAgICBzZWxlY3RlZFxuICBdKTtcbiAgcmV0dXJuIHVzZU1lbW8oXG4gICAgKCkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyAuLi5hdHRyaWJ1dGVzLCByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiBjb250ZW50IH0sIGxlYWYuX2tleSksXG4gICAgW2xlYWYsIGF0dHJpYnV0ZXMsIGNvbnRlbnRdXG4gICk7XG59LCBkZWJ1ZyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6RWRpdGFibGVcIiksIFBMQUNFSE9MREVSX1NUWUxFID0ge1xuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gIGxlZnQ6IDAsXG4gIHJpZ2h0OiAwXG59LCBFTVBUWV9ERUNPUkFUSU9OU19TVEFURSA9IFtdLCBQb3J0YWJsZVRleHRFZGl0YWJsZSA9IGZvcndhcmRSZWYoZnVuY3Rpb24ocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgaG90a2V5cyxcbiAgICBvbkJsdXIsXG4gICAgb25Gb2N1cyxcbiAgICBvbkJlZm9yZUlucHV0LFxuICAgIG9uUGFzdGUsXG4gICAgb25Db3B5LFxuICAgIG9uQ2xpY2ssXG4gICAgcmFuZ2VEZWNvcmF0aW9ucyxcbiAgICByZW5kZXJBbm5vdGF0aW9uLFxuICAgIHJlbmRlckJsb2NrLFxuICAgIHJlbmRlckNoaWxkLFxuICAgIHJlbmRlckRlY29yYXRvcixcbiAgICByZW5kZXJMaXN0SXRlbSxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJTdHlsZSxcbiAgICBzZWxlY3Rpb246IHByb3BzU2VsZWN0aW9uLFxuICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3LFxuICAgIHNwZWxsQ2hlY2ssXG4gICAgLi4ucmVzdFByb3BzXG4gIH0gPSBwcm9wcywgcG9ydGFibGVUZXh0RWRpdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yKCksIHJlYWRPbmx5ID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yUmVhZE9ubHlTdGF0dXMoKSwga2V5R2VuZXJhdG9yID0gdXNlUG9ydGFibGVUZXh0RWRpdG9yS2V5R2VuZXJhdG9yKCksIHJlZiA9IHVzZVJlZihudWxsKSwgW2VkaXRhYmxlRWxlbWVudCwgc2V0RWRpdGFibGVFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpLCBbaGFzSW52YWxpZFZhbHVlLCBzZXRIYXNJbnZhbGlkVmFsdWVdID0gdXNlU3RhdGUoITEpLCBbcmFuZ2VEZWNvcmF0aW9uU3RhdGUsIHNldFJhbmdlRGVjb3JhdGlvbnNTdGF0ZV0gPSB1c2VTdGF0ZShFTVBUWV9ERUNPUkFUSU9OU19TVEFURSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiByZWYuY3VycmVudCk7XG4gIGNvbnN0IHJhbmdlRGVjb3JhdGlvbnNSZWYgPSB1c2VSZWYocmFuZ2VEZWNvcmF0aW9ucyksIHsgY2hhbmdlJCwgc2NoZW1hVHlwZXMgfSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgc2xhdGVFZGl0b3IgPSB1c2VTbGF0ZSgpLCBibG9ja1R5cGVOYW1lID0gc2NoZW1hVHlwZXMuYmxvY2submFtZSwgd2l0aEluc2VydERhdGEgPSB1c2VNZW1vKFxuICAgICgpID0+IGNyZWF0ZVdpdGhJbnNlcnREYXRhKGNoYW5nZSQsIHNjaGVtYVR5cGVzLCBrZXlHZW5lcmF0b3IpLFxuICAgIFtjaGFuZ2UkLCBrZXlHZW5lcmF0b3IsIHNjaGVtYVR5cGVzXVxuICApLCB3aXRoSG90S2V5cyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gY3JlYXRlV2l0aEhvdGtleXMoc2NoZW1hVHlwZXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5cyksXG4gICAgW2hvdGtleXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXNdXG4gICk7XG4gIHVzZU1lbW8oKCkgPT4gcmVhZE9ubHkgPyAoZGVidWcoXCJFZGl0YWJsZSBpcyBpbiByZWFkIG9ubHkgbW9kZVwiKSwgd2l0aEluc2VydERhdGEoc2xhdGVFZGl0b3IpKSA6IChkZWJ1ZyhcIkVkaXRhYmxlIGlzIGluIGVkaXQgbW9kZVwiKSwgd2l0aEluc2VydERhdGEod2l0aEhvdEtleXMoc2xhdGVFZGl0b3IpKSksIFtyZWFkT25seSwgc2xhdGVFZGl0b3IsIHdpdGhIb3RLZXlzLCB3aXRoSW5zZXJ0RGF0YV0pO1xuICBjb25zdCByZW5kZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2soXG4gICAgKGVQcm9wcykgPT4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIEVsZW1lbnQsXG4gICAgICB7XG4gICAgICAgIC4uLmVQcm9wcyxcbiAgICAgICAgcmVhZE9ubHksXG4gICAgICAgIHJlbmRlckJsb2NrLFxuICAgICAgICByZW5kZXJDaGlsZCxcbiAgICAgICAgcmVuZGVyTGlzdEl0ZW0sXG4gICAgICAgIHJlbmRlclN0eWxlLFxuICAgICAgICBzY2hlbWFUeXBlcyxcbiAgICAgICAgc3BlbGxDaGVja1xuICAgICAgfVxuICAgICksXG4gICAgW3NjaGVtYVR5cGVzLCBzcGVsbENoZWNrLCByZWFkT25seSwgcmVuZGVyQmxvY2ssIHJlbmRlckNoaWxkLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyU3R5bGVdXG4gICksIHJlbmRlckxlYWYgPSB1c2VDYWxsYmFjayhcbiAgICAobFByb3BzKSA9PiB7XG4gICAgICBpZiAobFByb3BzLmxlYWYuX3R5cGUgPT09IFwic3BhblwiKSB7XG4gICAgICAgIGxldCByZW5kZXJlZCA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgTGVhZixcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5sUHJvcHMsXG4gICAgICAgICAgICBzY2hlbWFUeXBlcyxcbiAgICAgICAgICAgIHJlbmRlckFubm90YXRpb24sXG4gICAgICAgICAgICByZW5kZXJDaGlsZCxcbiAgICAgICAgICAgIHJlbmRlckRlY29yYXRvcixcbiAgICAgICAgICAgIHJlYWRPbmx5XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAocmVuZGVyUGxhY2Vob2xkZXIgJiYgbFByb3BzLmxlYWYucGxhY2Vob2xkZXIgJiYgbFByb3BzLnRleHQudGV4dCA9PT0gXCJcIilcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IFBMQUNFSE9MREVSX1NUWUxFLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyUGxhY2Vob2xkZXIoKSB9KSxcbiAgICAgICAgICAgIHJlbmRlcmVkXG4gICAgICAgICAgXSB9KTtcbiAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGxQcm9wcy5sZWFmLnJhbmdlRGVjb3JhdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRpb24gJiYgKHJlbmRlcmVkID0gZGVjb3JhdGlvbi5jb21wb25lbnQoeyBjaGlsZHJlbjogcmVuZGVyZWQgfSkpLCByZW5kZXJlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsUHJvcHMuY2hpbGRyZW47XG4gICAgfSxcbiAgICBbcmVhZE9ubHksIHJlbmRlckFubm90YXRpb24sIHJlbmRlckNoaWxkLCByZW5kZXJEZWNvcmF0b3IsIHJlbmRlclBsYWNlaG9sZGVyLCBzY2hlbWFUeXBlc11cbiAgKSwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocHJvcHNTZWxlY3Rpb24pIHtcbiAgICAgIGRlYnVnKGBTZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KHByb3BzU2VsZWN0aW9uKX1gKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBub3JtYWxpemVTZWxlY3Rpb24oXG4gICAgICAgIHByb3BzU2VsZWN0aW9uLFxuICAgICAgICBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvci5jaGlsZHJlbiwgYmxvY2tUeXBlTmFtZSlcbiAgICAgICk7XG4gICAgICBpZiAobm9ybWFsaXplZFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBkZWJ1ZyhgTm9ybWFsaXplZCBzZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZWxlY3Rpb24pfWApO1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKG5vcm1hbGl6ZWRTZWxlY3Rpb24sIHNsYXRlRWRpdG9yKTtcbiAgICAgICAgc2xhdGVSYW5nZSAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHNsYXRlUmFuZ2UpLCBzbGF0ZUVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG8pID0+IG8udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHx8IGNoYW5nZSQubmV4dCh7IHR5cGU6IFwic2VsZWN0aW9uXCIsIHNlbGVjdGlvbjogbm9ybWFsaXplZFNlbGVjdGlvbiB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbcHJvcHNTZWxlY3Rpb24sIHNsYXRlRWRpdG9yLCBibG9ja1R5cGVOYW1lLCBjaGFuZ2UkXSksIHN5bmNSYW5nZURlY29yYXRpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgKG9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKHJhbmdlRGVjb3JhdGlvbnMgJiYgcmFuZ2VEZWNvcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1NsYXRlUmFuZ2VzID0gW107XG4gICAgICAgIGlmIChyYW5nZURlY29yYXRpb25zLmZvckVhY2goKHJhbmdlRGVjb3JhdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKHJhbmdlRGVjb3JhdGlvbkl0ZW0uc2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKHNsYXRlUmFuZ2UpKSB7XG4gICAgICAgICAgICByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQgJiYgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkKHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW0sXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG5ld1JhbmdlO1xuICAgICAgICAgIGlmIChvcGVyYXRpb24gJiYgKG5ld1JhbmdlID0gbW92ZVJhbmdlQnlPcGVyYXRpb24oc2xhdGVSYW5nZSwgb3BlcmF0aW9uKSwgbmV3UmFuZ2UgJiYgbmV3UmFuZ2UgIT09IHNsYXRlUmFuZ2UgfHwgbmV3UmFuZ2UgPT09IG51bGwgJiYgc2xhdGVSYW5nZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFZhbHVlKHBvcnRhYmxlVGV4dEVkaXRvciksIG5ld1JhbmdlU2VsZWN0aW9uID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgbmV3UmFuZ2UsIHNjaGVtYVR5cGVzKTtcbiAgICAgICAgICAgIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCAmJiByYW5nZURlY29yYXRpb25JdGVtLm9uTW92ZWQoe1xuICAgICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1JhbmdlU2VsZWN0aW9uLFxuICAgICAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW0sXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJsb2NhbFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3UmFuZ2UgIT09IG51bGwgJiYgbmV3U2xhdGVSYW5nZXMucHVzaCh7IC4uLm5ld1JhbmdlIHx8IHNsYXRlUmFuZ2UsIHJhbmdlRGVjb3JhdGlvbjogcmFuZ2VEZWNvcmF0aW9uSXRlbSB9KTtcbiAgICAgICAgfSksIG5ld1NsYXRlUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXRSYW5nZURlY29yYXRpb25zU3RhdGUobmV3U2xhdGVSYW5nZXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlKEVNUFRZX0RFQ09SQVRJT05TX1NUQVRFKTtcbiAgICB9LFxuICAgIFtwb3J0YWJsZVRleHRFZGl0b3IsIHJhbmdlRGVjb3JhdGlvbnMsIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl1cbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdWIgPSBjaGFuZ2UkLnN1YnNjcmliZSgobmV4dCkgPT4ge1xuICAgICAgc3dpdGNoIChuZXh0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW52YWxpZFZhbHVlXCI6XG4gICAgICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCExKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW2NoYW5nZSQsIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IHVzZU1lbW8oKCkgPT4gc2xhdGVFZGl0b3IuYXBwbHksIFtzbGF0ZUVkaXRvcl0pLCBbc3luY2VkUmFuZ2VEZWNvcmF0aW9ucywgc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9uc10gPSB1c2VTdGF0ZSghMSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc3luY2VkUmFuZ2VEZWNvcmF0aW9ucyB8fCAoc2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9ucyghMCksIHN5bmNSYW5nZURlY29yYXRpb25zKCkpO1xuICB9LCBbc3luY1JhbmdlRGVjb3JhdGlvbnMsIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0VxdWFsKHJhbmdlRGVjb3JhdGlvbnMsIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCkgfHwgc3luY1JhbmdlRGVjb3JhdGlvbnMoKSwgcmFuZ2VEZWNvcmF0aW9uc1JlZi5jdXJyZW50ID0gcmFuZ2VEZWNvcmF0aW9ucztcbiAgfSwgW3JhbmdlRGVjb3JhdGlvbnMsIHN5bmNSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiAoc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcmlnaW5hbEFwcGx5KG9wKSwgb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgc3luY1JhbmdlRGVjb3JhdGlvbnMob3ApO1xuICB9LCAoKSA9PiB7XG4gICAgc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICB9KSwgW29yaWdpbmFsQXBwbHksIHNsYXRlRWRpdG9yLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pO1xuICBjb25zdCBoYW5kbGVDb3B5ID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBvbkNvcHkgJiYgb25Db3B5KGV2ZW50KSAhPT0gdm9pZCAwICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBbb25Db3B5XVxuICApLCBoYW5kbGVQYXN0ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KCksICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghb25QYXN0ZSkge1xuICAgICAgICBkZWJ1ZyhcIlBhc3Rpbmcgbm9ybWFsbHlcIiksIHNsYXRlRWRpdG9yLmluc2VydERhdGEoZXZlbnQuY2xpcGJvYXJkRGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFZhbHVlKHBvcnRhYmxlVGV4dEVkaXRvciksIHB0UmFuZ2UgPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBzbGF0ZUVkaXRvci5zZWxlY3Rpb24sIHNjaGVtYVR5cGVzKSwgcGF0aCA9IChwdFJhbmdlID09IG51bGwgPyB2b2lkIDAgOiBwdFJhbmdlLmZvY3VzLnBhdGgpIHx8IFtdLCBvblBhc3RlUmVzdWx0ID0gb25QYXN0ZSh7IGV2ZW50LCB2YWx1ZSwgcGF0aCwgc2NoZW1hVHlwZXMgfSk7XG4gICAgICBvblBhc3RlUmVzdWx0ID09PSB2b2lkIDAgPyAoZGVidWcoXCJObyByZXN1bHQgZnJvbSBjdXN0b20gcGFzdGUgaGFuZGxlciwgcGFzdGluZyBub3JtYWxseVwiKSwgc2xhdGVFZGl0b3IuaW5zZXJ0RGF0YShldmVudC5jbGlwYm9hcmREYXRhKSkgOiAoY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJsb2FkaW5nXCIsIGlzTG9hZGluZzogITAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0KSwgIXJlc3VsdCB8fCAhcmVzdWx0Lmluc2VydCA/IChkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50LmNsaXBib2FyZERhdGEpKSA6IHJlc3VsdC5pbnNlcnQgPyBzbGF0ZUVkaXRvci5pbnNlcnRGcmFnbWVudChcbiAgICAgICAgICB0b1NsYXRlVmFsdWUocmVzdWx0Lmluc2VydCwgeyBzY2hlbWFUeXBlcyB9KVxuICAgICAgICApIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHQpO1xuICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiAoY29uc29sZS5lcnJvcihlcnJvciksIGVycm9yKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNoYW5nZSQubmV4dCh7IHR5cGU6IFwibG9hZGluZ1wiLCBpc0xvYWRpbmc6ICExIH0pO1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgW2NoYW5nZSQsIG9uUGFzdGUsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXVxuICApLCBoYW5kbGVPbkZvY3VzID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAob25Gb2N1cyAmJiBvbkZvY3VzKGV2ZW50KSwgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgICAgc2VsZWN0aW9uID09PSBudWxsICYmIChUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgRWRpdG9yLnN0YXJ0KHNsYXRlRWRpdG9yLCBbXSkpLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSwgY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJmb2N1c1wiLCBldmVudCB9KTtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpO1xuICAgICAgICBzZWxlY3Rpb24gPT09IG5ld1NlbGVjdGlvbiAmJiBjaGFuZ2UkLm5leHQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW29uRm9jdXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgY2hhbmdlJCwgc2xhdGVFZGl0b3JdXG4gICksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAob25DbGljayAmJiBvbkNsaWNrKGV2ZW50KSwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uICYmIGV2ZW50LnRhcmdldCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICBjb25zdCBbbGFzdEJsb2NrLCBwYXRoXSA9IE5vZGUubGFzdChzbGF0ZUVkaXRvciwgW10pLCBmb2N1c1BhdGggPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSwgbGFzdFBhdGggPSBwYXRoLnNsaWNlKDAsIDEpO1xuICAgICAgICBpZiAoUGF0aC5lcXVhbHMoZm9jdXNQYXRoLCBsYXN0UGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gTm9kZS5kZXNjZW5kYW50KHNsYXRlRWRpdG9yLCBwYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgICBsYXN0QmxvY2sgJiYgRWRpdG9yLmlzVm9pZChzbGF0ZUVkaXRvciwgbm9kZSkgJiYgKFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIHNsYXRlRWRpdG9yLnB0ZUNyZWF0ZUVtcHR5QmxvY2soKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbb25DbGljaywgc2xhdGVFZGl0b3JdXG4gICksIGhhbmRsZU9uQmx1ciA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgb25CbHVyICYmIG9uQmx1cihldmVudCksIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgY2hhbmdlJC5uZXh0KHsgdHlwZTogXCJibHVyXCIsIGV2ZW50IH0pO1xuICAgIH0sXG4gICAgW2NoYW5nZSQsIG9uQmx1cl1cbiAgKSwgaGFuZGxlT25CZWZvcmVJbnB1dCA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgb25CZWZvcmVJbnB1dCAmJiBvbkJlZm9yZUlucHV0KGV2ZW50KTtcbiAgICB9LFxuICAgIFtvbkJlZm9yZUlucHV0XVxuICApLCB2YWxpZGF0ZVNlbGVjdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNsYXRlRWRpdG9yLnNlbGVjdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KHNsYXRlRWRpdG9yKSwgeyBhY3RpdmVFbGVtZW50IH0gPSByb290O1xuICAgIGlmIChyZWYuY3VycmVudCAhPT0gYWN0aXZlRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coc2xhdGVFZGl0b3IpLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uIHx8IGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0aW5nRE9NUmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV3RE9NUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgKG5ld0RPTVJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBleGlzdGluZ0RPTVJhbmdlLnN0YXJ0T2Zmc2V0IHx8IG5ld0RPTVJhbmdlLmVuZE9mZnNldCAhPT0gZXhpc3RpbmdET01SYW5nZS5lbmRPZmZzZXQpICYmIChkZWJ1ZyhcIkRPTSByYW5nZSBvdXQgb2Ygc3luYywgdmFsaWRhdGluZyBzZWxlY3Rpb25cIiksIGRvbVNlbGVjdGlvbiA9PSBudWxsIHx8IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKSwgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKG5ld0RPTVJhbmdlKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBkZWJ1ZyhcIkNvdWxkIG5vdCByZXNvbHZlIHNlbGVjdGlvbiwgc2VsZWN0aW5nIHRvcCBkb2N1bWVudFwiKSwgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIFswLCAwXSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9LCBbcmVmLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlZGl0YWJsZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih2YWxpZGF0ZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKGVkaXRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogITEsXG4gICAgICAgIGF0dHJpYnV0ZXM6ICExLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhMSxcbiAgICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgICAgc3VidHJlZTogITBcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt2YWxpZGF0ZVNlbGVjdGlvbiwgZWRpdGFibGVFbGVtZW50XSk7XG4gIGNvbnN0IGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIHByb3BzLm9uS2V5RG93biAmJiBwcm9wcy5vbktleURvd24oZXZlbnQpLCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBzbGF0ZUVkaXRvci5wdGVXaXRoSG90S2V5cyhldmVudCk7XG4gICAgfSxcbiAgICBbcHJvcHMsIHNsYXRlRWRpdG9yXVxuICApLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9PT0gbnVsbCA/IG5vb3AgOiAoZWRpdG9yLCBkb21SYW5nZSkgPT4ge1xuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhwb3J0YWJsZVRleHRFZGl0b3IsIGRvbVJhbmdlKTtcbiAgICAgIH07XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3IsIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3XSksIGRlY29yYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKFssIHBhdGhdKSA9PiB7XG4gICAgICBpZiAoaXNFcXVhbFRvRW1wdHlFZGl0b3Ioc2xhdGVFZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSlcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAhMFxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIEVNUFRZX0RFQ09SQVRJT05TX1NUQVRFO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmFuZ2VEZWNvcmF0aW9uU3RhdGUuZmlsdGVyKChpdGVtKSA9PiBSYW5nZS5pc0NvbGxhcHNlZChpdGVtKSA/IHBhdGgubGVuZ3RoICE9PSAyID8gITEgOiBQYXRoLmVxdWFscyhpdGVtLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBhdGguZXF1YWxzKGl0ZW0uYW5jaG9yLnBhdGgsIHBhdGgpIDogUmFuZ2UuaW50ZXJzZWN0aW9uKGl0ZW0sIHsgYW5jaG9yOiB7IHBhdGgsIG9mZnNldDogMCB9LCBmb2N1czogeyBwYXRoLCBvZmZzZXQ6IDAgfSB9KSB8fCBSYW5nZS5pbmNsdWRlcyhpdGVtLCBwYXRoKSk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDAgPyByZXN1bHQgOiBFTVBUWV9ERUNPUkFUSU9OU19TVEFURTtcbiAgICB9LFxuICAgIFtzbGF0ZUVkaXRvciwgc2NoZW1hVHlwZXMsIHJhbmdlRGVjb3JhdGlvblN0YXRlXVxuICApO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IpLCBzZXRFZGl0YWJsZUVsZW1lbnQocmVmLmN1cnJlbnQpO1xuICB9LCBbc2xhdGVFZGl0b3IsIHJlZl0pLCBwb3J0YWJsZVRleHRFZGl0b3IgPyBoYXNJbnZhbGlkVmFsdWUgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBFZGl0YWJsZSxcbiAgICB7XG4gICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICBhdXRvRm9jdXM6ICExLFxuICAgICAgY2xhc3NOYW1lOiByZXN0UHJvcHMuY2xhc3NOYW1lIHx8IFwicHQtZWRpdGFibGVcIixcbiAgICAgIGRlY29yYXRlLFxuICAgICAgb25CbHVyOiBoYW5kbGVPbkJsdXIsXG4gICAgICBvbkNvcHk6IGhhbmRsZUNvcHksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIG9uRE9NQmVmb3JlSW5wdXQ6IGhhbmRsZU9uQmVmb3JlSW5wdXQsXG4gICAgICBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLFxuICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgb25QYXN0ZTogaGFuZGxlUGFzdGUsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiB2b2lkIDAsXG4gICAgICByZW5kZXJFbGVtZW50LFxuICAgICAgcmVuZGVyTGVhZixcbiAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3OiBzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGVcbiAgICB9XG4gICkgOiBudWxsO1xufSk7XG5leHBvcnQge1xuICBQb3J0YWJsZVRleHRFZGl0YWJsZSxcbiAgUG9ydGFibGVUZXh0RWRpdG9yLFxuICBkZWZhdWx0S2V5R2VuZXJhdG9yIGFzIGtleUdlbmVyYXRvcixcbiAgdXNlUG9ydGFibGVUZXh0RWRpdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n  if (position !== BEFORE && position !== AFTER)\n    throw new Error(`Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`);\n  const items = flatten(...args);\n  if (array.length === 0)\n    return items;\n  const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n  return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n  return values.reduce((prev, item) => prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction move(arr, from, to) {\n  const nextValue = arr.slice(), val = nextValue[from];\n  return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n  if (typeof pathSegment == \"number\")\n    return pathSegment;\n  const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n  return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n  const nextValue = value.slice();\n  if (patch.path.length === 0) {\n    if (patch.type === \"setIfMissing\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return value === void 0 ? patch.value : value;\n    } else if (patch.type === \"set\") {\n      if (!Array.isArray(patch.value))\n        throw new Error(\"Cannot set value of an array to a non-array\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"move\") {\n        if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\"))\n          throw new Error(\n            `Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(\n              patch.value\n            )}`\n          );\n        return move(nextValue, patch.value.from, patch.value.to);\n      }\n    }\n    throw new Error(`Invalid array operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n  if (index === !1)\n    return nextValue;\n  if (tail.length === 0) {\n    if (patch.type === \"insert\") {\n      const { position, items } = patch;\n      return insert$1(value, position, index, items);\n    } else if (patch.type === \"unset\") {\n      if (typeof index != \"number\")\n        throw new Error(`Expected array index to be a number, instead got \"${index}\"`);\n      return nextValue.splice(index, 1), nextValue;\n    }\n  }\n  return nextValue[index] = _apply(nextValue[index], {\n    ...patch,\n    path: tail\n  }), nextValue;\n}\nfunction apply$2(value, patch) {\n  const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n  if (patch.path.length === 0) {\n    if (patch.type === \"set\") {\n      if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value))\n        throw new Error(\"Cannot set value of an object to a non-object\");\n      return patch.value;\n    } else {\n      if (patch.type === \"unset\")\n        return;\n      if (patch.type === \"setIfMissing\")\n        return value === void 0 ? patch.value : value;\n    }\n    throw new Error(`Invalid object operation: ${patch.type}`);\n  }\n  const [head, ...tail] = patch.path;\n  if (typeof head != \"string\")\n    throw new Error(`Expected field name to be a string, instad got: ${head}`);\n  return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n    ...patch,\n    path: tail\n  }), nextValue);\n}\nconst OPERATIONS$1 = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  inc(currentValue, nextValue) {\n    return currentValue + nextValue;\n  },\n  dec(currentValue, nextValue) {\n    return currentValue - nextValue;\n  }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for primitives. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path) => JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n  replace(_currentValue, nextValue) {\n    return nextValue;\n  },\n  set(_currentValue, nextValue) {\n    return nextValue;\n  },\n  setIfMissing(currentValue, nextValue) {\n    return currentValue === void 0 ? nextValue : currentValue;\n  },\n  unset(_currentValue, _nextValue) {\n  },\n  diffMatchPatch(currentValue, nextValue) {\n    const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n      allowExceedingIndices: !0\n    });\n    return result;\n  }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n  if (!SUPPORTED_PATCH_TYPES.includes(patch.type))\n    throw new Error(\n      `Received patch of unsupported type: \"${JSON.stringify(\n        patch.type\n      )}\" for string. This is most likely a bug.`\n    );\n  if (patch.path.length > 0)\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`\n    );\n  const func = OPERATIONS[patch.type];\n  if (func)\n    return func(value, patch.value);\n  throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n  return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n  return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n  return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n  return {\n    type: \"setIfMissing\",\n    path,\n    value\n  };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n  const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n  return { type: \"diffMatchPatch\", path, value: patch };\n}\nfunction insert(items, position, path = []) {\n  return {\n    type: \"insert\",\n    path,\n    position,\n    items\n  };\n}\nfunction set(value, path = []) {\n  return { type: \"set\", path, value };\n}\nfunction unset(path = []) {\n  return { type: \"unset\", path };\n}\nfunction prefixPath(patch, segment) {\n  return {\n    ...patch,\n    path: [segment, ...patch.path]\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG9CQUFvQixRQUFRLEtBQUssTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsNENBQUs7QUFDekI7QUFDQTtBQUNBLFdBQVcsK0NBQVE7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUUsdURBQXVELDJDQUFJO0FBQzNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVyxjQUFjLDBEQUEwRCwyQkFBMkIsc0JBQXNCO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0VBQVksQ0FBQyxvRUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsV0FBVyxjQUFjLHNCQUFzQiwyQkFBMkIsc0JBQXNCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFRLGdDQUFnQywrQ0FBUTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUVBQVcsbUNBQW1DLDBFQUFnQjtBQUNoRixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmNvbW1vbm9yZy1ibG9nLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvcGF0Y2hlcy9kaXN0L2luZGV4LmpzPzhjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNPYmplY3QuanNcIjtcbmltcG9ydCBpc1N0cmluZyBmcm9tIFwibG9kYXNoL2lzU3RyaW5nLmpzXCI7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gXCJsb2Rhc2gvZmluZEluZGV4LmpzXCI7XG5pbXBvcnQgY2xvbmUgZnJvbSBcImxvZGFzaC9jbG9uZS5qc1wiO1xuaW1wb3J0IG9taXQgZnJvbSBcImxvZGFzaC9vbWl0LmpzXCI7XG5pbXBvcnQgeyBhcHBseVBhdGNoZXMsIHBhcnNlUGF0Y2gsIG1ha2VQYXRjaGVzLCBzdHJpbmdpZnlQYXRjaGVzIH0gZnJvbSBcIkBzYW5pdHkvZGlmZi1tYXRjaC1wYXRjaFwiO1xuY29uc3QgQkVGT1JFID0gXCJiZWZvcmVcIiwgQUZURVIgPSBcImFmdGVyXCI7XG5mdW5jdGlvbiBpbnNlcnQkMShhcnJheSwgcG9zaXRpb24sIGluZGV4LCAuLi5hcmdzKSB7XG4gIGlmIChwb3NpdGlvbiAhPT0gQkVGT1JFICYmIHBvc2l0aW9uICE9PSBBRlRFUilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG9zaXRpb24gXCIke3Bvc2l0aW9ufVwiLCBtdXN0IGJlIGVpdGhlciAke0JFRk9SRX0gb3IgJHtBRlRFUn1gKTtcbiAgY29uc3QgaXRlbXMgPSBmbGF0dGVuKC4uLmFyZ3MpO1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBpdGVtcztcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoLCBpZHggPSBNYXRoLmFicygobGVuICsgaW5kZXgpICUgbGVuKSAlIGxlbiwgbm9ybWFsaXplZElkeCA9IHBvc2l0aW9uID09PSBcImFmdGVyXCIgPyBpZHggKyAxIDogaWR4LCBjb3B5ID0gYXJyYXkuc2xpY2UoKTtcbiAgcmV0dXJuIGNvcHkuc3BsaWNlKG5vcm1hbGl6ZWRJZHgsIDAsIC4uLmZsYXR0ZW4oaXRlbXMpKSwgY29weTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oLi4udmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKChwcmV2LCBpdGVtKSA9PiBwcmV2LmNvbmNhdChpdGVtKSwgW10pO1xufVxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5mdW5jdGlvbiBtb3ZlKGFyciwgZnJvbSwgdG8pIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gYXJyLnNsaWNlKCksIHZhbCA9IG5leHRWYWx1ZVtmcm9tXTtcbiAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoZnJvbSwgMSksIG5leHRWYWx1ZS5zcGxpY2UodG8sIDAsIHZhbCksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBwYXRoU2VnbWVudDtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICExIDogaW5kZXg7XG59XG5mdW5jdGlvbiBhcHBseSQzKHZhbHVlLCBwYXRjaCkge1xuICBjb25zdCBuZXh0VmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRJZk1pc3NpbmdcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBhcnJheSB0byBhIG5vbi1hcnJheVwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICBpZiAoIXBhdGNoLnZhbHVlIHx8ICFoYXNPd24ocGF0Y2gudmFsdWUsIFwiZnJvbVwiKSB8fCAhaGFzT3duKHBhdGNoLnZhbHVlLCBcInRvXCIpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIG9mICdtb3ZlJyBwYXRjaC4gRXhwZWN0ZWQgYSB2YWx1ZSB3aXRoIFwiZnJvbVwiIGFuZCBcInRvXCIgaW5kZXhlcywgaW5zdGVhZCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHBhdGNoLnZhbHVlXG4gICAgICAgICAgICApfWBcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbW92ZShuZXh0VmFsdWUsIHBhdGNoLnZhbHVlLmZyb20sIHBhdGNoLnZhbHVlLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IG9wZXJhdGlvbjogJHtwYXRjaC50eXBlfWApO1xuICB9XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGNoLnBhdGgsIGluZGV4ID0gZmluZFRhcmdldEluZGV4KHZhbHVlLCBoZWFkKTtcbiAgaWYgKGluZGV4ID09PSAhMSlcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICBpZiAodGFpbC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiwgaXRlbXMgfSA9IHBhdGNoO1xuICAgICAgcmV0dXJuIGluc2VydCQxKHZhbHVlLCBwb3NpdGlvbiwgaW5kZXgsIGl0ZW1zKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIikge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFycmF5IGluZGV4IHRvIGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCBcIiR7aW5kZXh9XCJgKTtcbiAgICAgIHJldHVybiBuZXh0VmFsdWUuc3BsaWNlKGluZGV4LCAxKSwgbmV4dFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFZhbHVlW2luZGV4XSA9IF9hcHBseShuZXh0VmFsdWVbaW5kZXhdLCB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogdGFpbFxuICB9KSwgbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gYXBwbHkkMih2YWx1ZSwgcGF0Y2gpIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gY2xvbmUodmFsdWUpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgaWYgKCFpc09iamVjdChwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gb2JqZWN0IHRvIGEgbm9uLW9iamVjdFwiKTtcbiAgICAgIHJldHVybiBwYXRjaC52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0SWZNaXNzaW5nXCIpXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG9iamVjdCBvcGVyYXRpb246ICR7cGF0Y2gudHlwZX1gKTtcbiAgfVxuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBwYXRjaC5wYXRoO1xuICBpZiAodHlwZW9mIGhlYWQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGZpZWxkIG5hbWUgdG8gYmUgYSBzdHJpbmcsIGluc3RhZCBnb3Q6ICR7aGVhZH1gKTtcbiAgcmV0dXJuIHRhaWwubGVuZ3RoID09PSAwICYmIHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiA/IG9taXQobmV4dFZhbHVlLCBoZWFkKSA6IChuZXh0VmFsdWVbaGVhZF0gPSBfYXBwbHkobmV4dFZhbHVlW2hlYWRdLCB7XG4gICAgLi4ucGF0Y2gsXG4gICAgcGF0aDogdGFpbFxuICB9KSwgbmV4dFZhbHVlKTtcbn1cbmNvbnN0IE9QRVJBVElPTlMkMSA9IHtcbiAgcmVwbGFjZShfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXQoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0SWZNaXNzaW5nKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gdm9pZCAwID8gbmV4dFZhbHVlIDogY3VycmVudFZhbHVlO1xuICB9LFxuICB1bnNldChfY3VycmVudFZhbHVlLCBfbmV4dFZhbHVlKSB7XG4gIH0sXG4gIGluYyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgKyBuZXh0VmFsdWU7XG4gIH0sXG4gIGRlYyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgLSBuZXh0VmFsdWU7XG4gIH1cbn0sIFNVUFBPUlRFRF9QQVRDSF9UWVBFUyQxID0gT2JqZWN0LmtleXMoT1BFUkFUSU9OUyQxKTtcbmZ1bmN0aW9uIGFwcGx5JDEodmFsdWUsIHBhdGNoKSB7XG4gIGlmICghU1VQUE9SVEVEX1BBVENIX1RZUEVTJDEuaW5jbHVkZXMocGF0Y2gudHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkIHBhdGNoIG9mIHVuc3VwcG9ydGVkIHR5cGU6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGF0Y2gudHlwZVxuICAgICAgKX1cIiBmb3IgcHJpbWl0aXZlcy4gVGhpcyBpcyBtb3N0IGxpa2VseSBhIGJ1Zy5gXG4gICAgKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IGFwcGx5IGRlZXAgb3BlcmF0aW9ucyBvbiBwcmltaXRpdmUgdmFsdWVzLiBSZWNlaXZlZCBwYXRjaCB3aXRoIHR5cGUgXCIke3BhdGNoLnR5cGV9XCIgYW5kIHBhdGggXCIke3BhdGNoLnBhdGgubWFwKChwYXRoKSA9PiBKU09OLnN0cmluZ2lmeShwYXRoKSkuam9pbihcIi5cIil9IHRoYXQgdGFyZ2V0ZWQgdGhlIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XCJgXG4gICAgKTtcbiAgcmV0dXJuIE9QRVJBVElPTlMkMVtwYXRjaC50eXBlXSh2YWx1ZSwgcGF0Y2gudmFsdWUpO1xufVxuY29uc3QgT1BFUkFUSU9OUyA9IHtcbiAgcmVwbGFjZShfY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICB9LFxuICBzZXQoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0SWZNaXNzaW5nKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gdm9pZCAwID8gbmV4dFZhbHVlIDogY3VycmVudFZhbHVlO1xuICB9LFxuICB1bnNldChfY3VycmVudFZhbHVlLCBfbmV4dFZhbHVlKSB7XG4gIH0sXG4gIGRpZmZNYXRjaFBhdGNoKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgY29uc3QgW3Jlc3VsdF0gPSBhcHBseVBhdGNoZXMocGFyc2VQYXRjaChuZXh0VmFsdWUpLCBjdXJyZW50VmFsdWUsIHtcbiAgICAgIGFsbG93RXhjZWVkaW5nSW5kaWNlczogITBcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59LCBTVVBQT1JURURfUEFUQ0hfVFlQRVMgPSBPYmplY3Qua2V5cyhPUEVSQVRJT05TKTtcbmZ1bmN0aW9uIGFwcGx5KHZhbHVlLCBwYXRjaCkge1xuICBpZiAoIVNVUFBPUlRFRF9QQVRDSF9UWVBFUy5pbmNsdWRlcyhwYXRjaC50eXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVjZWl2ZWQgcGF0Y2ggb2YgdW5zdXBwb3J0ZWQgdHlwZTogXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBwYXRjaC50eXBlXG4gICAgICApfVwiIGZvciBzdHJpbmcuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gc3RyaW5nIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIGNvbnN0IGZ1bmMgPSBPUEVSQVRJT05TW3BhdGNoLnR5cGVdO1xuICBpZiAoZnVuYylcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSwgcGF0Y2gudmFsdWUpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBhdGNoIHR5cGVcIik7XG59XG5mdW5jdGlvbiBhcHBseUFsbCh2YWx1ZSwgcGF0Y2hlcykge1xuICByZXR1cm4gcGF0Y2hlcy5yZWR1Y2UoX2FwcGx5LCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBhcHBseVBhdGNoKHZhbHVlLCBwYXRjaCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBhcHBseSQzKHZhbHVlLCBwYXRjaCkgOiBpc1N0cmluZyh2YWx1ZSkgPyBhcHBseSh2YWx1ZSwgcGF0Y2gpIDogaXNPYmplY3QodmFsdWUpID8gYXBwbHkkMih2YWx1ZSwgcGF0Y2gpIDogYXBwbHkkMSh2YWx1ZSwgcGF0Y2gpO1xufVxuZnVuY3Rpb24gX2FwcGx5KHZhbHVlLCBwYXRjaCkge1xuICByZXR1cm4gYXBwbHlQYXRjaCh2YWx1ZSwgcGF0Y2gpO1xufVxuZnVuY3Rpb24gc2V0SWZNaXNzaW5nKHZhbHVlLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldElmTWlzc2luZ1wiLFxuICAgIHBhdGgsXG4gICAgdmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZNYXRjaFBhdGNoKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlLCBwYXRoID0gW10pIHtcbiAgY29uc3QgcGF0Y2hlcyA9IG1ha2VQYXRjaGVzKGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSwgcGF0Y2ggPSBzdHJpbmdpZnlQYXRjaGVzKHBhdGNoZXMpO1xuICByZXR1cm4geyB0eXBlOiBcImRpZmZNYXRjaFBhdGNoXCIsIHBhdGgsIHZhbHVlOiBwYXRjaCB9O1xufVxuZnVuY3Rpb24gaW5zZXJ0KGl0ZW1zLCBwb3NpdGlvbiwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJpbnNlcnRcIixcbiAgICBwYXRoLFxuICAgIHBvc2l0aW9uLFxuICAgIGl0ZW1zXG4gIH07XG59XG5mdW5jdGlvbiBzZXQodmFsdWUsIHBhdGggPSBbXSkge1xuICByZXR1cm4geyB0eXBlOiBcInNldFwiLCBwYXRoLCB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gdW5zZXQocGF0aCA9IFtdKSB7XG4gIHJldHVybiB7IHR5cGU6IFwidW5zZXRcIiwgcGF0aCB9O1xufVxuZnVuY3Rpb24gcHJlZml4UGF0aChwYXRjaCwgc2VnbWVudCkge1xuICByZXR1cm4ge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IFtzZWdtZW50LCAuLi5wYXRjaC5wYXRoXVxuICB9O1xufVxuZXhwb3J0IHtcbiAgYXBwbHlBbGwsXG4gIGRpZmZNYXRjaFBhdGNoLFxuICBpbnNlcnQsXG4gIHByZWZpeFBhdGgsXG4gIHNldCxcbiAgc2V0SWZNaXNzaW5nLFxuICB1bnNldFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value == null ? void 0 : value.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsc0NBQXNDLHFEQUFxRDtBQUN6VCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixpQ0FBaUMsZUFBZTtBQUN4STtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuY29tbW9ub3JnLWJsb2cvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzPzA2OGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX2V4Y2x1ZGVkID0gW1wiYmxvY2tcIiwgXCJsaXN0XCIsIFwibGlzdEl0ZW1cIiwgXCJtYXJrc1wiLCBcInR5cGVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wibGlzdEl0ZW1cIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJfa2V5XCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCB0LmluZGV4T2YobykgPj0gMCB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmIChlLmluZGV4T2YobikgPj0gMCkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBuZXN0TGlzdHMsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIHNwYW5Ub1BsYWluVGV4dCwgYnVpbGRNYXJrc1RyZWUgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB0b1BsYWluVGV4dCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGRlZmF1bHRMaXN0cyA9IHtcbiAgICBudW1iZXI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcIm9sXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgYnVsbGV0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0sXG4gIERlZmF1bHRMaXN0SXRlbSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBsaW5rID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICB2YWx1ZVxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJhXCIsIHtcbiAgICBocmVmOiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuaHJlZixcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgdW5kZXJsaW5lU3R5bGUgPSB7XG4gICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgfSxcbiAgZGVmYXVsdE1hcmtzID0ge1xuICAgIGVtOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJlbVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHN0cm9uZzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3Ryb25nXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgY29kZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiY29kZVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHVuZGVybGluZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogdW5kZXJsaW5lU3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIFwic3RyaWtlLXRocm91Z2hcIjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZGVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgbGlua1xuICB9LFxuICBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgW0Bwb3J0YWJsZXRleHQvcmVhY3RdIFVua25vd24gJHt0eXBlfSwgc3BlY2lmeSBhIGNvbXBvbmVudCBmb3IgaXQgaW4gdGhlIFxcYGNvbXBvbmVudHMuJHtwcm9wfVxcYCBwcm9wYCxcbiAgdW5rbm93blR5cGVXYXJuaW5nID0gdHlwZU5hbWUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSxcbiAgdW5rbm93bk1hcmtXYXJuaW5nID0gbWFya1R5cGUgPT4gZ2V0VGVtcGxhdGUoYG1hcmsgdHlwZSBcIiR7bWFya1R5cGV9XCJgLCBcIm1hcmtzXCIpLFxuICB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKGBibG9jayBzdHlsZSBcIiR7YmxvY2tTdHlsZX1cImAsIFwiYmxvY2tcIiksXG4gIHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksXG4gIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBpdGVtIHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RJdGVtXCIpO1xuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuY29uc3QgaGlkZGVuID0ge1xuICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gIH0sXG4gIERlZmF1bHRVbmtub3duVHlwZSA9ICh7XG4gICAgdmFsdWUsXG4gICAgaXNJbmxpbmVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHdhcm5pbmcgPSB1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpO1xuICAgIHJldHVybiBpc0lubGluZSA/IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi9qc3goXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSk7XG4gIH0sXG4gIERlZmF1bHRVbmtub3duTWFyayA9ICh7XG4gICAgbWFya1R5cGUsXG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgdW5rbm93bl9fcHRfX21hcmtfXyR7bWFya1R5cGV9YCxcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25MaXN0ID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdEhhcmRCcmVhayA9ICgpID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJyXCIsIHt9KSxcbiAgZGVmYXVsdEJsb2NrU3R5bGVzID0ge1xuICAgIG5vcm1hbDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJsb2NrcXVvdGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJsb2NrcXVvdGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDFcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDJcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDNcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDRcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDZcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgICB0eXBlczoge30sXG4gICAgYmxvY2s6IGRlZmF1bHRCbG9ja1N0eWxlcyxcbiAgICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICAgIGxpc3Q6IGRlZmF1bHRMaXN0cyxcbiAgICBsaXN0SXRlbTogRGVmYXVsdExpc3RJdGVtLFxuICAgIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgICB1bmtub3duVHlwZTogRGVmYXVsdFVua25vd25UeXBlLFxuICAgIHVua25vd25NYXJrOiBEZWZhdWx0VW5rbm93bk1hcmssXG4gICAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgICB1bmtub3duTGlzdEl0ZW06IERlZmF1bHRVbmtub3duTGlzdEl0ZW0sXG4gICAgdW5rbm93bkJsb2NrU3R5bGU6IERlZmF1bHRVbmtub3duQmxvY2tTdHlsZVxuICB9O1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJsb2NrLFxuICAgICAgbGlzdCxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbWFya3MsXG4gICAgICB0eXBlc1xuICAgIH0gPSBvdmVycmlkZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCksIHt9LCB7XG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcbiAgfSwgcmVzdCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV0sXG4gICAgcGFyZW50VmFsID0gcGFyZW50W2tleV07XG4gIHJldHVybiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXCJmdW5jdGlvblwiIHx8IG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT0gXCJmdW5jdGlvblwiID8gb3ZlcnJpZGUgOiBvdmVycmlkZSA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50VmFsKSwgb3ZlcnJpZGUpIDogcGFyZW50VmFsO1xufVxuZnVuY3Rpb24gUG9ydGFibGVUZXh0KHtcbiAgdmFsdWU6IGlucHV0LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gIGxpc3ROZXN0aW5nTW9kZSxcbiAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xufSkge1xuICBjb25zdCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50ID0gbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgfHwgbm9vcCxcbiAgICBibG9ja3MgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XSxcbiAgICBuZXN0ZWQgPSBuZXN0TGlzdHMoYmxvY2tzLCBsaXN0TmVzdGluZ01vZGUgfHwgTElTVF9ORVNUX01PREVfSFRNTCksXG4gICAgY29tcG9uZW50cyA9IHVzZU1lbW8oKCkgPT4gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsIFtjb21wb25lbnRPdmVycmlkZXNdKSxcbiAgICByZW5kZXJOb2RlID0gdXNlTWVtbygoKSA9PiBnZXROb2RlUmVuZGVyZXIoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCksIFtjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50XSksXG4gICAgcmVuZGVyZWQgPSBuZXN0ZWQubWFwKChub2RlLCBpbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHJlbmRlcmVkXG4gIH0pO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmVcbiAgICAgIH0gPSBvcHRpb25zLFxuICAgICAga2V5ID0gbm9kZS5fa2V5IHx8IGBub2RlLSR7aW5kZXh9YDtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChub2RlKSA/IHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2sobm9kZSkgPyByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4obm9kZSkgPyByZW5kZXJTcGFuKG5vZGUsIGluZGV4LCBrZXkpIDogaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSA/IHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkgPyByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSA/IHJlbmRlclRleHQobm9kZSwga2V5KSA6IHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fdHlwZSBpbiBjb21wb25lbnRzLnR5cGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCB0cmVlID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHJlbmRlcmVyID0gY29tcG9uZW50cy5saXN0SXRlbSxcbiAgICAgIExpID0gKHR5cGVvZiByZW5kZXJlciA9PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbTtcbiAgICBpZiAoTGkgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICB0eXBlOiBzdHlsZSxcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSA9IG5vZGUsXG4gICAgICAgIGJsb2NrTm9kZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGJsb2NrTm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGksIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICAgICAgX2tleTogYGxpLSR7aW5kZXh9LSR7Y2hpbGRJbmRleH1gXG4gICAgICAgIH0pLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSksXG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsXG4gICAgICBMaXN0ID0gKHR5cGVvZiBjb21wb25lbnQgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50IDogY29tcG9uZW50W25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChMaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLFxuICAgICAgICB0eXBlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGlzdCwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyU3Bhbihub2RlLCBfaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFya0RlZixcbiAgICAgICAgbWFya1R5cGUsXG4gICAgICAgIG1hcmtLZXlcbiAgICAgIH0gPSBub2RlLFxuICAgICAgU3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcmssXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIFNwYW4gPT09IGNvbXBvbmVudHMudW5rbm93bk1hcmsgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTWFya1dhcm5pbmcobWFya1R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJtYXJrXCIsXG4gICAgICB0eXBlOiBtYXJrVHlwZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goU3Bhbiwge1xuICAgICAgdGV4dDogc3BhblRvUGxhaW5UZXh0KG5vZGUpLFxuICAgICAgdmFsdWU6IG1hcmtEZWYsXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIG1hcmtLZXksXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3QgX3NlcmlhbGl6ZUJsb2NrID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBfa2V5XG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3NlcmlhbGl6ZUJsb2NrLCBfZXhjbHVkZWQzKSxcbiAgICAgIHN0eWxlID0gcHJvcHMubm9kZS5zdHlsZSB8fCBcIm5vcm1hbFwiLFxuICAgICAgQmxvY2sgPSAodHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50cy5ibG9jayA6IGNvbXBvbmVudHMuYmxvY2tbc3R5bGVdKSB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xuICAgIHJldHVybiBCbG9jayA9PT0gY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZSAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25CbG9ja1N0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcbiAgICAgIHR5cGU6IHN0eWxlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChCbG9jaywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICB2YWx1ZTogcHJvcHMubm9kZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUsIGtleSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIEhhcmRCcmVhayA/IC8qIEBfX1BVUkVfXyAqL2pzeChIYXJkQnJlYWssIHt9LCBrZXkpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcobm9kZS5fdHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXG4gICAgICB0eXBlOiBub2RlLl90eXBlXG4gICAgfSk7XG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goVW5rbm93blR5cGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgICB2YWx1ZTogbm9kZSxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9LFxuICAgICAgTm9kZSA9IGNvbXBvbmVudHMudHlwZXNbbm9kZS5fdHlwZV07XG4gICAgcmV0dXJuIE5vZGUgPyAvKiBAX19QVVJFX18gKi9qc3goTm9kZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0gPSBvcHRpb25zLFxuICAgIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBfa2V5OiBub2RlLl9rZXkgfHwgYGJsb2NrLSR7aW5kZXh9YCxcbiAgICBjaGlsZHJlbixcbiAgICBpbmRleCxcbiAgICBpc0lubGluZSxcbiAgICBub2RlXG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCB7IFBvcnRhYmxlVGV4dCwgZGVmYXVsdENvbXBvbmVudHMsIG1lcmdlQ29tcG9uZW50cywgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /^\\s/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0EsMklBQTJJO0FBQzNJO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1CQUFtQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQixNQUFNLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ2lTO0FBQ2pTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5jb21tb25vcmctYmxvZy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3Rvb2xraXQvZGlzdC9pbmRleC5qcz82ZDk2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID4gXCJ1XCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KG1hcmsgPT4gdHlwZW9mIG1hcmsgPT0gXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBibG9jayBkb2Vzbid0IF9oYXZlXyB0byBiZSBuYW1lZCAnYmxvY2snIC0gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgLy8gYWxsb3dlZCBjaGlsZCB0eXBlcyBhbmQgbWFya3MsIG9uZSBtaWdodCBuYW1lIHRoZW0gZGlmZmVyZW50bHlcbiAgICB0eXBlb2Ygbm9kZS5fdHlwZSA9PSBcInN0cmluZ1wiICYmXG4gICAgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIChcbiAgICAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJlxuICAgIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoZGVmID0+IHR5cGVvZiBkZWYuX2tleSA9PSBcInN0cmluZ1wiKSkgJiZcbiAgICAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiZcbiAgICAvLyBBbGwgY2hpbGRyZW4gYXJlIG9iamVjdHMgd2l0aCBgX3R5cGVgICh1c3VhbGx5IHNwYW5zLCBidXQgY2FuIGNvbnRhaW4gb3RoZXIgc3R1ZmYpXG4gICAgbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spICYmIFwibGlzdEl0ZW1cIiBpbiBibG9jayAmJiB0eXBlb2YgYmxvY2subGlzdEl0ZW0gPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGJsb2NrLmxldmVsID4gXCJ1XCIgfHwgdHlwZW9mIGJsb2NrLmxldmVsID09IFwibnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChibG9jaykge1xuICByZXR1cm4gYmxvY2suX3R5cGUgPT09IFwiQGxpc3RcIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oc3Bhbikge1xuICByZXR1cm4gc3Bhbi5fdHlwZSA9PT0gXCJAc3BhblwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJAdGV4dFwiO1xufVxuY29uc3Qga25vd25EZWNvcmF0b3JzID0gW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJjb2RlXCIsIFwidW5kZXJsaW5lXCIsIFwic3RyaWtlLXRocm91Z2hcIl07XG5mdW5jdGlvbiBzb3J0TWFya3NCeU9jY3VyZW5jZXMoc3BhbiwgaW5kZXgsIGJsb2NrQ2hpbGRyZW4pIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgfHwgIXNwYW4ubWFya3MpIHJldHVybiBbXTtcbiAgaWYgKCFzcGFuLm1hcmtzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3Muc2xpY2UoKSxcbiAgICBvY2N1cmVuY2VzID0ge307XG4gIHJldHVybiBtYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgIG9jY3VyZW5jZXNbbWFya10gPSAxO1xuICAgIGZvciAobGV0IHNpYmxpbmdJbmRleCA9IGluZGV4ICsgMTsgc2libGluZ0luZGV4IDwgYmxvY2tDaGlsZHJlbi5sZW5ndGg7IHNpYmxpbmdJbmRleCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gYmxvY2tDaGlsZHJlbltzaWJsaW5nSW5kZXhdO1xuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNQb3J0YWJsZVRleHRTcGFuKHNpYmxpbmcpICYmIEFycmF5LmlzQXJyYXkoc2libGluZy5tYXJrcykgJiYgc2libGluZy5tYXJrcy5pbmRleE9mKG1hcmspICE9PSAtMSkgb2NjdXJlbmNlc1ttYXJrXSsrO2Vsc2UgYnJlYWs7XG4gICAgfVxuICB9KSwgbWFya3Muc29ydCgobWFya0EsIG1hcmtCKSA9PiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSk7XG59XG5mdW5jdGlvbiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSB7XG4gIGNvbnN0IGFPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQV0sXG4gICAgYk9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtCXTtcbiAgaWYgKGFPY2N1cmVuY2VzICE9PSBiT2NjdXJlbmNlcykgcmV0dXJuIGJPY2N1cmVuY2VzIC0gYU9jY3VyZW5jZXM7XG4gIGNvbnN0IGFLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtBKSxcbiAgICBiS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQik7XG4gIHJldHVybiBhS25vd25Qb3MgIT09IGJLbm93blBvcyA/IGFLbm93blBvcyAtIGJLbm93blBvcyA6IG1hcmtBLmxvY2FsZUNvbXBhcmUobWFya0IpO1xufVxuZnVuY3Rpb24gYnVpbGRNYXJrc1RyZWUoYmxvY2spIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbWFya0RlZnMgPSBbXVxuICB9ID0gYmxvY2s7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBzb3J0ZWRNYXJrcyA9IGNoaWxkcmVuLm1hcChzb3J0TWFya3NCeU9jY3VyZW5jZXMpLFxuICAgIHJvb3ROb2RlID0ge1xuICAgICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG1hcmtUeXBlOiBcIjx1bmtub3duPlwiXG4gICAgfTtcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzcGFuID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCFzcGFuKSBjb250aW51ZTtcbiAgICBjb25zdCBtYXJrc05lZWRlZCA9IHNvcnRlZE1hcmtzW2ldIHx8IFtdO1xuICAgIGxldCBwb3MgPSAxO1xuICAgIGlmIChub2RlU3RhY2subGVuZ3RoID4gMSkgZm9yIChwb3M7IHBvcyA8IG5vZGVTdGFjay5sZW5ndGg7IHBvcysrKSB7XG4gICAgICBjb25zdCBtYXJrID0gKChfYSA9IG5vZGVTdGFja1twb3NdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya0tleSkgfHwgXCJcIixcbiAgICAgICAgaW5kZXggPSBtYXJrc05lZWRlZC5pbmRleE9mKG1hcmspO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICBtYXJrc05lZWRlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBub2RlU3RhY2sgPSBub2RlU3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBtYXJrS2V5IG9mIG1hcmtzTmVlZGVkKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWYgPSBtYXJrRGVmcy5maW5kKGRlZiA9PiBkZWYuX2tleSA9PT0gbWFya0tleSksXG4gICAgICAgICAgbWFya1R5cGUgPSBtYXJrRGVmID8gbWFya0RlZi5fdHlwZSA6IG1hcmtLZXksXG4gICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXksXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgICAgbWFya1R5cGUsXG4gICAgICAgICAgICBtYXJrS2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKSwgbm9kZVN0YWNrLnB1c2gobm9kZSksIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGFuLnRleHQuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSBsaW5lcy5sZW5ndGg7IGxpbmUtLSA+IDE7KSBsaW5lcy5zcGxpY2UobGluZSwgMCwgYFxuYCk7XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KGxpbmVzLm1hcCh0ZXh0ID0+ICh7XG4gICAgICAgICAgX3R5cGU6IFwiQHRleHRcIixcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGVsc2UgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykpIHtcbiAgICAgICAgdHJlZS5wdXNoKGJsb2NrKSwgY3VycmVudExpc3QgPSB2b2lkIDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGlzdCkge1xuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA+IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdExpc3RJdGVtID0gY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBuZXdMYXN0Q2hpbGQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxhc3RMaXN0SXRlbSksIHt9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXdMYXN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKG5ld0xpc3QpO1xuICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwgYmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5saXN0SXRlbSAhPT0gY3VycmVudExpc3QubGlzdEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7XG4gICAgICAgICAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGlzdEl0ZW0gPT09IGJsb2NrLmxpc3RJdGVtKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBzdGF0ZSBlbmNvdW50ZXJlZCBmb3IgYmxvY2tcIiwgYmxvY2spLCB0cmVlLnB1c2goYmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGxpc3QpIHtcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGxpc3RGcm9tQmxvY2soYmxvY2ssIGluZGV4LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IFwiQGxpc3RcIixcbiAgICBfa2V5OiBgJHtibG9jay5fa2V5IHx8IGAke2luZGV4fWB9LXBhcmVudGAsXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMSxcbiAgICBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIsXG4gICAgZmlsdGVyT25UeXBlID0gdHlwZW9mIG1hdGNoaW5nLmxpc3RJdGVtID09IFwic3RyaW5nXCI7XG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSByZXR1cm4gcm9vdE5vZGU7XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlLmNoaWxkcmVuW3Jvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUoY3VycmVudCkgPyB0ZXh0ICs9IGN1cnJlbnQudGV4dCA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkgJiYgKHRleHQgKz0gc3BhblRvUGxhaW5UZXh0KGN1cnJlbnQpKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBsZWFkaW5nU3BhY2UgPSAvXlxccy8sXG4gIHRyYWlsaW5nU3BhY2UgPSAvXlxccy87XG5mdW5jdGlvbiB0b1BsYWluVGV4dChibG9jaykge1xuICBjb25zdCBibG9ja3MgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gYmxvY2tzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BvcnRhYmxlVGV4dEJsb2NrKGN1cnJlbnQpKSByZXR1cm47XG4gICAgbGV0IHBhZCA9ICExO1xuICAgIGN1cnJlbnQuY2hpbGRyZW4uZm9yRWFjaChzcGFuID0+IHtcbiAgICAgIGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSA/ICh0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCIsIHRleHQgKz0gc3Bhbi50ZXh0LCBwYWQgPSAhMSkgOiBwYWQgPSAhMDtcbiAgICB9KSwgaW5kZXggIT09IGJsb2Nrcy5sZW5ndGggLSAxICYmICh0ZXh0ICs9IGBcblxuYCk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiLFxuICBMSVNUX05FU1RfTU9ERV9ESVJFQ1QgPSBcImRpcmVjdFwiO1xuZXhwb3J0IHsgTElTVF9ORVNUX01PREVfRElSRUNULCBMSVNUX05FU1RfTU9ERV9IVE1MLCBidWlsZE1hcmtzVHJlZSwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBuZXN0TGlzdHMsIHNvcnRNYXJrc0J5T2NjdXJlbmNlcywgc3BhblRvUGxhaW5UZXh0LCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @portabletext/toolkit */ \"(rsc)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nconst _excluded = [\"block\", \"list\", \"listItem\", \"marks\", \"types\"],\n  _excluded2 = [\"listItem\"],\n  _excluded3 = [\"_key\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\n\n\n\n\nconst defaultLists = {\n    number: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ol\", {\n      children\n    }),\n    bullet: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n      children\n    })\n  },\n  DefaultListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  link = ({\n    children,\n    value\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n    href: value == null ? void 0 : value.href,\n    children\n  }),\n  underlineStyle = {\n    textDecoration: \"underline\"\n  },\n  defaultMarks = {\n    em: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"em\", {\n      children\n    }),\n    strong: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"strong\", {\n      children\n    }),\n    code: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"code\", {\n      children\n    }),\n    underline: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: underlineStyle,\n      children\n    }),\n    \"strike-through\": ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"del\", {\n      children\n    }),\n    link\n  },\n  getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`,\n  unknownTypeWarning = typeName => getTemplate(`block type \"${typeName}\"`, \"types\"),\n  unknownMarkWarning = markType => getTemplate(`mark type \"${markType}\"`, \"marks\"),\n  unknownBlockStyleWarning = blockStyle => getTemplate(`block style \"${blockStyle}\"`, \"block\"),\n  unknownListStyleWarning = listStyle => getTemplate(`list style \"${listStyle}\"`, \"list\"),\n  unknownListItemStyleWarning = listStyle => getTemplate(`list item style \"${listStyle}\"`, \"listItem\");\nfunction printWarning(message) {\n  console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n  },\n  DefaultUnknownType = ({\n    value,\n    isInline\n  }) => {\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n      style: hidden,\n      children: warning\n    }) : /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      style: hidden,\n      children: warning\n    });\n  },\n  DefaultUnknownMark = ({\n    markType,\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n    className: `unknown__pt__mark__${markType}`,\n    children\n  }),\n  DefaultUnknownBlockStyle = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n    children\n  }),\n  DefaultUnknownList = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"ul\", {\n    children\n  }),\n  DefaultUnknownListItem = ({\n    children\n  }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"li\", {\n    children\n  }),\n  DefaultHardBreak = () => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"br\", {}),\n  defaultBlockStyles = {\n    normal: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"p\", {\n      children\n    }),\n    blockquote: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"blockquote\", {\n      children\n    }),\n    h1: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h1\", {\n      children\n    }),\n    h2: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n      children\n    }),\n    h3: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n      children\n    }),\n    h4: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h4\", {\n      children\n    }),\n    h5: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h5\", {\n      children\n    }),\n    h6: ({\n      children\n    }) => /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h6\", {\n      children\n    })\n  },\n  defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n  };\nfunction mergeComponents(parent, overrides) {\n  const {\n      block,\n      list,\n      listItem,\n      marks,\n      types\n    } = overrides,\n    rest = _objectWithoutProperties(overrides, _excluded);\n  return _objectSpread(_objectSpread({}, parent), {}, {\n    block: mergeDeeply(parent, overrides, \"block\"),\n    list: mergeDeeply(parent, overrides, \"list\"),\n    listItem: mergeDeeply(parent, overrides, \"listItem\"),\n    marks: mergeDeeply(parent, overrides, \"marks\"),\n    types: mergeDeeply(parent, overrides, \"types\")\n  }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n  const override = overrides[key],\n    parentVal = parent[key];\n  return typeof override == \"function\" || override && typeof parentVal == \"function\" ? override : override ? _objectSpread(_objectSpread({}, parentVal), override) : parentVal;\n}\nfunction PortableText({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning\n}) {\n  const handleMissingComponent = missingComponentHandler || noop,\n    blocks = Array.isArray(input) ? input : [input],\n    nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.LIST_NEST_MODE_HTML),\n    components = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]),\n    renderNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]),\n    rendered = nested.map((node, index) => renderNode({\n      node,\n      index,\n      isInline: !1,\n      renderNode\n    }));\n  return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: rendered\n  });\n}\nconst getNodeRenderer = (components, handleMissingComponent) => {\n  function renderNode(options) {\n    const {\n        node,\n        index,\n        isInline\n      } = options,\n      key = node._key || `node-${index}`;\n    return (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitList)(node) ? renderList(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextListItemBlock)(node) ? renderListItem(node, index, key) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitSpan)(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextBlock)(node) ? renderBlock(node, index, key, isInline) : (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPortableTextToolkitTextNode)(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);\n  }\n  function hasCustomComponentForNode(node) {\n    return node._type in components.types;\n  }\n  function renderListItem(node, index, key) {\n    const tree = serializeBlock({\n        node,\n        index,\n        isInline: !1,\n        renderNode\n      }),\n      renderer = components.listItem,\n      Li = (typeof renderer == \"function\" ? renderer : renderer[node.listItem]) || components.unknownListItem;\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: \"listItemStyle\"\n      });\n    }\n    let children = tree.children;\n    if (node.style && node.style !== \"normal\") {\n      const {\n          listItem\n        } = node,\n        blockNode = _objectWithoutProperties(node, _excluded2);\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: !1,\n        renderNode\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Li, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderList(node, index, key) {\n    const children = node.children.map((child, childIndex) => renderNode({\n        node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n          _key: `li-${index}-${childIndex}`\n        }),\n        index: childIndex,\n        isInline: !1,\n        renderNode\n      })),\n      component = components.list,\n      List = (typeof component == \"function\" ? component : component[node.listItem]) || components.unknownList;\n    if (List === components.unknownList) {\n      const style = node.listItem || \"bullet\";\n      handleMissingComponent(unknownListStyleWarning(style), {\n        nodeType: \"listStyle\",\n        type: style\n      });\n    }\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(List, {\n      value: node,\n      index,\n      isInline: !1,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderSpan(node, _index, key) {\n    const {\n        markDef,\n        markType,\n        markKey\n      } = node,\n      Span = components.marks[markType] || components.unknownMark,\n      children = node.children.map((child, childIndex) => renderNode({\n        node: child,\n        index: childIndex,\n        isInline: !0,\n        renderNode\n      }));\n    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {\n      nodeType: \"mark\",\n      type: markType\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Span, {\n      text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.spanToPlainText)(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children\n    }, key);\n  }\n  function renderBlock(node, index, key, isInline) {\n    const _serializeBlock = serializeBlock({\n        node,\n        index,\n        isInline,\n        renderNode\n      }),\n      {\n        _key\n      } = _serializeBlock,\n      props = _objectWithoutProperties(_serializeBlock, _excluded3),\n      style = props.node.style || \"normal\",\n      Block = (typeof components.block == \"function\" ? components.block : components.block[style]) || components.unknownBlockStyle;\n    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {\n      nodeType: \"blockStyle\",\n      type: style\n    }), /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n      value: props.node,\n      renderNode\n    }), key);\n  }\n  function renderText(node, key) {\n    if (node.text === `\n`) {\n      const HardBreak = components.hardBreak;\n      return HardBreak ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HardBreak, {}, key) : `\n`;\n    }\n    return node.text;\n  }\n  function renderUnknownType(node, index, key, isInline) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode\n    };\n    handleMissingComponent(unknownTypeWarning(node._type), {\n      nodeType: \"block\",\n      type: node._type\n    });\n    const UnknownType = components.unknownType;\n    return /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n  }\n  function renderCustomBlock(node, index, key, isInline) {\n    const nodeOptions = {\n        value: node,\n        isInline,\n        index,\n        renderNode\n      },\n      Node = components.types[node._type];\n    return Node ? /* @__PURE__ */(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n  }\n  return renderNode;\n};\nfunction serializeBlock(options) {\n  const {\n      node,\n      index,\n      isInline,\n      renderNode\n    } = options,\n    children = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_2__.buildMarksTree)(node).map((child, i) => renderNode({\n      node: child,\n      isInline: !0,\n      index: i,\n      renderNode\n    }));\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node\n  };\n}\nfunction noop() {}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsc0NBQXNDLHFEQUFxRDtBQUN6VCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixpQ0FBaUMsZUFBZTtBQUN4STtBQUM2TDtBQUMzTDtBQUNwQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixzREFBRztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isc0RBQUc7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssb0JBQW9CLHNEQUFHO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLG9CQUFvQixzREFBRztBQUM1QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxvQkFB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O0FBQ0E7QUFDQTtBQUN5RTtBQUN6RSIsInNvdXJjZXMiOlsid2VicGFjazovL3VuY29tbW9ub3JnLWJsb2cvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzPzRhNzYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgX2V4Y2x1ZGVkID0gW1wiYmxvY2tcIiwgXCJsaXN0XCIsIFwibGlzdEl0ZW1cIiwgXCJtYXJrc1wiLCBcInR5cGVzXCJdLFxuICBfZXhjbHVkZWQyID0gW1wibGlzdEl0ZW1cIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJfa2V5XCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCB0LmluZGV4T2YobykgPj0gMCB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmIChlLmluZGV4T2YobikgPj0gMCkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBuZXN0TGlzdHMsIExJU1RfTkVTVF9NT0RFX0hUTUwsIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUsIHNwYW5Ub1BsYWluVGV4dCwgYnVpbGRNYXJrc1RyZWUgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC90b29sa2l0XCI7XG5pbXBvcnQgeyB0b1BsYWluVGV4dCB9IGZyb20gXCJAcG9ydGFibGV0ZXh0L3Rvb2xraXRcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGRlZmF1bHRMaXN0cyA9IHtcbiAgICBudW1iZXI6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcIm9sXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgYnVsbGV0OiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0sXG4gIERlZmF1bHRMaXN0SXRlbSA9ICh7XG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwibGlcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pLFxuICBsaW5rID0gKHtcbiAgICBjaGlsZHJlbixcbiAgICB2YWx1ZVxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJhXCIsIHtcbiAgICBocmVmOiB2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuaHJlZixcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgdW5kZXJsaW5lU3R5bGUgPSB7XG4gICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgfSxcbiAgZGVmYXVsdE1hcmtzID0ge1xuICAgIGVtOiAoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJlbVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHN0cm9uZzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3Ryb25nXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgY29kZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiY29kZVwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIHVuZGVybGluZTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgICBzdHlsZTogdW5kZXJsaW5lU3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIFwic3RyaWtlLXRocm91Z2hcIjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiZGVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSksXG4gICAgbGlua1xuICB9LFxuICBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBgW0Bwb3J0YWJsZXRleHQvcmVhY3RdIFVua25vd24gJHt0eXBlfSwgc3BlY2lmeSBhIGNvbXBvbmVudCBmb3IgaXQgaW4gdGhlIFxcYGNvbXBvbmVudHMuJHtwcm9wfVxcYCBwcm9wYCxcbiAgdW5rbm93blR5cGVXYXJuaW5nID0gdHlwZU5hbWUgPT4gZ2V0VGVtcGxhdGUoYGJsb2NrIHR5cGUgXCIke3R5cGVOYW1lfVwiYCwgXCJ0eXBlc1wiKSxcbiAgdW5rbm93bk1hcmtXYXJuaW5nID0gbWFya1R5cGUgPT4gZ2V0VGVtcGxhdGUoYG1hcmsgdHlwZSBcIiR7bWFya1R5cGV9XCJgLCBcIm1hcmtzXCIpLFxuICB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKGBibG9jayBzdHlsZSBcIiR7YmxvY2tTdHlsZX1cImAsIFwiYmxvY2tcIiksXG4gIHVua25vd25MaXN0U3R5bGVXYXJuaW5nID0gbGlzdFN0eWxlID0+IGdldFRlbXBsYXRlKGBsaXN0IHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RcIiksXG4gIHVua25vd25MaXN0SXRlbVN0eWxlV2FybmluZyA9IGxpc3RTdHlsZSA9PiBnZXRUZW1wbGF0ZShgbGlzdCBpdGVtIHN0eWxlIFwiJHtsaXN0U3R5bGV9XCJgLCBcImxpc3RJdGVtXCIpO1xuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuY29uc3QgaGlkZGVuID0ge1xuICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gIH0sXG4gIERlZmF1bHRVbmtub3duVHlwZSA9ICh7XG4gICAgdmFsdWUsXG4gICAgaXNJbmxpbmVcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHdhcm5pbmcgPSB1bmtub3duVHlwZVdhcm5pbmcodmFsdWUuX3R5cGUpO1xuICAgIHJldHVybiBpc0lubGluZSA/IC8qIEBfX1BVUkVfXyAqL2pzeChcInNwYW5cIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi9qc3goXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IGhpZGRlbixcbiAgICAgIGNoaWxkcmVuOiB3YXJuaW5nXG4gICAgfSk7XG4gIH0sXG4gIERlZmF1bHRVbmtub3duTWFyayA9ICh7XG4gICAgbWFya1R5cGUsXG4gICAgY2hpbGRyZW5cbiAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgdW5rbm93bl9fcHRfX21hcmtfXyR7bWFya1R5cGV9YCxcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJwXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdFVua25vd25MaXN0ID0gKHtcbiAgICBjaGlsZHJlblxuICB9KSA9PiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSksXG4gIERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSAoe1xuICAgIGNoaWxkcmVuXG4gIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KSxcbiAgRGVmYXVsdEhhcmRCcmVhayA9ICgpID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJyXCIsIHt9KSxcbiAgZGVmYXVsdEJsb2NrU3R5bGVzID0ge1xuICAgIG5vcm1hbDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pLFxuICAgIGJsb2NrcXVvdGU6ICh7XG4gICAgICBjaGlsZHJlblxuICAgIH0pID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJsb2NrcXVvdGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDFcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDJcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoMzogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDNcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNDogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDRcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNTogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSxcbiAgICBoNjogKHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSkgPT4gLyogQF9fUFVSRV9fICovanN4KFwiaDZcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9LFxuICBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgICB0eXBlczoge30sXG4gICAgYmxvY2s6IGRlZmF1bHRCbG9ja1N0eWxlcyxcbiAgICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICAgIGxpc3Q6IGRlZmF1bHRMaXN0cyxcbiAgICBsaXN0SXRlbTogRGVmYXVsdExpc3RJdGVtLFxuICAgIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgICB1bmtub3duVHlwZTogRGVmYXVsdFVua25vd25UeXBlLFxuICAgIHVua25vd25NYXJrOiBEZWZhdWx0VW5rbm93bk1hcmssXG4gICAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgICB1bmtub3duTGlzdEl0ZW06IERlZmF1bHRVbmtub3duTGlzdEl0ZW0sXG4gICAgdW5rbm93bkJsb2NrU3R5bGU6IERlZmF1bHRVbmtub3duQmxvY2tTdHlsZVxuICB9O1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJsb2NrLFxuICAgICAgbGlzdCxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbWFya3MsXG4gICAgICB0eXBlc1xuICAgIH0gPSBvdmVycmlkZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCksIHt9LCB7XG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcbiAgfSwgcmVzdCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV0sXG4gICAgcGFyZW50VmFsID0gcGFyZW50W2tleV07XG4gIHJldHVybiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXCJmdW5jdGlvblwiIHx8IG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT0gXCJmdW5jdGlvblwiID8gb3ZlcnJpZGUgOiBvdmVycmlkZSA/IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcGFyZW50VmFsKSwgb3ZlcnJpZGUpIDogcGFyZW50VmFsO1xufVxuZnVuY3Rpb24gUG9ydGFibGVUZXh0KHtcbiAgdmFsdWU6IGlucHV0LFxuICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gIGxpc3ROZXN0aW5nTW9kZSxcbiAgb25NaXNzaW5nQ29tcG9uZW50OiBtaXNzaW5nQ29tcG9uZW50SGFuZGxlciA9IHByaW50V2FybmluZ1xufSkge1xuICBjb25zdCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50ID0gbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgfHwgbm9vcCxcbiAgICBibG9ja3MgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XSxcbiAgICBuZXN0ZWQgPSBuZXN0TGlzdHMoYmxvY2tzLCBsaXN0TmVzdGluZ01vZGUgfHwgTElTVF9ORVNUX01PREVfSFRNTCksXG4gICAgY29tcG9uZW50cyA9IHVzZU1lbW8oKCkgPT4gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHMsIFtjb21wb25lbnRPdmVycmlkZXNdKSxcbiAgICByZW5kZXJOb2RlID0gdXNlTWVtbygoKSA9PiBnZXROb2RlUmVuZGVyZXIoY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCksIFtjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50XSksXG4gICAgcmVuZGVyZWQgPSBuZXN0ZWQubWFwKChub2RlLCBpbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHJlbmRlcmVkXG4gIH0pO1xufVxuY29uc3QgZ2V0Tm9kZVJlbmRlcmVyID0gKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpID0+IHtcbiAgZnVuY3Rpb24gcmVuZGVyTm9kZShvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmVcbiAgICAgIH0gPSBvcHRpb25zLFxuICAgICAga2V5ID0gbm9kZS5fa2V5IHx8IGBub2RlLSR7aW5kZXh9YDtcbiAgICByZXR1cm4gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChub2RlKSA/IHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkgOiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2sobm9kZSkgPyByZW5kZXJMaXN0SXRlbShub2RlLCBpbmRleCwga2V5KSA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4obm9kZSkgPyByZW5kZXJTcGFuKG5vZGUsIGluZGV4LCBrZXkpIDogaGFzQ3VzdG9tQ29tcG9uZW50Rm9yTm9kZShub2RlKSA/IHJlbmRlckN1c3RvbUJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSA6IGlzUG9ydGFibGVUZXh0QmxvY2sobm9kZSkgPyByZW5kZXJCbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkgOiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSA/IHJlbmRlclRleHQobm9kZSwga2V5KSA6IHJlbmRlclVua25vd25UeXBlKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5fdHlwZSBpbiBjb21wb25lbnRzLnR5cGVzO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpIHtcbiAgICBjb25zdCB0cmVlID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSxcbiAgICAgIHJlbmRlcmVyID0gY29tcG9uZW50cy5saXN0SXRlbSxcbiAgICAgIExpID0gKHR5cGVvZiByZW5kZXJlciA9PSBcImZ1bmN0aW9uXCIgPyByZW5kZXJlciA6IHJlbmRlcmVyW25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0SXRlbTtcbiAgICBpZiAoTGkgPT09IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RJdGVtU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICB0eXBlOiBzdHlsZSxcbiAgICAgICAgbm9kZVR5cGU6IFwibGlzdEl0ZW1TdHlsZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgICBpZiAobm9kZS5zdHlsZSAmJiBub2RlLnN0eWxlICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSA9IG5vZGUsXG4gICAgICAgIGJsb2NrTm9kZSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGJsb2NrTm9kZSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGksIHtcbiAgICAgIHZhbHVlOiBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogITEsXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckxpc3Qobm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBjaGlsZEluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICAgICAgX2tleTogYGxpLSR7aW5kZXh9LSR7Y2hpbGRJbmRleH1gXG4gICAgICAgIH0pLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICExLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSksXG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3QsXG4gICAgICBMaXN0ID0gKHR5cGVvZiBjb21wb25lbnQgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50IDogY29tcG9uZW50W25vZGUubGlzdEl0ZW1dKSB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChMaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLFxuICAgICAgICB0eXBlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGlzdCwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiAhMSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyU3Bhbihub2RlLCBfaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbWFya0RlZixcbiAgICAgICAgbWFya1R5cGUsXG4gICAgICAgIG1hcmtLZXlcbiAgICAgIH0gPSBub2RlLFxuICAgICAgU3BhbiA9IGNvbXBvbmVudHMubWFya3NbbWFya1R5cGVdIHx8IGNvbXBvbmVudHMudW5rbm93bk1hcmssXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBpbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgaXNJbmxpbmU6ICEwLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KSk7XG4gICAgcmV0dXJuIFNwYW4gPT09IGNvbXBvbmVudHMudW5rbm93bk1hcmsgJiYgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTWFya1dhcm5pbmcobWFya1R5cGUpLCB7XG4gICAgICBub2RlVHlwZTogXCJtYXJrXCIsXG4gICAgICB0eXBlOiBtYXJrVHlwZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi9qc3goU3Bhbiwge1xuICAgICAgdGV4dDogc3BhblRvUGxhaW5UZXh0KG5vZGUpLFxuICAgICAgdmFsdWU6IG1hcmtEZWYsXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIG1hcmtLZXksXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3QgX3NlcmlhbGl6ZUJsb2NrID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBfa2V5XG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3NlcmlhbGl6ZUJsb2NrLCBfZXhjbHVkZWQzKSxcbiAgICAgIHN0eWxlID0gcHJvcHMubm9kZS5zdHlsZSB8fCBcIm5vcm1hbFwiLFxuICAgICAgQmxvY2sgPSAodHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT0gXCJmdW5jdGlvblwiID8gY29tcG9uZW50cy5ibG9jayA6IGNvbXBvbmVudHMuYmxvY2tbc3R5bGVdKSB8fCBjb21wb25lbnRzLnVua25vd25CbG9ja1N0eWxlO1xuICAgIHJldHVybiBCbG9jayA9PT0gY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZSAmJiBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25CbG9ja1N0eWxlV2FybmluZyhzdHlsZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrU3R5bGVcIixcbiAgICAgIHR5cGU6IHN0eWxlXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqL2pzeChCbG9jaywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICB2YWx1ZTogcHJvcHMubm9kZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUsIGtleSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IGBcbmApIHtcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIEhhcmRCcmVhayA/IC8qIEBfX1BVUkVfXyAqL2pzeChIYXJkQnJlYWssIHt9LCBrZXkpIDogYFxuYDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcobm9kZS5fdHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXG4gICAgICB0eXBlOiBub2RlLl90eXBlXG4gICAgfSk7XG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goVW5rbm93blR5cGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgICB2YWx1ZTogbm9kZSxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIGluZGV4LFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9LFxuICAgICAgTm9kZSA9IGNvbXBvbmVudHMudHlwZXNbbm9kZS5fdHlwZV07XG4gICAgcmV0dXJuIE5vZGUgPyAvKiBAX19QVVJFX18gKi9qc3goTm9kZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0gPSBvcHRpb25zLFxuICAgIGNoaWxkcmVuID0gYnVpbGRNYXJrc1RyZWUobm9kZSkubWFwKChjaGlsZCwgaSkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGlzSW5saW5lOiAhMCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgcmV0dXJuIHtcbiAgICBfa2V5OiBub2RlLl9rZXkgfHwgYGJsb2NrLSR7aW5kZXh9YCxcbiAgICBjaGlsZHJlbixcbiAgICBpbmRleCxcbiAgICBpc0lubGluZSxcbiAgICBub2RlXG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCB7IFBvcnRhYmxlVGV4dCwgZGVmYXVsdENvbXBvbmVudHMsIG1lcmdlQ29tcG9uZW50cywgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && (\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    !(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) &&\n    // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every(def => typeof def._key == \"string\")) &&\n    // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every(child => typeof child == \"object\" && \"_type\" in child)\n  );\n}\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem == \"string\" && (typeof block.level > \"u\" || typeof block.level == \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) return [];\n  if (!span.marks.length) return [];\n  const marks = span.marks.slice(),\n    occurences = {};\n  return marks.forEach(mark => {\n    occurences[mark] = 1;\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;else break;\n    }\n  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA],\n    bOccurences = occurences[markB];\n  if (aOccurences !== bOccurences) return bOccurences - aOccurences;\n  const aKnownPos = knownDecorators.indexOf(markA),\n    bKnownPos = knownDecorators.indexOf(markB);\n  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n  var _a;\n  const {\n    children,\n    markDefs = []\n  } = block;\n  if (!children || !children.length) return [];\n  const sortedMarks = children.map(sortMarksByOccurences),\n    rootNode = {\n      _type: \"@span\",\n      children: [],\n      markType: \"<unknown>\"\n    };\n  let nodeStack = [rootNode];\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n    if (!span) continue;\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {\n      const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\",\n        index = marksNeeded.indexOf(mark);\n      if (index === -1) break;\n      marksNeeded.splice(index, 1);\n    }\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n    if (currentNode) {\n      for (const markKey of marksNeeded) {\n        const markDef = markDefs.find(def => def._key === markKey),\n          markType = markDef ? markDef._type : markKey,\n          node = {\n            _type: \"@span\",\n            _key: span._key,\n            children: [],\n            markDef,\n            markType,\n            markKey\n          };\n        currentNode.children.push(node), nodeStack.push(node), currentNode = node;\n      }\n      if (isPortableTextSpan(span)) {\n        const lines = span.text.split(`\n`);\n        for (let line = lines.length; line-- > 1;) lines.splice(line, 0, `\n`);\n        currentNode.children = currentNode.children.concat(lines.map(text => ({\n          _type: \"@text\",\n          text\n        })));\n      } else currentNode.children = currentNode.children.concat(span);\n    }\n  }\n  return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n    if (block) {\n      if (!isPortableTextListItemBlock(block)) {\n        tree.push(block), currentList = void 0;\n        continue;\n      }\n      if (!currentList) {\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (blockMatchesList(block, currentList)) {\n        currentList.children.push(block);\n        continue;\n      }\n      if ((block.level || 1) > currentList.level) {\n        const newList = listFromBlock(block, i, mode);\n        if (mode === \"html\") {\n          const lastListItem = currentList.children[currentList.children.length - 1],\n            newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n              children: [...lastListItem.children, newList]\n            });\n          currentList.children[currentList.children.length - 1] = newLastChild;\n        } else currentList.children.push(newList);\n        currentList = newList;\n        continue;\n      }\n      if ((block.level || 1) < currentList.level) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, block);\n        if (match) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        }\n        currentList = listFromBlock(block, i, mode), tree.push(currentList);\n        continue;\n      }\n      if (block.listItem !== currentList.listItem) {\n        const matchingBranch = tree[tree.length - 1],\n          match = matchingBranch && findListMatching(matchingBranch, {\n            level: block.level || 1\n          });\n        if (match && match.listItem === block.listItem) {\n          currentList = match, currentList.children.push(block);\n          continue;\n        } else {\n          currentList = listFromBlock(block, i, mode), tree.push(currentList);\n          continue;\n        }\n      }\n      console.warn(\"Unknown state encountered for block\", block), tree.push(block);\n    }\n  }\n  return tree;\n}\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1,\n    style = matching.listItem || \"normal\",\n    filterOnType = typeof matching.listItem == \"string\";\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) return rootNode;\n  if (!(\"children\" in rootNode)) return;\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nfunction spanToPlainText(span) {\n  let text = \"\";\n  return span.children.forEach(current => {\n    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));\n  }), text;\n}\nconst leadingSpace = /^\\s/,\n  trailingSpace = /^\\s/;\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  return blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) return;\n    let pad = !1;\n    current.children.forEach(span => {\n      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\", text += span.text, pad = !1) : pad = !0;\n    }), index !== blocks.length - 1 && (text += `\n\n`);\n  }), text;\n}\nconst LIST_NEST_MODE_HTML = \"html\",\n  LIST_NEST_MODE_DIRECT = \"direct\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSw0Q0FBNEMsMkJBQTJCLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7QUFDL04sNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscUNBQXFDO0FBQzVFO0FBQ0EsMklBQTJJO0FBQzNJO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1CQUFtQjtBQUM1RTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQixNQUFNLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ2lTO0FBQ2pTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5jb21tb25vcmctYmxvZy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3Rvb2xraXQvZGlzdC9pbmRleC5qcz82ZDE4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID4gXCJ1XCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KG1hcmsgPT4gdHlwZW9mIG1hcmsgPT0gXCJzdHJpbmdcIikpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBibG9jayBkb2Vzbid0IF9oYXZlXyB0byBiZSBuYW1lZCAnYmxvY2snIC0gdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuXG4gICAgLy8gYWxsb3dlZCBjaGlsZCB0eXBlcyBhbmQgbWFya3MsIG9uZSBtaWdodCBuYW1lIHRoZW0gZGlmZmVyZW50bHlcbiAgICB0eXBlb2Ygbm9kZS5fdHlwZSA9PSBcInN0cmluZ1wiICYmXG4gICAgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIChcbiAgICAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJlxuICAgIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoZGVmID0+IHR5cGVvZiBkZWYuX2tleSA9PSBcInN0cmluZ1wiKSkgJiZcbiAgICAvLyBgY2hpbGRyZW5gIGlzIHJlcXVpcmVkIGFuZCBuZWVkcyB0byBiZSBhbiBhcnJheVxuICAgIFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikgJiZcbiAgICAvLyBBbGwgY2hpbGRyZW4gYXJlIG9iamVjdHMgd2l0aCBgX3R5cGVgICh1c3VhbGx5IHNwYW5zLCBidXQgY2FuIGNvbnRhaW4gb3RoZXIgc3R1ZmYpXG4gICAgbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiB0eXBlb2YgY2hpbGQgPT0gXCJvYmplY3RcIiAmJiBcIl90eXBlXCIgaW4gY2hpbGQpXG4gICk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2soYmxvY2spIHtcbiAgcmV0dXJuIGlzUG9ydGFibGVUZXh0QmxvY2soYmxvY2spICYmIFwibGlzdEl0ZW1cIiBpbiBibG9jayAmJiB0eXBlb2YgYmxvY2subGlzdEl0ZW0gPT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGJsb2NrLmxldmVsID4gXCJ1XCIgfHwgdHlwZW9mIGJsb2NrLmxldmVsID09IFwibnVtYmVyXCIpO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0TGlzdChibG9jaykge1xuICByZXR1cm4gYmxvY2suX3R5cGUgPT09IFwiQGxpc3RcIjtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oc3Bhbikge1xuICByZXR1cm4gc3Bhbi5fdHlwZSA9PT0gXCJAc3BhblwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJAdGV4dFwiO1xufVxuY29uc3Qga25vd25EZWNvcmF0b3JzID0gW1wic3Ryb25nXCIsIFwiZW1cIiwgXCJjb2RlXCIsIFwidW5kZXJsaW5lXCIsIFwic3RyaWtlLXRocm91Z2hcIl07XG5mdW5jdGlvbiBzb3J0TWFya3NCeU9jY3VyZW5jZXMoc3BhbiwgaW5kZXgsIGJsb2NrQ2hpbGRyZW4pIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikgfHwgIXNwYW4ubWFya3MpIHJldHVybiBbXTtcbiAgaWYgKCFzcGFuLm1hcmtzLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBtYXJrcyA9IHNwYW4ubWFya3Muc2xpY2UoKSxcbiAgICBvY2N1cmVuY2VzID0ge307XG4gIHJldHVybiBtYXJrcy5mb3JFYWNoKG1hcmsgPT4ge1xuICAgIG9jY3VyZW5jZXNbbWFya10gPSAxO1xuICAgIGZvciAobGV0IHNpYmxpbmdJbmRleCA9IGluZGV4ICsgMTsgc2libGluZ0luZGV4IDwgYmxvY2tDaGlsZHJlbi5sZW5ndGg7IHNpYmxpbmdJbmRleCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gYmxvY2tDaGlsZHJlbltzaWJsaW5nSW5kZXhdO1xuICAgICAgaWYgKHNpYmxpbmcgJiYgaXNQb3J0YWJsZVRleHRTcGFuKHNpYmxpbmcpICYmIEFycmF5LmlzQXJyYXkoc2libGluZy5tYXJrcykgJiYgc2libGluZy5tYXJrcy5pbmRleE9mKG1hcmspICE9PSAtMSkgb2NjdXJlbmNlc1ttYXJrXSsrO2Vsc2UgYnJlYWs7XG4gICAgfVxuICB9KSwgbWFya3Muc29ydCgobWFya0EsIG1hcmtCKSA9PiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSk7XG59XG5mdW5jdGlvbiBzb3J0TWFya3Mob2NjdXJlbmNlcywgbWFya0EsIG1hcmtCKSB7XG4gIGNvbnN0IGFPY2N1cmVuY2VzID0gb2NjdXJlbmNlc1ttYXJrQV0sXG4gICAgYk9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtCXTtcbiAgaWYgKGFPY2N1cmVuY2VzICE9PSBiT2NjdXJlbmNlcykgcmV0dXJuIGJPY2N1cmVuY2VzIC0gYU9jY3VyZW5jZXM7XG4gIGNvbnN0IGFLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtBKSxcbiAgICBiS25vd25Qb3MgPSBrbm93bkRlY29yYXRvcnMuaW5kZXhPZihtYXJrQik7XG4gIHJldHVybiBhS25vd25Qb3MgIT09IGJLbm93blBvcyA/IGFLbm93blBvcyAtIGJLbm93blBvcyA6IG1hcmtBLmxvY2FsZUNvbXBhcmUobWFya0IpO1xufVxuZnVuY3Rpb24gYnVpbGRNYXJrc1RyZWUoYmxvY2spIHtcbiAgdmFyIF9hO1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbWFya0RlZnMgPSBbXVxuICB9ID0gYmxvY2s7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIFtdO1xuICBjb25zdCBzb3J0ZWRNYXJrcyA9IGNoaWxkcmVuLm1hcChzb3J0TWFya3NCeU9jY3VyZW5jZXMpLFxuICAgIHJvb3ROb2RlID0ge1xuICAgICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG1hcmtUeXBlOiBcIjx1bmtub3duPlwiXG4gICAgfTtcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzcGFuID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCFzcGFuKSBjb250aW51ZTtcbiAgICBjb25zdCBtYXJrc05lZWRlZCA9IHNvcnRlZE1hcmtzW2ldIHx8IFtdO1xuICAgIGxldCBwb3MgPSAxO1xuICAgIGlmIChub2RlU3RhY2subGVuZ3RoID4gMSkgZm9yIChwb3M7IHBvcyA8IG5vZGVTdGFjay5sZW5ndGg7IHBvcysrKSB7XG4gICAgICBjb25zdCBtYXJrID0gKChfYSA9IG5vZGVTdGFja1twb3NdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya0tleSkgfHwgXCJcIixcbiAgICAgICAgaW5kZXggPSBtYXJrc05lZWRlZC5pbmRleE9mKG1hcmspO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkgYnJlYWs7XG4gICAgICBtYXJrc05lZWRlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBub2RlU3RhY2sgPSBub2RlU3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlU3RhY2tbbm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgZm9yIChjb25zdCBtYXJrS2V5IG9mIG1hcmtzTmVlZGVkKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWYgPSBtYXJrRGVmcy5maW5kKGRlZiA9PiBkZWYuX2tleSA9PT0gbWFya0tleSksXG4gICAgICAgICAgbWFya1R5cGUgPSBtYXJrRGVmID8gbWFya0RlZi5fdHlwZSA6IG1hcmtLZXksXG4gICAgICAgICAgbm9kZSA9IHtcbiAgICAgICAgICAgIF90eXBlOiBcIkBzcGFuXCIsXG4gICAgICAgICAgICBfa2V5OiBzcGFuLl9rZXksXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgICAgbWFya1R5cGUsXG4gICAgICAgICAgICBtYXJrS2V5XG4gICAgICAgICAgfTtcbiAgICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKSwgbm9kZVN0YWNrLnB1c2gobm9kZSksIGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzcGFuLnRleHQuc3BsaXQoYFxuYCk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgPSBsaW5lcy5sZW5ndGg7IGxpbmUtLSA+IDE7KSBsaW5lcy5zcGxpY2UobGluZSwgMCwgYFxuYCk7XG4gICAgICAgIGN1cnJlbnROb2RlLmNoaWxkcmVuID0gY3VycmVudE5vZGUuY2hpbGRyZW4uY29uY2F0KGxpbmVzLm1hcCh0ZXh0ID0+ICh7XG4gICAgICAgICAgX3R5cGU6IFwiQHRleHRcIixcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0pKSk7XG4gICAgICB9IGVsc2UgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKGJsb2NrKSB7XG4gICAgICBpZiAoIWlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykpIHtcbiAgICAgICAgdHJlZS5wdXNoKGJsb2NrKSwgY3VycmVudExpc3QgPSB2b2lkIDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGlzdCkge1xuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA+IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgICAgY29uc3QgbGFzdExpc3RJdGVtID0gY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBuZXdMYXN0Q2hpbGQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxhc3RMaXN0SXRlbSksIHt9LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLi4ubGFzdExpc3RJdGVtLmNoaWxkcmVuLCBuZXdMaXN0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW5bY3VycmVudExpc3QuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBuZXdMYXN0Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKG5ld0xpc3QpO1xuICAgICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwgYmxvY2spO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjdXJyZW50TGlzdCA9IG1hdGNoLCBjdXJyZW50TGlzdC5jaGlsZHJlbi5wdXNoKGJsb2NrKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpLCB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChibG9jay5saXN0SXRlbSAhPT0gY3VycmVudExpc3QubGlzdEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCcmFuY2ggPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7XG4gICAgICAgICAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMVxuICAgICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGlzdEl0ZW0gPT09IGJsb2NrLmxpc3RJdGVtKSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaCwgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKSwgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBzdGF0ZSBlbmNvdW50ZXJlZCBmb3IgYmxvY2tcIiwgYmxvY2spLCB0cmVlLnB1c2goYmxvY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGJsb2NrTWF0Y2hlc0xpc3QoYmxvY2ssIGxpc3QpIHtcbiAgcmV0dXJuIChibG9jay5sZXZlbCB8fCAxKSA9PT0gbGlzdC5sZXZlbCAmJiBibG9jay5saXN0SXRlbSA9PT0gbGlzdC5saXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGxpc3RGcm9tQmxvY2soYmxvY2ssIGluZGV4LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgX3R5cGU6IFwiQGxpc3RcIixcbiAgICBfa2V5OiBgJHtibG9jay5fa2V5IHx8IGAke2luZGV4fWB9LXBhcmVudGAsXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMSxcbiAgICBzdHlsZSA9IG1hdGNoaW5nLmxpc3RJdGVtIHx8IFwibm9ybWFsXCIsXG4gICAgZmlsdGVyT25UeXBlID0gdHlwZW9mIG1hdGNoaW5nLmxpc3RJdGVtID09IFwic3RyaW5nXCI7XG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSByZXR1cm4gcm9vdE5vZGU7XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHJldHVybjtcbiAgY29uc3Qgbm9kZSA9IHJvb3ROb2RlLmNoaWxkcmVuW3Jvb3ROb2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZSAmJiAhaXNQb3J0YWJsZVRleHRTcGFuKG5vZGUpID8gZmluZExpc3RNYXRjaGluZyhub2RlLCBtYXRjaGluZykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzcGFuVG9QbGFpblRleHQoc3Bhbikge1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIHJldHVybiBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgaXNQb3J0YWJsZVRleHRUb29sa2l0VGV4dE5vZGUoY3VycmVudCkgPyB0ZXh0ICs9IGN1cnJlbnQudGV4dCA6IGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkgJiYgKHRleHQgKz0gc3BhblRvUGxhaW5UZXh0KGN1cnJlbnQpKTtcbiAgfSksIHRleHQ7XG59XG5jb25zdCBsZWFkaW5nU3BhY2UgPSAvXlxccy8sXG4gIHRyYWlsaW5nU3BhY2UgPSAvXlxccy87XG5mdW5jdGlvbiB0b1BsYWluVGV4dChibG9jaykge1xuICBjb25zdCBibG9ja3MgPSBBcnJheS5pc0FycmF5KGJsb2NrKSA/IGJsb2NrIDogW2Jsb2NrXTtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICByZXR1cm4gYmxvY2tzLmZvckVhY2goKGN1cnJlbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BvcnRhYmxlVGV4dEJsb2NrKGN1cnJlbnQpKSByZXR1cm47XG4gICAgbGV0IHBhZCA9ICExO1xuICAgIGN1cnJlbnQuY2hpbGRyZW4uZm9yRWFjaChzcGFuID0+IHtcbiAgICAgIGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSA/ICh0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCIsIHRleHQgKz0gc3Bhbi50ZXh0LCBwYWQgPSAhMSkgOiBwYWQgPSAhMDtcbiAgICB9KSwgaW5kZXggIT09IGJsb2Nrcy5sZW5ndGggLSAxICYmICh0ZXh0ICs9IGBcblxuYCk7XG4gIH0pLCB0ZXh0O1xufVxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiLFxuICBMSVNUX05FU1RfTU9ERV9ESVJFQ1QgPSBcImRpcmVjdFwiO1xuZXhwb3J0IHsgTElTVF9ORVNUX01PREVfRElSRUNULCBMSVNUX05FU1RfTU9ERV9IVE1MLCBidWlsZE1hcmtzVHJlZSwgaXNQb3J0YWJsZVRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrLCBpc1BvcnRhYmxlVGV4dFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QsIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBuZXN0TGlzdHMsIHNvcnRNYXJrc0J5T2NjdXJlbmNlcywgc3BhblRvUGxhaW5UZXh0LCB0b1BsYWluVGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;